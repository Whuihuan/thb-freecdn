{"version":3,"sources":["freecdn-main.js","main-js/src/hook.ts","core-lib/src/global.ts","core-lib/src/param-base.ts","core-lib/src/key-manager.ts","core-lib/src/manifest.ts","core-lib/src/url-conf.ts","core-lib/src/url-loader.ts","core-lib/src/file-conf.ts","core-lib/src/file-loader.ts","core-lib/src/updater.ts","core-lib/src/freecdn.ts","core-lib/src/promisex.ts","main-js/src/sw.ts","core-lib/src/param-mods/br.ts","core-lib/src/param-mods/bundle.ts","core-lib/src/param-mods/charset.ts","core-lib/src/param-mods/concat.ts","core-lib/src/param-mods/data.ts","core-lib/src/param-mods/expires.ts","core-lib/src/param-mods/hash.ts","core-lib/src/param-mods/headers.ts","core-lib/src/param-mods/open-timeout.ts","core-lib/src/param-mods/pos.ts","core-lib/src/param-mods/prefix.ts","core-lib/src/param-mods/recv-timeout.ts","core-lib/src/param-mods/referrer-policy.ts","core-lib/src/param-mods/req-headers.ts","core-lib/src/param-mods/size.ts","core-lib/src/param-mods/stream.ts","core-lib/src/param-mods/suffix.ts","core-lib/src/param-mods/valid-status.ts","core-lib/src/param-mods/xor.ts","core-lib/src/cache-manager.ts","core-lib/src/network.ts","core-lib/src/param-mods/mime/mime.ts","core-lib/src/param-mods/mime/mime-data.ts","core-lib/src/database.ts","core-lib/src/util.ts","core-lib/src/zone-host.ts"],"names":["Hook","func","obj","key","factory","oldFn","newFn","prop","getterFactory","setterFactory","desc","Object","getOwnPropertyDescriptor","defineProperty","MY_URL","location","href","MY_HOST","host","MY_ORIGIN","origin","ROOT_PATH","INTERNAL_PATH","URL","pathname","REG_IMG_EXTS","NATIVE_FETCH","fetch","EMPTY_BUF","Uint8Array","CRYPTO","crypto","subtle","gInited","ParamError","Error","constructor","message","super","ParamBase","onRequest","reqArgs","fileLoader","onResponse","resArgs","rawRes","onData","chunk","onEnd","onError","error","onAbort","reason","KeyManager","mKey","set","async","keyBase64","keyBin","base64Decode","importKey","name","namedCurve","verify","data","linePos","lastIndexOf","m","bytesToUtf8","subarray","match","signBin","dataBin","hash","REG_HEAD_LINE","Manifest","this","urlFileMap","Map","has","get","getParams","fileConf","parse","params","txt","parseFile","inc","cdn","FreeCDN","manifest","rets","getLines","map","fetchText","Promise","all","forEach","last","exec","toRelUrl","curr","index","length","part","substring","conf","FileConf","lastIndex","m0","m1","globalParams","UrlConf","url","fileParams","frag","getPair","static","nameClassMap","ParamData","bundle","ParamBundle","concat","ParamConcat","open_timeout","ParamOpenTimeout","recv_timeout","ParamRecvTimeout","referrer_policy","ParamReferrerPolicy","req_headers","ParamReqHeaders","valid_status","ParamValidStatus","headers","ParamHeaders","expires","ParamExpires","mime","ParamMime","charset","ParamCharset","pos","ParamPos","size","ParamSize","xor","ParamXor","br","ParamBr","prefix","ParamPrefix","suffix","ParamSuffix","ParamHash","stream","ParamStream","values","cls","i","priority","mergeMap","getHostFromUrl","hostParams","URLSearchParams","mods","k","v","console","warn","ret","parseConf","undefined","push","sort","a","b","UrlLoader","paramMods","isFetchDone","bytesRead","err","isNetErr","loadUnsafe","e","abortCtrl","signal","aborted","mod","abort","rawReq","method","referrer","referrerPolicy","Headers","res","body","clone","arrayBuffer","isPromise","AbortController","req","Request","Network","status","statusText","contentLen","contentRange","rangeBegin","reader","getReader","buf","READ","value","read","pauseSignal","pause","promisex","resume","resolve","REG_SUB_LINE","text","lines","urlConfs","line","test","urlConf","val","FILE_BACKUP_PARAMS","FileLoaderError","FileLoader","range","urlLoaderSet","Set","isPaused","isAborted","delayTid","urlErrs","hasRange","opened","closed","r","parseReqRange","rangeEnd","fileSize","vUrlConf","backupParams","backupUrlConf","begin","end","buildResRange","len","open","loadNextUrl","urlLoader","clearTimeout","getNextUrl","weight","now","getTimeSec","w","getUrlWeight","weightConf","delay","getSourceUrl","setTimeout","createUrlLoader","getTargetUrl","endsWith","add","exceed","delete","onOpen","load","EMPTY_PARAMS","Updater","manifestPath","onAvailable","urlWsMap","wsArgs","manifestHash","pollingTimer","pollingInterval","lastTime","setSvcTimer","backupUrls","assert","path","search","encodeURIComponent","manifestUrl","CacheManager","findCache","bin","getManifestFromCache","update","updateSignal","Date","updateUnsafe","fetchManifest","applyManifest","ctl","tid","cache","bytes","sha256","isArrayEqual","Response","addCache","applyConfs","parseBackupParam","interval","parseIntervalParam","setPollingInterval","svcUrls","parseServicesParam","setServices","splitList","str","num","parseTime","isNaN","clearInterval","setInterval","urls","ws","includes","onclose","close","createSvc","WebSocket","binaryType","onmessage","hashBin","enableCacheStorage","isSubReq","inited","updater","updateConf","parseWeightConf","input","init","FIND","urlObj","originPrefix","replace","file","mode","integrity","accept","redirect","dir","fileHash","hashParam","cacheable","findHash","promiseObj","addEventListener","args","cacheRes","addHash","reject","controller","checkPressure","desiredSize","ReadableStream","start","c","pull","cancel","enqueue","type","Blob","keyB64","globalInit","p","then","Sw","GLOBAL","self","mLoaderJsRes","mFreeCDN","mIniting","mResUrlMap","sharedModeHandler","loaderModeHandler","request","result","isSharedMode","FREECDN_SHARED_MODE","publicKey","Cache","prototype","put","reqs","tasks","WeakMap","getter","call","FREECDN_PUBLIC_KEY","Q","shift","setPublicKey","splice","loaderModeInit","log","main","state","BR_WASM_PATH","BR_GLUE_PATH","BR_MANIFEST","hasErr","timer","asmMod","locateFile","onRuntimeInitialized","inPtr","_AllocInBuf","outPtr","_AllocOutBuf","print","msg","printErr","onFetch","js","Function","fn","waitWasm","process","destory","asmObj","HEAPU8","_Init","outBufs","inBuf","avaiablelIn","availableOut","_Update","_GetErrorCode","_GetAvailableIn","_GetAvailableOut","outBuf","slice","_HasMoreOutput","concatBufs","_Destroy","packUrl","fileMap","cacheMap","loadPkg","pkgBin","fetchBin","indexOf","confMap","parseJson","bodyBin","offset","entries","fileBuf","REG_TEXT_MIME","reuse","partLen","parseByteUnit","fileInfos","REG_WILDCARD","beginNum","endNum","padNum","beginStr","realUrl","padStart","reverse","pop","openNextFile","info","readNextChunk","parseStrOrB64","seconds","time","rawMaxAge","_maxage","maxAge","append","blkLen","hashBins","queueArr","queueLen","hasData","hashes","blkLenStr","hashB64s","split","remain","head","blks","tail","blk","hashExp","hashGot","exp","base64Encode","got","preserveAll","rawVal","Math","max","stopTimer","done","sum","n","t","REG_REFFERER_POLICY","policy","codes","Number","_a","ext","toLowerCase","extTypeMap","rawType","item","exts","mCache","reqInfo","delCache","caches","Database","opts","s","indexedDB","onsuccess","idb","db","onerror","onupgradeneeded","createObjectStore","table","getStore","record","enum","callback","openCursor","continue","transaction","objectStore","mDatabase","mUrlInfoMap","addUrlInfo","expire","HostInfo","lastDoneTime","lastErrTime","pending","errNum","reqNum","reqTimeAvg","reqTimeSum","mHostInfoMap","getHostInfo","hostWeightMap","urlInfo","hostInfo","delayScore","getHostWeight","t0","navigator","onLine","REG_NET_ERR","parseFetchError","cacheControl","t1","parseMaxAge","parseEntries","list","timeBase","performance","timeOrigin","responseEnd","responseStart","reqTime","requestStart","keyPath","getEntriesByType","PerformanceObserver","entryList","getEntries","observe","entryTypes","zone","language","zone0","weightParams","ZONE_HOST_SCORE","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","decode","btoa","reduce","String","fromCharCode","bytesToAsc","atob","charCodeAt","JSON","trim","encode","utf8ToBytes","TIME_UNIT","ms","min","h","d","y","NaN","unit","kMG","bB","bufs","b1","b2","delim","dst","src","startsWith","digest"],"mappings":"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","file":"freecdn-main.min.js","sourcesContent":["\"use strict\";\n/**\n * JS Hook Util\n * example: https://codepen.io/etherdream/pen/WNoQQbG?editors=0012\n */\nvar Hook;\n(function (Hook) {\n    /**\n     * hook function\n     */\n    function func(obj, key, factory) {\n        const oldFn = obj[key];\n        if (!oldFn) {\n            return false;\n        }\n        const newFn = factory(oldFn);\n        obj[key] = newFn;\n        return true;\n    }\n    Hook.func = func;\n    /**\n     * hook property\n     */\n    function prop(obj, key, getterFactory, setterFactory) {\n        const desc = Object.getOwnPropertyDescriptor(obj, key);\n        if (!desc) {\n            return false;\n        }\n        if (getterFactory) {\n            func(desc, 'get', getterFactory);\n        }\n        if (setterFactory) {\n            func(desc, 'set', setterFactory);\n        }\n        Object.defineProperty(obj, key, desc);\n        return true;\n    }\n    Hook.prop = prop;\n})(Hook || (Hook = {}));\nconst IS_DEBUG = typeof RELEASE === 'undefined';\nconst DEFAULT_PARAMS = `\n@__default__\n expires=30s\n mime=auto\n open_timeout=10s\n valid_status=200\n`;\nconst DEFAULT_MANIFEST_PATH = '/freecdn-internal/freecdn-manifest.txt';\nconst MY_URL = location.href;\nconst MY_HOST = location.host;\nconst MY_ORIGIN = location.origin;\nconst ROOT_PATH = MY_ORIGIN + '/';\nconst INTERNAL_DIR = 'freecdn-internal/' + (IS_DEBUG ? 'dev' : VER);\nconst INTERNAL_PATH = new URL(INTERNAL_DIR, ROOT_PATH).pathname;\nconst REG_IMG_EXTS = /\\.(?:jpg|jpeg|png|apng|gif|ico|bmp)$/i;\nconst NATIVE_FETCH = fetch;\nconst EMPTY_BUF = new Uint8Array(0);\nconst CRYPTO = crypto.subtle;\nlet gInited;\nasync function globalInit() {\n    if (gInited) {\n        return gInited;\n    }\n    gInited = promisex();\n    await CacheManager.init();\n    await Network.init();\n    UrlConf.init();\n    gInited.resolve();\n    gInited = true;\n}\nclass ParamError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass ParamBase {\n    onRequest(reqArgs, fileLoader) {\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n    }\n    onData(chunk) {\n        return chunk;\n    }\n    onEnd(chunk) {\n        return chunk;\n    }\n    onError(error) {\n    }\n    onAbort(reason) {\n    }\n}\nvar KeyManager;\n(function (KeyManager) {\n    let mKey;\n    async function set(keyBase64) {\n        const keyBin = base64Decode(keyBase64);\n        if (!keyBin) {\n            return;\n        }\n        mKey = await CRYPTO.importKey('spki', keyBin, {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, false, ['verify']);\n    }\n    KeyManager.set = set;\n    async function verify(data) {\n        if (!mKey) {\n            return false;\n        }\n        const linePos = data.lastIndexOf(10); // 10 = '\\n'\n        const lineBin = data.subarray(linePos + 1);\n        const lineTxt = bytesToUtf8(lineBin);\n        const m = lineTxt.match(/# SIGN: ([A-Za-z0-9+/=]{88})$/);\n        if (!m) {\n            return false;\n        }\n        const signTxt = m[1];\n        const signBin = base64Decode(signTxt);\n        const dataBin = data.subarray(0, linePos);\n        return await CRYPTO.verify({\n            name: 'ECDSA',\n            hash: {\n                name: 'SHA-256'\n            },\n        }, mKey, signBin, dataBin);\n    }\n    KeyManager.verify = verify;\n})(KeyManager || (KeyManager = {}));\n//\n// \n//\n// (http://foo/path/to/file)\n//    ...\n// (/path/to/file)\n//    ...\n// (@config)\n//    ...\n//  $0  lastIndex \n//\nconst REG_HEAD_LINE = /^(?:\\/|https?:|@).*/mg;\nclass Manifest {\n    constructor() {\n        this.urlFileMap = new Map();\n    }\n    has(key) {\n        return this.urlFileMap.has(key);\n    }\n    get(key) {\n        return this.urlFileMap.get(key);\n    }\n    getParams(name) {\n        const fileConf = this.get(name);\n        if (fileConf) {\n            fileConf.parse();\n            return fileConf.params;\n        }\n    }\n    async parse(txt) {\n        this.parseFile(txt + DEFAULT_PARAMS);\n        const inc = this.urlFileMap.get('@include');\n        if (inc) {\n            const cdn = new FreeCDN();\n            cdn.manifest = this;\n            const urls = inc.getLines();\n            const rets = urls.map(cdn.fetchText, cdn);\n            const txts = await Promise.all(rets);\n            txts.forEach(this.parseFile, this);\n        }\n    }\n    parseFile(txt) {\n        // lazy parse\n        let name = '';\n        let last = 0;\n        for (;;) {\n            const m = REG_HEAD_LINE.exec(txt);\n            if (last > 0) {\n                if (name[0] !== '@') {\n                    name = toRelUrl(name);\n                }\n                const curr = m ? m.index : txt.length;\n                const part = txt.substring(last, curr);\n                const conf = new FileConf(name, part);\n                this.urlFileMap.set(name, conf);\n            }\n            if (!m) {\n                break;\n            }\n            name = m[0];\n            last = REG_HEAD_LINE.lastIndex;\n        }\n        const m0 = this.getParams('@__default__');\n        const m1 = this.getParams('@global');\n        this.globalParams = m1 ? new Map([...m0, ...m1]) : m0;\n    }\n}\nclass UrlConf {\n    constructor(url, fileParams) {\n        this.fileParams = fileParams;\n        if (url) {\n            [this.url, this.frag] = getPair(toRelUrl(url), '#');\n        }\n    }\n    static init() {\n        // \n        // \n        this.nameClassMap = {\n            // \n            'data': ParamData,\n            'bundle': ParamBundle,\n            'concat': ParamConcat,\n            'open_timeout': ParamOpenTimeout,\n            'recv_timeout': ParamRecvTimeout,\n            'referrer_policy': ParamReferrerPolicy,\n            'req_headers': ParamReqHeaders,\n            'valid_status': ParamValidStatus,\n            'headers': ParamHeaders,\n            'expires': ParamExpires,\n            'mime': ParamMime,\n            'charset': ParamCharset,\n            'pos': ParamPos,\n            'size': ParamSize,\n            'xor': ParamXor,\n            'br': ParamBr,\n            'prefix': ParamPrefix,\n            'suffix': ParamSuffix,\n            'hash': ParamHash,\n            'stream': ParamStream,\n        };\n        Object.values(this.nameClassMap).forEach((cls, i) => {\n            cls.priority = i;\n        });\n    }\n    parse(manifest) {\n        // TODO: cache result\n        const params = new Map();\n        // :  <  <  < URL \n        mergeMap(params, manifest.globalParams);\n        // \n        if (this.url) {\n            const host = this.url[0] === '/' ? MY_HOST : getHostFromUrl(this.url);\n            const hostParams = manifest.getParams('@host ' + host);\n            if (hostParams) {\n                mergeMap(params, hostParams);\n            }\n        }\n        // \n        mergeMap(params, this.fileParams);\n        // URL  # \n        if (this.frag) {\n            const urlParams = new URLSearchParams(this.frag);\n            mergeMap(params, urlParams);\n        }\n        const mods = [];\n        for (const [k, v] of params) {\n            const cls = UrlConf.nameClassMap[k];\n            if (!cls) {\n                console.warn('[FreeCDN/UrlConf] unknown param:', k);\n                continue;\n            }\n            const ret = cls.parseConf(v);\n            if (ret === undefined) {\n                continue;\n            }\n            if (typeof ret === 'string') {\n                console.warn('[FreeCDN/UrlConf] parseConf failed. mod:', k, 'err:', ret, 'conf:', v);\n                continue;\n            }\n            const obj = new cls(...ret);\n            mods.push(obj);\n        }\n        mods.sort((a, b) => a.constructor.priority -\n            b.constructor.priority);\n        return mods;\n    }\n}\nclass UrlLoader {\n    constructor(url, paramMods) {\n        this.url = url;\n        this.paramMods = paramMods;\n        this.isFetchDone = false;\n        this.bytesRead = 0;\n    }\n    async load(fileLoader) {\n        let isNetErr = false;\n        let err;\n        try {\n            //  fetch \n            //  catch \n            err = await this.loadUnsafe(fileLoader);\n            isNetErr = !!err;\n        }\n        catch (e) {\n            // \n            // console.assert(e instanceof ParamError, e)\n            err = e;\n        }\n        if (err) {\n            if (this.abortCtrl && !this.abortCtrl.signal.aborted) {\n                for (const mod of this.paramMods) {\n                    mod.onError(err);\n                }\n                this.onError(err);\n                if (!isNetErr) {\n                    this.abort(err);\n                }\n            }\n        }\n    }\n    async loadUnsafe(fileLoader) {\n        const { rawReq } = fileLoader;\n        const { method } = rawReq;\n        const reqArgs = {\n            method,\n            referrer: rawReq.referrer,\n            referrerPolicy: 'same-origin',\n            headers: new Headers(),\n        };\n        if (method === 'POST' || method === 'PUT') {\n            reqArgs.body = await rawReq.clone().arrayBuffer();\n        }\n        let res;\n        for (const mod of this.paramMods) {\n            //  data bundle \n            const ret = mod.onRequest(reqArgs, fileLoader);\n            if (ret) {\n                res = isPromise(ret) ? await ret : ret;\n                if (res) {\n                    break;\n                }\n            }\n        }\n        if (!res) {\n            if (!this.url) {\n                this.onError(Error('vURL no data'));\n                return;\n            }\n            this.abortCtrl = new AbortController();\n            reqArgs.signal = this.abortCtrl.signal;\n            const req = new Request(this.url, reqArgs);\n            try {\n                res = await Network.fetch(req);\n            }\n            catch (err) {\n                return err;\n            }\n        }\n        if (!res.body) {\n            return Error('cors error');\n        }\n        const resArgs = {\n            status: res.status,\n            statusText: res.statusText,\n            headers: new Headers(),\n            contentLen: -1,\n        };\n        if (!res.headers.has('content-encoding')) {\n            const contentLen = res.headers.get('content-length');\n            if (contentLen) {\n                resArgs.contentLen = +contentLen;\n            }\n        }\n        for (const mod of this.paramMods) {\n            mod.onResponse(resArgs, fileLoader, res);\n        }\n        const contentRange = res.headers.get('content-range');\n        if (contentRange) {\n            const m = contentRange.match(/bytes (\\d+)-/i);\n            if (m) {\n                const rangeBegin = +m[1];\n                if (rangeBegin > 0) {\n                    this.bytesRead = rangeBegin;\n                }\n            }\n        }\n        if (resArgs.contentLen !== -1) {\n            resArgs.headers.set('content-length', resArgs.contentLen + '');\n        }\n        this.onResponse(resArgs);\n        const reader = res.body.getReader();\n        let buf;\n        READ: for (;;) {\n            try {\n                const { value } = await reader.read();\n                if (!value) {\n                    break;\n                }\n                buf = value;\n            }\n            catch (err) {\n                return err;\n            }\n            for (const mod of this.paramMods) {\n                const ret = mod.onData(buf);\n                buf = isPromise(ret) ? await ret : ret;\n                if (buf.length === 0) {\n                    continue READ;\n                }\n            }\n            if (buf.length > 0) {\n                this.pauseSignal && await this.pauseSignal;\n                this.bytesRead += buf.length;\n                this.onData(buf);\n            }\n        } // READ NEXT\n        this.isFetchDone = true;\n        buf = EMPTY_BUF;\n        for (const mod of this.paramMods) {\n            const ret = mod.onEnd(buf);\n            buf = isPromise(ret) ? await ret : ret;\n        }\n        if (buf.length > 0) {\n            this.pauseSignal && await this.pauseSignal;\n            this.bytesRead += buf.length;\n            this.onData(buf);\n        }\n        this.onEnd();\n    }\n    pause() {\n        this.pauseSignal = promisex();\n    }\n    resume() {\n        this.pauseSignal?.resolve();\n        this.pauseSignal = undefined;\n    }\n    abort(reason) {\n        if (this.isFetchDone) {\n            return;\n        }\n        this.abortCtrl?.abort();\n        for (const mod of this.paramMods) {\n            mod.onAbort(reason);\n        }\n    }\n}\n//  trim  `#` \nconst REG_SUB_LINE = /^\\s+([^#\\s].+?)\\s*$/mg;\nclass FileConf {\n    constructor(name, text) {\n        this.name = name;\n        this.text = text;\n    }\n    getLines() {\n        const lines = [];\n        for (;;) {\n            const m = REG_SUB_LINE.exec(this.text);\n            if (!m) {\n                break;\n            }\n            lines.push(m[1]);\n        }\n        this.text = '';\n        return lines;\n    }\n    parse() {\n        if (this.text === '') {\n            return;\n        }\n        const urlConfs = [];\n        const params = new Map();\n        for (const line of this.getLines()) {\n            if (/^https?:|^\\//.test(line)) {\n                const urlConf = new UrlConf(line, params);\n                urlConfs.push(urlConf);\n            }\n            else {\n                const [key, val] = getPair(line, '=');\n                if (val === undefined) {\n                    console.warn('[FreeCDN/FileConf] missing param value:', line);\n                    continue;\n                }\n                params.set(key, val);\n            }\n        }\n        this.params = params;\n        this.urlConfs = urlConfs;\n    }\n}\nconst FILE_BACKUP_PARAMS = [\n    'open_timeout',\n    'recv_timeout',\n    'hash',\n    'req_headers',\n    'valid_status',\n];\nclass FileLoaderError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass FileLoader {\n    constructor(fileConf, rawReq, cdn, range, suffix) {\n        this.fileConf = fileConf;\n        this.rawReq = rawReq;\n        this.cdn = cdn;\n        this.range = range;\n        this.suffix = suffix;\n        this.urlLoaderSet = new Set();\n        this.isPaused = false;\n        this.isAborted = false;\n        this.delayTid = 0;\n        this.urlErrs = [];\n        this.hasRange = false;\n        this.opened = false;\n        this.closed = false;\n        this.bytesRead = 0;\n        const fileParams = fileConf.params;\n        if (range) {\n            const r = this.parseReqRange(range);\n            if (r) {\n                [this.rangeBegin, this.rangeEnd] = r;\n                this.hasRange = true;\n                this.bytesRead = this.rangeBegin;\n            }\n            const fileSize = fileParams.get('size');\n            if (fileSize) {\n                this.fileSize = +fileSize;\n            }\n        }\n        if (fileParams.has('data') || fileParams.has('bundle') || fileParams.has('concat')) {\n            this.vUrlConf = new UrlConf(undefined, fileParams);\n        }\n        //  URL \n        // \n        const backupParams = new Map();\n        for (const k of FILE_BACKUP_PARAMS) {\n            const v = fileParams.get(k);\n            if (v !== undefined) {\n                backupParams.set(k, v);\n            }\n        }\n        const backupUrlConf = new UrlConf(fileConf.name, backupParams);\n        this.urlConfs = fileConf.urlConfs.concat(backupUrlConf);\n    }\n    parseReqRange(range) {\n        //  `bytes=begin-end`  `bytes=begin-` \n        const m = range.match(/bytes=(\\d+)-(\\d*)/i);\n        if (!m) {\n            return;\n        }\n        const begin = +m[1];\n        const end = +m[2]; // +'' === 0\n        if (end !== 0 && end <= begin) {\n            return;\n        }\n        return [begin, end];\n    }\n    buildResRange(resArgs) {\n        const begin = this.rangeBegin;\n        let end = 0;\n        if (this.rangeEnd) {\n            end = this.rangeEnd - 1;\n        }\n        else if (this.fileSize) {\n            end = this.fileSize - 1;\n        }\n        else if (resArgs.contentLen > 0) {\n            end = resArgs.contentLen;\n        }\n        const val = 'bytes ' + begin + '-' + end + '/' + (this.fileSize || '*');\n        // TODO: status 416\n        resArgs.status = 206;\n        resArgs.headers.set('content-range', val);\n        if (end > 0) {\n            const len = end - begin + 1;\n            resArgs.headers.set('content-length', len + '');\n        }\n    }\n    open() {\n        this.loadNextUrl();\n    }\n    pause() {\n        if (this.isPaused) {\n            return;\n        }\n        this.isPaused = true;\n        // TODO:  Loader \n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.pause();\n        }\n    }\n    resume() {\n        if (!this.isPaused) {\n            return;\n        }\n        this.isPaused = false;\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.resume();\n        }\n    }\n    abort(reason) {\n        if (this.isAborted) {\n            return;\n        }\n        this.isAborted = true;\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.abort(reason);\n        }\n        if (this.delayTid !== 0) {\n            clearTimeout(this.delayTid);\n        }\n    }\n    getNextUrl() {\n        //  URL data  URL\n        const { vUrlConf } = this;\n        if (vUrlConf) {\n            this.vUrlConf = undefined;\n            return { weight: 100, conf: vUrlConf };\n        }\n        const { urlConfs } = this;\n        const lastIndex = urlConfs.length - 1;\n        if (lastIndex === -1) {\n            return;\n        }\n        const now = getTimeSec();\n        let weight = -10000;\n        let index = 0;\n        urlConfs.forEach((conf, i) => {\n            const w = Network.getUrlWeight(conf.url, now, this.cdn.weightConf);\n            if (w > weight) {\n                weight = w;\n                index = i;\n            }\n        });\n        //  urlConfs[index]\n        const conf = urlConfs[index];\n        urlConfs[index] = urlConfs[lastIndex];\n        urlConfs.length = lastIndex;\n        return { weight, conf };\n    }\n    loadNextUrl(delay = 0) {\n        const ret = this.getNextUrl();\n        if (!ret) {\n            if (this.urlLoaderSet.size === 0) {\n                const err = new FileLoaderError('failed to load: ' + this.getSourceUrl());\n                err.urlErrs = this.urlErrs;\n                this.onError(err);\n            }\n            return;\n        }\n        const { weight, conf } = ret;\n        if (weight < 0 && delay > 0) {\n            //  URL \n            this.delayTid = setTimeout(() => {\n                this.delayTid = 0;\n                this.createUrlLoader(conf);\n            }, delay);\n            return;\n        }\n        this.createUrlLoader(conf);\n    }\n    getSourceUrl() {\n        return this.fileConf.name + this.suffix;\n    }\n    getTargetUrl(url) {\n        if (url.endsWith('/')) {\n            return url + this.suffix;\n        }\n        return url;\n    }\n    createUrlLoader(urlConf) {\n        const url = urlConf.url && this.getTargetUrl(urlConf.url);\n        const mods = urlConf.parse(this.cdn.manifest);\n        const urlLoader = new UrlLoader(url, mods);\n        this.urlLoaderSet.add(urlLoader);\n        urlLoader.onData = (chunk) => {\n            if (this.closed) {\n                return;\n            }\n            const add = urlLoader.bytesRead - this.bytesRead;\n            if (add <= 0) {\n                // \n                return;\n            }\n            if (add !== chunk.length) {\n                chunk = chunk.subarray(-add);\n            }\n            this.bytesRead = urlLoader.bytesRead;\n            if (this.rangeEnd) {\n                const exceed = this.bytesRead - this.rangeEnd;\n                if (exceed > 0) {\n                    chunk = chunk.subarray(0, -exceed);\n                    this.onData(chunk);\n                    urlLoader.onEnd();\n                    return;\n                }\n            }\n            this.onData(chunk);\n        };\n        urlLoader.onEnd = () => {\n            if (this.closed) {\n                return;\n            }\n            this.closed = true;\n            this.onEnd();\n            this.abort('TASK_DONE');\n        };\n        urlLoader.onError = (err) => {\n            this.urlErrs.push({ url: urlLoader.url || '', err });\n            this.urlLoaderSet.delete(urlLoader);\n            this.loadNextUrl();\n        };\n        urlLoader.onResponse = (resArgs) => {\n            if (this.opened) {\n                return;\n            }\n            if (this.hasRange) {\n                this.buildResRange(resArgs);\n            }\n            this.opened = true;\n            this.onOpen(resArgs);\n        };\n        urlLoader.load(this);\n    }\n}\nconst EMPTY_PARAMS = new Map();\nclass Updater {\n    constructor(manifestPath, onAvailable) {\n        this.onAvailable = onAvailable;\n        this.urlWsMap = new Map();\n        this.wsArgs = '';\n        this.manifestHash = EMPTY_BUF;\n        this.pollingTimer = 0;\n        this.pollingInterval = 300000 /* DEFAULT_INTERVAL */;\n        this.lastTime = 0;\n        this.setSvcTimer = 0;\n        this.backupUrls = [];\n        const url = new URL(manifestPath, MY_URL);\n        console.assert(url.host === MY_HOST);\n        const path = url.pathname + url.search;\n        if (path !== DEFAULT_MANIFEST_PATH) {\n            this.wsArgs = '?manifest=' + encodeURIComponent(path);\n        }\n        this.manifestUrl = path;\n    }\n    async getManifestFromCache() {\n        const res = await CacheManager.findCache(this.manifestUrl);\n        if (!res) {\n            return;\n        }\n        const buf = await res.arrayBuffer();\n        const bin = new Uint8Array(buf);\n        // \n        if (!await KeyManager.verify(bin)) {\n            return;\n        }\n        const txt = bytesToUtf8(bin);\n        const manifest = new Manifest();\n        await manifest.parse(txt);\n        return manifest;\n    }\n    async init() {\n        const manifest = await this.getManifestFromCache();\n        if (manifest) {\n            // \n            this.onAvailable(manifest);\n        }\n        await this.update();\n    }\n    async update() {\n        if (this.updateSignal) {\n            return this.updateSignal;\n        }\n        const now = Date.now();\n        if (now - this.lastTime < 1000 /* MIN_INTERVAL */) {\n            return true;\n        }\n        this.lastTime = now;\n        this.updateSignal = promisex();\n        let ret = false;\n        try {\n            ret = await this.updateUnsafe();\n        }\n        catch (err) {\n            console.error('[FreeCDN/Updater] update err:', err);\n        }\n        this.updateSignal.resolve(ret);\n        this.updateSignal = undefined;\n        return ret;\n    }\n    async updateUnsafe() {\n        // from current site\n        const data = await this.fetchManifest(this.manifestUrl);\n        if (data) {\n            await this.applyManifest(data);\n            return true;\n        }\n        console.warn('[FreeCDN/Updater] failed to fetch 1st manifest:', this.manifestUrl);\n        if (this.backupUrls.length === 0) {\n            console.warn('[FreeCDN/Updater] no backup url');\n            return false;\n        }\n        // from backup sites\n        for (const url of this.backupUrls) {\n            const data = await this.fetchManifest(url);\n            if (!data) {\n                console.warn('[FreeCDN/Updater] failed to fetch 3rd manifest:', url);\n                continue;\n            }\n            if (!await KeyManager.verify(data)) {\n                console.warn('[FreeCDN/Updater] failed to verify 3rd manifest:', url);\n                continue;\n            }\n            await this.applyManifest(data);\n            return true;\n        }\n        console.warn('[FreeCDN/Updater] failed to reload');\n        return false;\n    }\n    async fetchManifest(url) {\n        const ctl = new AbortController();\n        const tid = setTimeout(() => {\n            ctl.abort();\n        }, 3000 /* FETCH_TIMEOUT */);\n        const req = new Request(url, {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\n            cache: 'no-cache',\n            signal: ctl.signal,\n        });\n        try {\n            const res = await Network.fetch(req);\n            const bin = await res.arrayBuffer();\n            return new Uint8Array(bin);\n        }\n        catch {\n        }\n        finally {\n            clearTimeout(tid);\n        }\n    }\n    async applyManifest(bytes) {\n        const hash = await sha256(bytes);\n        if (isArrayEqual(this.manifestHash, hash)) {\n            return;\n        }\n        this.manifestHash = hash;\n        // \n        const res = new Response(bytes);\n        res.headers.set('content-length', bytes.length + '');\n        CacheManager.addCache(this.manifestUrl, res);\n        const manifest = new Manifest();\n        const txt = bytesToUtf8(bytes);\n        await manifest.parse(txt);\n        this.onAvailable(manifest);\n    }\n    applyConfs(params) {\n        this.backupUrls = this.parseBackupParam(params);\n        const interval = this.parseIntervalParam(params);\n        this.setPollingInterval(interval);\n        const svcUrls = this.parseServicesParam(params);\n        if (this.setSvcTimer > 0) {\n            clearTimeout(this.setSvcTimer);\n        }\n        // \n        this.setSvcTimer = setTimeout(() => {\n            this.setSvcTimer = 0;\n            this.setServices(svcUrls);\n        }, 5000 /* SET_SVC_DELAY */);\n    }\n    parseBackupParam(params) {\n        const str = params.get('backup') || '';\n        return splitList(str);\n    }\n    parseIntervalParam(params) {\n        const str = params.get('interval');\n        if (str) {\n            const num = parseTime(str);\n            if (!isNaN(num)) {\n                return num;\n            }\n            console.warn('[FreeCDN/Updater] invalid interval:', str);\n        }\n        return 300000 /* DEFAULT_INTERVAL */;\n    }\n    parseServicesParam(params) {\n        const str = params.get('services') || '';\n        return splitList(str);\n    }\n    setPollingInterval(interval) {\n        if (this.pollingInterval === interval) {\n            return;\n        }\n        this.pollingInterval === interval;\n        if (this.pollingTimer) {\n            clearInterval(this.pollingTimer);\n        }\n        if (interval > 0) {\n            this.pollingTimer = setInterval(() => {\n                this.update();\n            }, interval);\n        }\n    }\n    setServices(urls) {\n        for (const [url, ws] of this.urlWsMap) {\n            if (!urls.includes(url)) {\n                ws.onclose = null;\n                ws.close();\n                this.urlWsMap.delete(url);\n            }\n        }\n        for (const url of urls) {\n            if (!this.urlWsMap.has(url)) {\n                this.createSvc(url);\n            }\n        }\n    }\n    createSvc(url) {\n        const ws = new WebSocket(url + this.wsArgs);\n        ws.binaryType = 'arraybuffer';\n        ws.onmessage = (e) => {\n            const hashBin = new Uint8Array(e.data);\n            if (isArrayEqual(this.manifestHash, hashBin)) {\n                return;\n            }\n            this.update();\n        };\n        ws.onclose = () => {\n            this.urlWsMap.delete(url);\n            setTimeout(() => {\n                this.createSvc(url);\n            }, 20000 /* WS_RETRY_DELAY */);\n        };\n        this.urlWsMap.set(url, ws);\n    }\n}\n///<reference path=\"global.ts\"/>\n///<reference path=\"param-base.ts\"/>\n///<reference path=\"key-manager.ts\"/>\n///<reference path=\"manifest.ts\"/>\n///<reference path=\"url-conf.ts\"/>\n///<reference path=\"url-loader.ts\"/>\n///<reference path=\"file-conf.ts\"/>\n///<reference path=\"file-loader.ts\"/>\n///<reference path=\"updater.ts\"/>\nclass FreeCDN {\n    constructor(manifestUrl) {\n        this.enableCacheStorage = true;\n        this.isSubReq = false;\n        this.weightConf = new Map();\n        this.inited = false;\n        if (!manifestUrl) {\n            return;\n        }\n        const updater = new Updater(manifestUrl, manifest => {\n            this.manifest = manifest;\n            const updateConf = manifest.getParams('@update') || EMPTY_PARAMS;\n            updater.applyConfs(updateConf);\n            // \n            this.weightConf = Network.parseWeightConf(manifest);\n        });\n        this.updater = updater;\n    }\n    async fetch(input, init) {\n        const req = (input instanceof Request && !init)\n            ? input\n            : new Request(input, init);\n        if (!/^https?:/.test(req.url)) {\n            return NATIVE_FETCH(req);\n        }\n        const { manifest } = this;\n        if (!manifest) {\n            return Network.fetch(req);\n        }\n        let fileConf;\n        let suffix = '';\n        FIND: for (;;) {\n            const urlObj = new URL(req.url);\n            //  URL \n            const originPrefix = urlObj.origin === MY_ORIGIN ? '' : urlObj.origin;\n            //  URL \n            if (urlObj.search) {\n                fileConf = manifest.get(originPrefix + urlObj.pathname + urlObj.search);\n                if (fileConf) {\n                    break;\n                }\n            }\n            //  `/`\n            const path = urlObj.pathname.replace(/\\/{2,}/g, '/');\n            const file = originPrefix + path;\n            //  avifwebp \n            if (REG_IMG_EXTS.test(file) && req.mode !== 'cors' && !req.integrity) {\n                const accept = req.headers.get('accept') || '';\n                if (accept.includes('image/avif')) {\n                    fileConf = manifest.get(file + '.avif');\n                    if (fileConf) {\n                        break;\n                    }\n                }\n                if (accept.includes('image/webp')) {\n                    fileConf = manifest.get(file + '.webp');\n                    if (fileConf) {\n                        break;\n                    }\n                }\n            }\n            fileConf = manifest.get(file);\n            if (fileConf) {\n                break;\n            }\n            if (file.endsWith('/')) {\n                fileConf = manifest.get(file + 'index.html');\n                if (fileConf) {\n                    break;\n                }\n            }\n            //  `/` \n            if (manifest.has(file + '/index.html')) {\n                return Response.redirect(file + '/');\n            }\n            // \n            //  suffix  /path/to/file?a=1\n            //  /path/ suffix  `to/file?a=1`\n            //  `/` \n            let dir = path.replace(/[^/]*$/, '');\n            for (;;) {\n                fileConf = manifest.get(originPrefix + dir);\n                if (fileConf) {\n                    suffix = path.substring(dir.length) + urlObj.search;\n                    break FIND;\n                }\n                if (dir === '/') {\n                    break;\n                }\n                //  `/` \n                dir = dir.replace(/[^/]+\\/$/, '');\n            }\n            // \n            return Network.fetch(req);\n        }\n        fileConf.parse();\n        let fileHash = '';\n        const hashParam = fileConf.params.get('hash');\n        if (hashParam && hashParam.length === 44 /* SHA256_B64 */) {\n            fileHash = hashParam;\n        }\n        const range = req.headers.get('range');\n        const cacheable = this.enableCacheStorage && fileHash && !range;\n        if (cacheable) {\n            const res = await CacheManager.findHash(fileHash);\n            if (res) {\n                return res;\n            }\n        }\n        const fileLoader = new FileLoader(fileConf, req, this, range, suffix);\n        const promiseObj = promisex();\n        req.signal.addEventListener('abort', () => {\n            const reason = req.signal.reason || 'unknown';\n            fileLoader.abort(reason);\n        });\n        //  hash  hash\n        if (fileHash) {\n            fileLoader.onOpen = (args) => {\n                fileLoader.onData = (body) => {\n                    const res = new Response(body, args);\n                    if (cacheable && body.length < 1024 * 1024 * 5) {\n                        const cacheRes = res.clone();\n                        // \n                        cacheRes.headers.set('content-length', body.length + '');\n                        cacheRes.headers.set('x-raw-url', req.url);\n                        CacheManager.addHash(fileHash, cacheRes);\n                    }\n                    promiseObj.resolve(res);\n                };\n            };\n            fileLoader.onError = (err) => {\n                console.warn('[FreeCDN]', err.message, err.urlErrs);\n                promiseObj.reject(err);\n            };\n            fileLoader.onEnd = () => {\n            };\n            fileLoader.open();\n            return promiseObj;\n        }\n        //  hash  hash\n        let controller;\n        const checkPressure = () => {\n            const { desiredSize } = controller;\n            if (desiredSize === null) {\n                console.warn('desiredSize is null');\n                return;\n            }\n            if (desiredSize <= 0) {\n                fileLoader.pause();\n            }\n            else {\n                fileLoader.resume();\n            }\n        };\n        const stream = new ReadableStream({\n            start(c) {\n                controller = c;\n            },\n            pull: checkPressure,\n            cancel(reason) {\n                console.warn('[FreeCDN] stream cancel:', reason);\n                fileLoader.abort(reason);\n            },\n        });\n        fileLoader.onData = (chunk) => {\n            controller.enqueue(chunk);\n            checkPressure();\n        };\n        fileLoader.onEnd = () => {\n            controller.close();\n        };\n        fileLoader.onError = (err) => {\n            controller.error();\n            console.warn('[FreeCDN]', err.message, err.urlErrs);\n            promiseObj.reject(err);\n        };\n        fileLoader.onOpen = (args) => {\n            const res = new Response(stream, args);\n            promiseObj.resolve(res);\n        };\n        fileLoader.open();\n        return promiseObj;\n    }\n    async fetchText(url) {\n        const res = await this.fetch(url);\n        return res.text();\n    }\n    async fetchBin(url) {\n        const res = await this.fetch(url);\n        const buf = await res.arrayBuffer();\n        return new Uint8Array(buf);\n    }\n    async fetchBlob(url) {\n        const res = await this.fetch(url);\n        const buf = await res.arrayBuffer();\n        const type = res.headers.get('content-type') || '';\n        return new Blob([buf], { type });\n    }\n    async update() {\n        if (this.updater) {\n            return this.updater.update();\n        }\n        return false;\n    }\n    async setPublicKey(keyB64) {\n        if (keyB64.length !== 124 /* PUBKEY_B64 */) {\n            keyB64 = `MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE${keyB64}==`;\n        }\n        await KeyManager.set(keyB64);\n    }\n    async init() {\n        console.assert(!this.inited);\n        this.inited = true;\n        await globalInit();\n        if (this.updater) {\n            await this.updater.init();\n        }\n    }\n}\n// non-callback style Promise\nfunction promisex() {\n    let resolve;\n    let reject;\n    const p = new Promise((a, b) => {\n        resolve = a;\n        reject = b;\n    });\n    // @ts-ignore\n    p.resolve = resolve;\n    // @ts-ignore\n    p.reject = reject;\n    return p;\n}\n// faster than instanceof\nfunction isPromise(obj) {\n    return typeof obj.then === 'function';\n}\n///<reference path=\"../../core-lib/src/freecdn.ts\"/>\n///<reference path=\"../../core-lib/src/promisex.ts\"/>\n///<reference path=\"hook.ts\"/>\nvar Sw;\n(function (Sw) {\n    const GLOBAL = self;\n    const mLoaderJsRes = new Response('/* freecdn is installed */', {\n        headers: {\n            'content-type': 'text/javascript',\n            'cache-control': 'max-age=3600',\n        },\n    });\n    let mFreeCDN;\n    let mIniting;\n    let mResUrlMap;\n    //  SW \n    function sharedModeInit() {\n        Hook.func(GLOBAL, 'fetch', oldFn => sharedModeHandler);\n        Hook.func(Cache.prototype, 'add', oldFn => async function (req) {\n            const res = await sharedModeHandler(req);\n            await this.put(req, res);\n        });\n        Hook.func(Cache.prototype, 'addAll', oldFn => async function (reqs) {\n            const tasks = reqs.map(req => this.add(req));\n            await Promise.all(tasks);\n        });\n        mResUrlMap = new WeakMap();\n        //  Response  url  hook  url\n        Hook.prop(Response.prototype, 'url', getter => function () {\n            return mResUrlMap.get(this) || getter.call(this);\n        }, \n        /* setter */ null);\n        Hook.func(Response.prototype, 'clone', oldFn => function () {\n            const res = oldFn.call(this);\n            const url = mResUrlMap.get(this);\n            if (url) {\n                mResUrlMap.set(res, url);\n            }\n            return res;\n        });\n    }\n    async function sharedModeHandler(input, init) {\n        if (mIniting) {\n            // freecdn \n            await mIniting;\n        }\n        const req = (input instanceof Request && !init)\n            ? input\n            : new Request(input, init);\n        const res = await mFreeCDN.fetch(req);\n        mResUrlMap.set(res, req.url);\n        return res;\n    }\n    //  freecdn-loader.min.js \n    function loaderModeInit() {\n        //  Q.push loader-js  event  promise\n        Q.push = loaderModeHandler;\n        while (Q.length) {\n            const args = Q.splice(0, 3);\n            loaderModeHandler(...args);\n        }\n    }\n    function loaderModeHandler(e, resolve, reject) {\n        const req = e.request;\n        // debug\n        if (req.url.endsWith('/freecdn-update')) {\n            mFreeCDN.update().then(result => {\n                const res = new Response('updated. success: ' + result, {\n                    headers: {\n                        'content-type': 'text/html',\n                    },\n                });\n                resolve(res);\n            });\n            return;\n        }\n        if (req.url === MY_URL) {\n            resolve(mLoaderJsRes.clone());\n            return;\n        }\n        mFreeCDN.fetch(req).then(resolve, reject);\n    }\n    async function main() {\n        mFreeCDN = new FreeCDN('freecdn-internal/freecdn-manifest.txt');\n        const isSharedMode = !!GLOBAL.FREECDN_SHARED_MODE;\n        let publicKey;\n        if (isSharedMode) {\n            mFreeCDN.enableCacheStorage = false;\n            mIniting = promisex();\n            //  await hook  hook\n            sharedModeInit();\n            publicKey = GLOBAL.FREECDN_PUBLIC_KEY;\n        }\n        else {\n            publicKey = Q.shift();\n        }\n        if (publicKey) {\n            await mFreeCDN.setPublicKey(publicKey);\n        }\n        await mFreeCDN.init();\n        if (isSharedMode) {\n            mIniting?.resolve();\n            mIniting = null;\n        }\n        else {\n            loaderModeInit();\n        }\n        console.log('[FreeCDN] service worker inited');\n    }\n    main();\n})(Sw || (Sw = {}));\nclass ParamBr extends ParamBase {\n    constructor() {\n        super();\n        this.state = 0;\n    }\n    static async init() {\n        if (this.signal) {\n            return;\n        }\n        this.signal = promisex();\n        const BR_WASM_PATH = `${INTERNAL_PATH}/br/br.wasm`;\n        const BR_GLUE_PATH = `${INTERNAL_PATH}/br/` + (IS_DEBUG ? 'br.js' : 'br.min.js');\n        const BR_MANIFEST = IS_DEBUG ? '' : `\n${BR_WASM_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.wasm\n\thash=${BR_WASM_HASH}\n\n${BR_GLUE_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.min.js\n\thash=${BR_GLUE_HASH}\n`;\n        const onError = () => {\n            this.hasErr = true;\n            this.signal?.resolve();\n        };\n        const timer = setTimeout(onError, 20000 /* WASM_LOAD_TIMEOUT */);\n        const asmMod = {\n            locateFile: () => BR_WASM_PATH,\n            onRuntimeInitialized: () => {\n                this.inPtr = asmMod._AllocInBuf(131072 /* IN_BUF_LEN */);\n                this.outPtr = asmMod._AllocOutBuf(524288 /* OUT_BUF_LEN */);\n                clearTimeout(timer);\n                this.signal?.resolve();\n                this.signal = undefined;\n            },\n            onAbort: (reason) => {\n                console.warn('[FreeCDN/Br] wasm onAbort:', reason);\n                onError();\n            },\n            print: (msg) => {\n                console.warn('[FreeCDN/Br] wasm print:', msg);\n            },\n            printErr: (err) => {\n                console.warn('[FreeCDN/Br] wasm printErr:', err);\n            },\n        };\n        const manifest = new Manifest();\n        await manifest.parse(BR_MANIFEST);\n        const cdn = new FreeCDN();\n        cdn.manifest = manifest;\n        const onFetch = async (...args) => {\n            try {\n                return await cdn.fetch(...args);\n            }\n            catch (err) {\n                console.warn('[FreeCDN/Br] failed to load wasm');\n                onError();\n                throw err;\n            }\n        };\n        try {\n            const js = await cdn.fetchText(BR_GLUE_PATH);\n            const fn = Function('Module', 'fetch', js);\n            fn(asmMod, onFetch);\n        }\n        catch {\n            console.warn('[FreeCDN/Br] failed to execute glue js');\n            onError();\n            return;\n        }\n        this.asmMod = asmMod;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        if (conf === 'on') {\n            if (!this.asmMod) {\n                this.init();\n            }\n            return [];\n        }\n        return 'invalid value';\n    }\n    onResponse(resArgs) {\n        resArgs.contentLen = -1;\n    }\n    async onData(chunk) {\n        if (ParamBr.signal) {\n            await this.waitWasm();\n        }\n        return this.process(chunk);\n    }\n    async onEnd(chunk) {\n        if (ParamBr.signal) {\n            await this.waitWasm();\n        }\n        // ???\n        let buf = EMPTY_BUF;\n        if (chunk.length > 0) {\n            buf = this.process(chunk);\n        }\n        this.destory();\n        return buf;\n    }\n    async waitWasm() {\n        await ParamBr.signal;\n        if (ParamBr.hasErr) {\n            throw new ParamError('failed to load br decoder');\n        }\n    }\n    process(chunk) {\n        const asmObj = ParamBr.asmMod;\n        const HEAPU8 = asmObj.HEAPU8;\n        if (this.state === 0) {\n            this.state = asmObj._Init();\n        }\n        const outBufs = [];\n        for (let p = 0; p < chunk.length; p += 131072 /* IN_BUF_LEN */) {\n            const inBuf = chunk.subarray(p, p + 131072 /* IN_BUF_LEN */);\n            HEAPU8.set(inBuf, ParamBr.inPtr);\n            let avaiablelIn = inBuf.length;\n            let availableOut = 0;\n            do {\n                const ret = asmObj._Update(this.state, 0, avaiablelIn);\n                if (ret === 0 /* ERROR */) {\n                    const err = asmObj._GetErrorCode();\n                    this.destory();\n                    throw new ParamError('br decode failed. code: ' + err);\n                }\n                avaiablelIn = asmObj._GetAvailableIn();\n                availableOut = asmObj._GetAvailableOut();\n                const len = 524288 /* OUT_BUF_LEN */ - availableOut;\n                if (len === 0) {\n                    continue;\n                }\n                // use slice (copy), not subarray (ref)\n                const outBuf = HEAPU8.slice(ParamBr.outPtr, ParamBr.outPtr + len);\n                outBufs.push(outBuf);\n            } while (asmObj._HasMoreOutput(this.state));\n        }\n        if (outBufs.length === 1) {\n            return outBufs[0];\n        }\n        return concatBufs(outBufs);\n    }\n    destory() {\n        ParamBr.asmMod._Destroy(this.state);\n    }\n}\nParamBr.hasErr = false;\nclass ParamBundle extends ParamBase {\n    constructor(packUrl) {\n        super();\n        this.packUrl = packUrl;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        if (!/^https?:|^\\//.test(conf)) {\n            return 'invalid url';\n        }\n        return [conf];\n    }\n    async onRequest(reqArgs, fileLoader) {\n        if (fileLoader.cdn.isSubReq) {\n            return;\n        }\n        let fileMap;\n        const r = ParamBundle.cacheMap.get(this.packUrl);\n        if (r === undefined) {\n            const signal = promisex();\n            ParamBundle.cacheMap.set(this.packUrl, signal);\n            fileMap = new Map();\n            await this.loadPkg(fileLoader, fileMap);\n            ParamBundle.cacheMap.set(this.packUrl, fileMap);\n            signal.resolve(fileMap);\n        }\n        else if (isPromise(r)) {\n            fileMap = await r;\n        }\n        else {\n            fileMap = r;\n        }\n        const path = fileLoader.suffix || '';\n        const res = fileMap.get(path);\n        if (res) {\n            return res.clone();\n        }\n        if (path === '') {\n            const res = fileMap.get('index.html');\n            if (res) {\n                fileLoader.suffix = 'index.html';\n                return res.clone();\n            }\n            return;\n        }\n        if (path.endsWith('/')) {\n            const res = fileMap.get(path + 'index.html');\n            if (res) {\n                fileLoader.suffix = path + 'index.html';\n                return res.clone();\n            }\n            return;\n        }\n        if (fileMap.has(path + '/index.html')) {\n            fileLoader.suffix = path + '/index.html';\n            return new Response(\"<script>location.pathname+='/'</script>\");\n        }\n    }\n    async loadPkg(fileLoader, fileMap) {\n        // TODO: support stream\n        const cdn = new FreeCDN();\n        cdn.manifest = fileLoader.cdn.manifest;\n        cdn.weightConf = fileLoader.cdn.weightConf;\n        cdn.isSubReq = true;\n        let pkgBin;\n        try {\n            pkgBin = await cdn.fetchBin(this.packUrl);\n        }\n        catch {\n            this.warn('failed to load');\n            return;\n        }\n        const pos = pkgBin.indexOf(13 /* '\\r' */);\n        if (pos === -1) {\n            this.warn('missing header');\n            return;\n        }\n        const confBin = pkgBin.subarray(0, pos);\n        const confMap = parseJson(bytesToUtf8(confBin));\n        if (!confMap) {\n            this.warn('invalid header');\n            return;\n        }\n        const bodyBin = pkgBin.subarray(pos + 1);\n        let offset = 0;\n        for (const [file, conf] of Object.entries(confMap)) {\n            const len = +conf['content-length'];\n            if (!(len >= 0)) {\n                this.warn('invalid content-length');\n                return;\n            }\n            if (offset + len > bodyBin.length) {\n                this.warn('invalid offset');\n                return;\n            }\n            const fileBuf = bodyBin.subarray(offset, offset + len);\n            const res = new Response(fileBuf, {\n                headers: confMap[file]\n            });\n            fileMap.set(file, res);\n            offset += len;\n        }\n    }\n    warn(msg) {\n        console.warn('[FreeCDN/Bundle]', msg, this.packUrl);\n    }\n}\nParamBundle.cacheMap = new Map();\nconst REG_TEXT_MIME = /^text\\/|^application\\/(?:javascript|json)|\\+xml$/;\nclass ParamCharset extends ParamBase {\n    constructor(charset) {\n        super();\n        this.charset = charset;\n    }\n    static parseConf(conf) {\n        if (conf !== 'off') {\n            return [conf];\n        }\n    }\n    onResponse(resArgs) {\n        const type = resArgs.headers.get('content-type') || '';\n        if (REG_TEXT_MIME.test(type)) {\n            resArgs.headers.set('content-type', type + '; charset=' + this.charset);\n        }\n    }\n}\nParamCharset.reuse = true;\nclass ParamConcat extends ParamBase {\n    constructor(partLen, urls) {\n        super();\n        this.partLen = partLen;\n        this.urls = urls;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        const urls = splitList(conf);\n        if (urls.length === 0) {\n            return 'missing url';\n        }\n        let partLen = parseByteUnit(urls[0]);\n        if (partLen > 0) {\n            urls.shift();\n        }\n        else {\n            partLen = -1;\n        }\n        for (const url of urls) {\n            if (!/^https?:|^\\//.test(url)) {\n                return 'invalid url';\n            }\n        }\n        return [partLen, urls];\n    }\n    async onRequest(reqArgs, fileLoader) {\n        if (fileLoader.cdn.isSubReq) {\n            return;\n        }\n        const manifest = fileLoader.cdn.manifest;\n        const fileInfos = [];\n        const REG_WILDCARD = /\\[(\\d+)-(\\d+)\\]/;\n        for (const url of this.urls) {\n            let beginNum = 0;\n            let endNum = 0;\n            let padNum = 0;\n            //  [begin-end]\n            // begin  0\n            const m = url.match(REG_WILDCARD);\n            if (m) {\n                const beginStr = m[1];\n                beginNum = +beginStr;\n                endNum = +m[2];\n                padNum = beginStr[0] === '0' ? beginStr.length : 0;\n            }\n            for (let i = beginNum; i <= endNum; i++) {\n                const realUrl = m\n                    ? url.replace(REG_WILDCARD, (i + '').padStart(padNum, '0'))\n                    : url;\n                const fileConf = manifest.get(realUrl);\n                if (fileConf) {\n                    fileConf.parse();\n                    //  size \n                    const size = fileConf.params.get('size');\n                    fileInfos.push({\n                        url: fileConf.name,\n                        size: size ? +size : this.partLen,\n                    });\n                }\n                else {\n                    fileInfos.push({ url: realUrl, size: this.partLen });\n                }\n            }\n        }\n        fileInfos.reverse();\n        const headers = new Headers();\n        //  range \n        const { rangeBegin } = fileLoader;\n        if (rangeBegin && rangeBegin > 0) {\n            let pos = 0;\n            for (let i = fileInfos.length - 1; i >= 0; i--) {\n                const { size } = fileInfos[i];\n                if (size === -1) {\n                    // \n                    break;\n                }\n                if (pos + size > rangeBegin) {\n                    //  FileLoader \n                    if (pos) {\n                        headers.set('content-range', `bytes ${pos}-/*`);\n                    }\n                    break;\n                }\n                fileInfos.pop();\n                pos += size;\n            }\n        }\n        const cdn = new FreeCDN();\n        cdn.manifest = fileLoader.cdn.manifest;\n        cdn.weightConf = fileLoader.cdn.weightConf;\n        cdn.isSubReq = true;\n        let reader;\n        let controller;\n        const openNextFile = async () => {\n            const info = fileInfos.pop();\n            if (!info) {\n                controller.close();\n                return false;\n            }\n            this.abortCtrl = new AbortController();\n            let res;\n            try {\n                res = await cdn.fetch(info.url, {\n                    signal: this.abortCtrl.signal,\n                });\n            }\n            catch (err) {\n                controller.error(err);\n                return false;\n            }\n            if (!res.body) {\n                return Error('no body');\n            }\n            reader = res.body.getReader();\n            return true;\n        };\n        const readNextChunk = async () => {\n            let buf;\n            try {\n                const { value } = await reader.read();\n                buf = value;\n            }\n            catch (err) {\n                controller.error(err);\n                return;\n            }\n            if (buf) {\n                controller.enqueue(buf);\n            }\n            else {\n                if (await openNextFile()) {\n                    await readNextChunk();\n                }\n            }\n        };\n        const stream = new ReadableStream({\n            async start(c) {\n                controller = c;\n                await openNextFile();\n            },\n            pull: readNextChunk,\n        });\n        return new Response(stream, { headers });\n    }\n    onAbort(reason) {\n        if (this.abortCtrl) {\n            this.abortCtrl.abort(reason);\n            this.abortCtrl = undefined;\n        }\n    }\n}\nclass ParamData extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onRequest() {\n        return new Response(this.bytes);\n    }\n}\nParamData.reuse = true;\nclass ParamExpires extends ParamBase {\n    constructor(seconds) {\n        super();\n        this.seconds = seconds;\n    }\n    static parseConf(conf) {\n        const time = parseTime(conf);\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        const seconds = time / 1000 | 0;\n        return [seconds];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        // \n        const rawMaxAge = rawRes._maxage;\n        const maxAge = rawMaxAge < this.seconds ? rawMaxAge : this.seconds;\n        resArgs.headers.append('cache-control', 'max-age=' + maxAge);\n    }\n}\nParamExpires.reuse = true;\nclass ParamHash extends ParamBase {\n    constructor(blkLen, hashBins) {\n        super();\n        this.blkLen = blkLen;\n        this.hashBins = hashBins;\n        this.queueArr = [];\n        this.queueLen = 0;\n        this.hasData = false;\n    }\n    static parseConf(conf) {\n        // conf format:\n        // [blksize;]hash1,hash2,...\n        let blkLen = 1e9;\n        let hashes = conf;\n        const pos = conf.indexOf(';');\n        if (pos > 0) {\n            const blkLenStr = conf.substring(0, pos);\n            hashes = conf.substring(pos + 1);\n            blkLen = parseByteUnit(blkLenStr);\n            if (isNaN(blkLen)) {\n                return 'invalid block length';\n            }\n        }\n        const hashBins = [];\n        const hashB64s = hashes.split(',');\n        //  pop \n        for (let i = hashB64s.length - 1; i !== -1; i--) {\n            const bin = base64Decode(hashB64s[i]);\n            if (!bin || bin.length !== 32 /* SHA256_BIN */) {\n                return 'invalid block hash';\n            }\n            hashBins.push(bin);\n        }\n        return [blkLen, hashBins];\n    }\n    async onData(chunk) {\n        this.hasData = true;\n        this.queueLen += chunk.length;\n        if (this.queueLen > 67108864 /* MAX_QUEUE_LEN */) {\n            throw new ParamError('max queue length exceeded');\n        }\n        if (this.queueLen >= this.blkLen) {\n            // let queueLen be integer multiple of blkLen\n            const remain = this.queueLen % this.blkLen;\n            if (remain) {\n                const head = chunk.subarray(0, -remain);\n                this.queueArr.push(head);\n                this.queueLen -= remain;\n            }\n            else {\n                this.queueArr.push(chunk);\n            }\n            const blks = await this.pull();\n            this.queueLen = remain;\n            if (remain) {\n                const tail = chunk.subarray(-remain);\n                this.queueArr.push(tail);\n            }\n            return blks;\n        }\n        this.queueArr.push(chunk);\n        return EMPTY_BUF;\n    }\n    async onEnd(chunk) {\n        if (chunk.length > 0) {\n            this.queueLen += chunk.length;\n            this.queueArr.push(chunk);\n        }\n        if (this.queueLen === 0) {\n            if (!this.hasData) {\n                await this.verify(EMPTY_BUF);\n            }\n            return EMPTY_BUF;\n        }\n        return this.pull();\n    }\n    async pull() {\n        const blks = concatBufs(this.queueArr, this.queueLen);\n        this.queueArr.length = 0;\n        for (let p = 0; p < blks.length; p += this.blkLen) {\n            const blk = blks.subarray(p, p + this.blkLen);\n            await this.verify(blk);\n        }\n        return blks;\n    }\n    async verify(blk) {\n        const hashExp = this.hashBins.pop();\n        if (!hashExp) {\n            throw new ParamError('missing hash');\n        }\n        const hashGot = await sha256(blk);\n        if (!isArrayEqual(hashExp, hashGot)) {\n            const exp = base64Encode(hashExp);\n            const got = base64Encode(hashGot);\n            throw new ParamError(`hash incorrect. expected: ${exp}, but got: ${got}`);\n        }\n    }\n}\nclass ParamHeaders extends ParamBase {\n    constructor(headers, preserveAll) {\n        super();\n        this.headers = headers;\n        this.preserveAll = preserveAll;\n    }\n    static parseConf(conf) {\n        return ParamReqHeaders.parse(conf);\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        if (this.preserveAll) {\n            for (const [k, v] of rawRes.headers) {\n                resArgs.headers.set(k, v);\n            }\n            for (const [k, v] of this.headers) {\n                resArgs.headers.set(k, v);\n            }\n            return;\n        }\n        for (const [k, v] of this.headers) {\n            if (v === '') {\n                // preserve\n                const rawVal = rawRes.headers.get(k);\n                if (rawVal !== null) {\n                    resArgs.headers.set(k, rawVal);\n                }\n            }\n            else {\n                // add\n                resArgs.headers.set(k, v);\n            }\n        }\n    }\n}\nParamHeaders.reuse = true;\nclass ParamOpenTimeout extends ParamBase {\n    constructor(time) {\n        super();\n        this.time = time;\n        this.tid = 0;\n    }\n    static parseConf(conf) {\n        const time = parseTime(conf);\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        return [time];\n    }\n    onRequest(reqArgs, fileLoader) {\n        this.tid = setTimeout(() => {\n            const delay = Math.max(this.time, 5000);\n            fileLoader.loadNextUrl(delay);\n        }, this.time);\n    }\n    onResponse() {\n        this.stopTimer();\n    }\n    onError() {\n        this.stopTimer();\n    }\n    onAbort() {\n        this.stopTimer();\n    }\n    stopTimer() {\n        if (this.tid > 0) {\n            clearTimeout(this.tid);\n            this.tid = 0;\n        }\n    }\n}\nclass ParamPos extends ParamBase {\n    constructor(remain) {\n        super();\n        this.remain = remain;\n    }\n    static parseConf(conf) {\n        const pos = parseByteUnit(conf);\n        if (isNaN(pos)) {\n            return 'invalid byte format';\n        }\n        if (pos === 0) {\n            return;\n        }\n        return [pos];\n    }\n    onResponse(resArgs) {\n        if (resArgs.contentLen !== -1) {\n            if ((resArgs.contentLen -= this.remain) < 0) {\n                resArgs.contentLen = 0;\n            }\n        }\n    }\n    onData(chunk) {\n        if (this.remain <= 0) {\n            return chunk;\n        }\n        const remain = (this.remain -= chunk.length);\n        if (remain >= 0) {\n            return EMPTY_BUF;\n        }\n        // if remain < 0, return last -remain bytes\n        return chunk.subarray(remain);\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nclass ParamPrefix extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n        this.done = false;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onResponse(resArgs) {\n        if (resArgs.contentLen >= 0) {\n            resArgs.contentLen += this.bytes.length;\n        }\n    }\n    onData(chunk) {\n        if (this.done) {\n            return chunk;\n        }\n        this.done = true;\n        return concatBufs([this.bytes, chunk]);\n    }\n    onEnd(chunk) {\n        // for empty file\n        return this.onData(chunk);\n    }\n}\nclass ParamRecvTimeout extends ParamBase {\n    constructor(bytes, time) {\n        super();\n        this.bytes = bytes;\n        this.time = time;\n        this.tid = 0;\n        this.sum = 0;\n    }\n    static parseConf(conf) {\n        const [n, t] = conf.split('/');\n        const bytes = parseByteUnit(n);\n        const time = parseTime(t);\n        if (isNaN(bytes)) {\n            return 'invalid byte format';\n        }\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        return [bytes, time];\n    }\n    onRequest(reqArgs, fileLoader) {\n        this.fileLoader = fileLoader;\n    }\n    onResponse() {\n        this.tid = setInterval(() => {\n            if (this.sum <= this.bytes) {\n                this.stopTimer();\n                this.fileLoader.loadNextUrl();\n            }\n            this.sum = 0;\n        }, this.time);\n    }\n    onData(chunk) {\n        this.sum += chunk.length;\n        return chunk;\n    }\n    onEnd(chunk) {\n        this.stopTimer();\n        return chunk;\n    }\n    onError() {\n        this.stopTimer();\n    }\n    onAbort() {\n        this.stopTimer();\n    }\n    stopTimer() {\n        if (this.tid > 0) {\n            clearInterval(this.tid);\n            this.tid = 0;\n        }\n    }\n}\nconst REG_REFFERER_POLICY = /^(?:no-referrer|unsafe-url|origin|same-origin|strict-origin|no-referrer-when-downgrade|origin-when-cross-origin|strict-origin-when-cross-origin)$/;\nclass ParamReferrerPolicy extends ParamBase {\n    constructor(policy) {\n        super();\n        this.policy = policy;\n    }\n    static parseConf(conf) {\n        if (conf === 'raw') {\n            return [''];\n        }\n        if (!REG_REFFERER_POLICY.test(conf)) {\n            return 'invalid value';\n        }\n        return [conf];\n    }\n    onRequest(reqArgs, fileLoader) {\n        reqArgs.referrerPolicy = this.policy || fileLoader.rawReq.referrerPolicy;\n    }\n}\nParamReferrerPolicy.reuse = true;\nclass ParamReqHeaders extends ParamBase {\n    constructor(headers, preserveAll) {\n        super();\n        this.headers = headers;\n        this.preserveAll = preserveAll;\n    }\n    static parse(conf) {\n        const headers = [];\n        let preserveAll = false;\n        // {\"header-to-preserve\": \"\", \"header-to-add\": \"val\"}\n        const map = parseJson(conf);\n        if (typeof map !== 'object') {\n            return 'invalid format';\n        }\n        for (const [k, v] of Object.entries(map)) {\n            if (k === '*') {\n                preserveAll = true;\n            }\n            else {\n                headers.push([k, v + '']);\n            }\n        }\n        return [headers, preserveAll];\n    }\n    static parseConf(conf) {\n        return this.parse(conf);\n    }\n    onRequest(reqArgs, fileLoader) {\n        const { rawReq } = fileLoader;\n        if (this.preserveAll) {\n            for (const [k, v] of rawReq.headers) {\n                reqArgs.headers.set(k, v);\n            }\n            for (const [k, v] of this.headers) {\n                reqArgs.headers.set(k, v);\n            }\n            return;\n        }\n        for (const [k, v] of this.headers) {\n            if (k === 'referer') {\n                reqArgs.referrer = v || rawReq.referrer;\n                continue;\n            }\n            if (v === '') {\n                // preserve\n                const rawVal = rawReq.headers.get(k);\n                if (rawVal !== null) {\n                    reqArgs.headers.set(k, rawVal);\n                }\n            }\n            else {\n                // add\n                reqArgs.headers.set(k, v);\n            }\n        }\n    }\n}\nParamReqHeaders.reuse = true;\nclass ParamSize extends ParamBase {\n    constructor(remain) {\n        super();\n        this.remain = remain;\n    }\n    static parseConf(conf) {\n        const size = parseByteUnit(conf);\n        if (isNaN(size)) {\n            return 'invalid byte format';\n        }\n        return [size];\n    }\n    onResponse(resArgs) {\n        resArgs.contentLen = this.remain;\n    }\n    onData(chunk) {\n        if (this.remain <= 0) {\n            return EMPTY_BUF;\n        }\n        const remain = (this.remain -= chunk.length);\n        if (remain >= 0) {\n            return chunk;\n        }\n        // remain < 0, return [0, END + remain)\n        return chunk.subarray(0, remain);\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nclass ParamStream extends ParamBase {\n    constructor() {\n        super();\n        this.queueArr = [];\n        this.queueLen = 0;\n    }\n    static parseConf(conf) {\n        if (conf === 'on') {\n            // default\n            return;\n        }\n        if (conf === 'off') {\n            return [];\n        }\n        return 'invalid value';\n    }\n    onData(chunk) {\n        this.queueLen += chunk.length;\n        if (this.queueLen > 67108864 /* MAX_QUEUE_LEN */) {\n            throw new ParamError('max queue length exceeded');\n        }\n        this.queueArr.push(chunk);\n        return EMPTY_BUF;\n    }\n    onEnd(chunk) {\n        if (chunk.length > 0) {\n            // unlikely\n            this.onData(chunk);\n        }\n        return concatBufs(this.queueArr, this.queueLen);\n    }\n}\nclass ParamSuffix extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onResponse(resArgs) {\n        if (resArgs.contentLen >= 0) {\n            resArgs.contentLen += this.bytes.length;\n        }\n    }\n    onEnd(chunk) {\n        if (chunk.length === 0) {\n            return this.bytes;\n        }\n        return concatBufs([chunk, this.bytes]);\n    }\n}\nParamSuffix.reuse = true;\nclass ParamValidStatus extends ParamBase {\n    constructor(codes) {\n        super();\n        this.codes = codes;\n    }\n    static parseConf(conf) {\n        if (conf === '*') {\n            return;\n        }\n        const codes = conf.split(',').map(Number);\n        return [codes];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        if (!this.codes.includes(rawRes.status)) {\n            throw new ParamError('invalid http status: ' + rawRes.status);\n        }\n    }\n}\nParamValidStatus.reuse = true;\nclass ParamXor extends ParamBase {\n    constructor(key) {\n        super();\n        this.key = key;\n    }\n    static parseConf(conf) {\n        const key = +conf | 0;\n        if (key < 0 || key > 255) {\n            return 'invalid value';\n        }\n        return [key];\n    }\n    onData(chunk) {\n        // TODO: u32 optimize\n        for (let i = 0; i < chunk.length; i++) {\n            chunk[i] ^= this.key;\n        }\n        return chunk;\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nParamXor.reuse = true;\nconst MIME_DATA = 'application/andrew-inset:ez;application/applixware:aw;application/atom+xml:atom;application/atomcat+xml:atomcat;application/atomdeleted+xml:atomdeleted;application/atomsvc+xml:atomsvc;application/atsc-dwd+xml:dwd;application/atsc-held+xml:held;application/atsc-rsat+xml:rsat;application/bdoc:bdoc;application/calendar+xml:xcs;application/ccxml+xml:ccxml;application/cdfx+xml:cdfx;application/cdmi-capability:cdmia;application/cdmi-container:cdmic;application/cdmi-domain:cdmid;application/cdmi-object:cdmio;application/cdmi-queue:cdmiq;application/cu-seeme:cu;application/dash+xml:mpd;application/davmount+xml:davmount;application/docbook+xml:dbk;application/dssc+der:dssc;application/dssc+xml:xdssc;application/ecmascript:ecma,es;application/emma+xml:emma;application/emotionml+xml:emotionml;application/epub+zip:epub;application/exi:exi;application/fdt+xml:fdt;application/font-tdpfr:pfr;application/geo+json:geojson;application/gml+xml:gml;application/gpx+xml:gpx;application/gxf:gxf;application/gzip:gz;application/hjson:hjson;application/hyperstudio:stk;application/inkml+xml:ink,inkml;application/ipfix:ipfix;application/its+xml:its;application/java-archive:jar,war,ear;application/java-serialized-object:ser;application/java-vm:class;application/javascript:js,mjs;application/json:json,map;application/json5:json5;application/jsonml+json:jsonml;application/ld+json:jsonld;application/lgr+xml:lgr;application/lost+xml:lostxml;application/mac-binhex40:hqx;application/mac-compactpro:cpt;application/mads+xml:mads;application/manifest+json:webmanifest;application/marc:mrc;application/marcxml+xml:mrcx;application/mathematica:ma,nb,mb;application/mathml+xml:mathml;application/mbox:mbox;application/mediaservercontrol+xml:mscml;application/metalink+xml:metalink;application/metalink4+xml:meta4;application/mets+xml:mets;application/mmt-aei+xml:maei;application/mmt-usd+xml:musd;application/mods+xml:mods;application/mp21:m21,mp21;application/mp4:mp4s,m4p;application/mrb-consumer+xml:xdf;application/mrb-publish+xml:xdf;application/msword:doc,dot;application/mxf:mxf;application/n-quads:nq;application/n-triples:nt;application/node:cjs;application/octet-stream:bin,dms,lrf,mar,so,dist,distz,pkg,bpk,dump,elc,deploy,exe,dll,deb,dmg,iso,img,msi,msp,msm,buffer;application/oda:oda;application/oebps-package+xml:opf;application/ogg:ogx;application/omdoc+xml:omdoc;application/onenote:onetoc,onetoc2,onetmp,onepkg;application/oxps:oxps;application/p2p-overlay+xml:relo;application/patch-ops-error+xml:xer;application/pdf:pdf;application/pgp-encrypted:pgp;application/pgp-signature:asc,sig;application/pics-rules:prf;application/pkcs10:p10;application/pkcs7-mime:p7m,p7c;application/pkcs7-signature:p7s;application/pkcs8:p8;application/pkix-attr-cert:ac;application/pkix-cert:cer;application/pkix-crl:crl;application/pkix-pkipath:pkipath;application/pkixcmp:pki;application/pls+xml:pls;application/postscript:ai,eps,ps;application/provenance+xml:provx;application/pskc+xml:pskcxml;application/raml+yaml:raml;application/rdf+xml:rdf,owl;application/reginfo+xml:rif;application/relax-ng-compact-syntax:rnc;application/resource-lists+xml:rl;application/resource-lists-diff+xml:rld;application/rls-services+xml:rs;application/route-apd+xml:rapd;application/route-s-tsid+xml:sls;application/route-usd+xml:rusd;application/rpki-ghostbusters:gbr;application/rpki-manifest:mft;application/rpki-roa:roa;application/rsd+xml:rsd;application/rss+xml:rss;application/rtf:rtf;application/sbml+xml:sbml;application/scvp-cv-request:scq;application/scvp-cv-response:scs;application/scvp-vp-request:spq;application/scvp-vp-response:spp;application/sdp:sdp;application/senml+xml:senmlx;application/sensml+xml:sensmlx;application/set-payment-initiation:setpay;application/set-registration-initiation:setreg;application/shf+xml:shf;application/sieve:siv,sieve;application/smil+xml:smi,smil;application/sparql-query:rq;application/sparql-results+xml:srx;application/srgs:gram;application/srgs+xml:grxml;application/sru+xml:sru;application/ssdl+xml:ssdl;application/ssml+xml:ssml;application/swid+xml:swidtag;application/tei+xml:tei,teicorpus;application/thraud+xml:tfi;application/timestamped-data:tsd;application/toml:toml;application/ttml+xml:ttml;application/ubjson:ubj;application/urc-ressheet+xml:rsheet;application/urc-targetdesc+xml:td;application/voicexml+xml:vxml;application/wasm:wasm;application/widget:wgt;application/winhlp:hlp;application/wsdl+xml:wsdl;application/wspolicy+xml:wspolicy;application/xaml+xml:xaml;application/xcap-att+xml:xav;application/xcap-caps+xml:xca;application/xcap-diff+xml:xdf;application/xcap-el+xml:xel;application/xcap-error+xml:xer;application/xcap-ns+xml:xns;application/xenc+xml:xenc;application/xhtml+xml:xhtml,xht;application/xliff+xml:xlf;application/xml:xml,xsl,xsd,rng;application/xml-dtd:dtd;application/xop+xml:xop;application/xproc+xml:xpl;application/xslt+xml:xsl,xslt;application/xspf+xml:xspf;application/xv+xml:mxml,xhvml,xvml,xvm;application/yang:yang;application/yin+xml:yin;application/zip:zip;audio/3gpp:3gpp;audio/adpcm:adp;audio/amr:amr;audio/basic:au,snd;audio/midi:mid,midi,kar,rmi;audio/mobile-xmf:mxmf;audio/mp3:mp3;audio/mp4:m4a,mp4a;audio/mpeg:mpga,mp2,mp2a,mp3,m2a,m3a;audio/ogg:oga,ogg,spx,opus;audio/s3m:s3m;audio/silk:sil;audio/wav:wav;audio/wave:wav;audio/webm:weba;audio/xm:xm;font/collection:ttc;font/otf:otf;font/ttf:ttf;font/woff:woff;font/woff2:woff2;image/aces:exr;image/apng:apng;image/avif:avif;image/bmp:bmp;image/cgm:cgm;image/dicom-rle:drle;image/emf:emf;image/fits:fits;image/g3fax:g3;image/gif:gif;image/heic:heic;image/heic-sequence:heics;image/heif:heif;image/heif-sequence:heifs;image/hej2k:hej2;image/hsj2:hsj2;image/ief:ief;image/jls:jls;image/jp2:jp2,jpg2;image/jpeg:jpeg,jpg,jpe;image/jph:jph;image/jphc:jhc;image/jpm:jpm;image/jpx:jpx,jpf;image/jxr:jxr;image/jxra:jxra;image/jxrs:jxrs;image/jxs:jxs;image/jxsc:jxsc;image/jxsi:jxsi;image/jxss:jxss;image/ktx:ktx;image/ktx2:ktx2;image/png:png;image/sgi:sgi;image/svg+xml:svg,svgz;image/t38:t38;image/tiff:tif,tiff;image/tiff-fx:tfx;image/webp:webp;image/wmf:wmf;message/disposition-notification:disposition-notification;message/global:u8msg;message/global-delivery-status:u8dsn;message/global-disposition-notification:u8mdn;message/global-headers:u8hdr;message/rfc822:eml,mime;model/3mf:3mf;model/gltf+json:gltf;model/gltf-binary:glb;model/iges:igs,iges;model/mesh:msh,mesh,silo;model/mtl:mtl;model/obj:obj;model/stl:stl;model/vrml:wrl,vrml;model/x3d+binary:x3db,x3dbz;model/x3d+fastinfoset:x3db;model/x3d+vrml:x3dv,x3dvz;model/x3d+xml:x3d,x3dz;model/x3d-vrml:x3dv;text/cache-manifest:appcache,manifest;text/calendar:ics,ifb;text/coffeescript:coffee,litcoffee;text/css:css;text/csv:csv;text/html:html,htm,shtml;text/jade:jade;text/jsx:jsx;text/less:less;text/markdown:markdown,md;text/mathml:mml;text/mdx:mdx;text/n3:n3;text/plain:txt,text,conf,def,list,log,in,ini;text/richtext:rtx;text/rtf:rtf;text/sgml:sgml,sgm;text/shex:shex;text/slim:slim,slm;text/spdx:spdx;text/stylus:stylus,styl;text/tab-separated-values:tsv;text/troff:t,tr,roff,man,me,ms;text/turtle:ttl;text/uri-list:uri,uris,urls;text/vcard:vcard;text/vtt:vtt;text/xml:xml;text/yaml:yaml,yml;video/3gpp:3gp,3gpp;video/3gpp2:3g2;video/h261:h261;video/h263:h263;video/h264:h264;video/iso.segment:m4s;video/jpeg:jpgv;video/jpm:jpm,jpgm;video/mj2:mj2,mjp2;video/mp2t:ts;video/mp4:mp4,mp4v,mpg4;video/mpeg:mpeg,mpg,mpe,m1v,m2v;video/ogg:ogv;video/quicktime:qt,mov;video/webm:webm';\nvar _a;\nclass ParamMime extends ParamBase {\n    constructor(mime) {\n        super();\n        this.mime = mime;\n    }\n    static parseConf(conf) {\n        if (conf === 'auto') {\n            // likely\n            return [''];\n        }\n        return [conf];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        let type;\n        if (this.mime === '') {\n            const url = fileLoader.getSourceUrl();\n            if (!url.includes('?')) {\n                const m = url.match(/\\.(\\w+)$/);\n                if (m) {\n                    const ext = m[1].toLowerCase();\n                    type = ParamMime.extTypeMap.get(ext);\n                }\n            }\n            if (!type) {\n                const rawType = rawRes.headers.get('content-type');\n                if (rawType) {\n                    type = getPair(rawType, ';')[0];\n                }\n                else {\n                    type = 'application/octet-stream';\n                }\n            }\n        }\n        else {\n            type = this.mime;\n        }\n        resArgs.headers.set('content-type', type);\n    }\n}\n_a = ParamMime;\nParamMime.reuse = true;\n(() => {\n    const map = new Map();\n    for (const item of MIME_DATA.split(';')) {\n        const [mime, exts] = getPair(item, ':');\n        for (const ext of exts.split(',')) {\n            map.set(ext, mime);\n        }\n    }\n    _a.extTypeMap = map;\n})();\nvar CacheManager;\n(function (CacheManager) {\n    let mCache;\n    // TODO: LRU\n    async function init() {\n        if (!mCache) {\n            mCache = await caches.open('.freecdn');\n        }\n    }\n    CacheManager.init = init;\n    async function findHash(hash) {\n        const res = await findCache('/' + hash);\n        if (!res) {\n            return;\n        }\n        const buf = await res.clone().arrayBuffer();\n        const bin = new Uint8Array(buf);\n        const hashGot = await sha256(bin);\n        const hashExp = base64Decode(hash);\n        if (!hashExp) {\n            return;\n        }\n        if (!isArrayEqual(hashGot, hashExp)) {\n            console.warn('[FreeCDN/CacheManager] bad cache:', hash);\n            delCache('/' + hash);\n            return;\n        }\n        return res;\n    }\n    CacheManager.findHash = findHash;\n    async function addHash(hash, res) {\n        await addCache('/' + hash, res);\n    }\n    CacheManager.addHash = addHash;\n    function findCache(reqInfo) {\n        return mCache.match(reqInfo);\n    }\n    CacheManager.findCache = findCache;\n    async function addCache(reqInfo, res) {\n        try {\n            await mCache.put(reqInfo, res);\n        }\n        catch {\n        }\n    }\n    CacheManager.addCache = addCache;\n    function delCache(reqInfo) {\n        return mCache.delete(reqInfo);\n    }\n    CacheManager.delCache = delCache;\n})(CacheManager || (CacheManager = {}));\nclass Database {\n    constructor(name) {\n        this.name = name;\n    }\n    open(opts) {\n        const s = promisex();\n        const req = indexedDB.open(this.name);\n        req.onsuccess = () => {\n            const idb = req.result;\n            this.db = idb;\n            idb.onclose = () => {\n                console.warn('[FreeCDN/Database] indexedDB disconnected, reopen...');\n                this.open(opts);\n            };\n            s.resolve();\n        };\n        req.onerror = (e) => {\n            console.warn('[FreeCDN/Database] indexedDB open error:', e);\n            s.reject(req.error);\n        };\n        req.onupgradeneeded = () => {\n            const idb = req.result;\n            for (const [k, v] of Object.entries(opts)) {\n                idb.createObjectStore(k, v);\n            }\n        };\n        return s;\n    }\n    close() {\n        this.db.close();\n    }\n    get(table, key) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readonly');\n        const req = obj.get(key);\n        req.onsuccess = () => {\n            s.resolve(req.result);\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    put(table, record) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readwrite');\n        const req = obj.put(record);\n        req.onsuccess = () => {\n            s.resolve();\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    delete(table, key) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readwrite');\n        const req = obj.delete(key);\n        req.onsuccess = () => {\n            s.resolve();\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    enum(table, callback, ...args) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readonly');\n        const req = obj.openCursor(...args);\n        req.onsuccess = () => {\n            const { result } = req;\n            if (!result) {\n                s.resolve();\n                return;\n            }\n            const ret = callback(result.value);\n            if (ret !== false) {\n                result.continue();\n            }\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    getStore(table, mode) {\n        return this.db\n            .transaction(table, mode)\n            .objectStore(table);\n    }\n}\nvar Network;\n(function (Network) {\n    const mDatabase = new Database('.freecdn');\n    const mUrlInfoMap = new Map();\n    function addUrlInfo(url, status, expire) {\n        if (mUrlInfoMap.has(url)) {\n            return;\n        }\n        const info = { url, status, expire };\n        mUrlInfoMap.set(url, info);\n        mDatabase.put('cache', info);\n    }\n    class HostInfo {\n        constructor() {\n            this.lastDoneTime = 0;\n            this.lastErrTime = 0;\n            this.pending = 0;\n            // public protocol = 1\n            this.errNum = 0;\n            this.reqNum = 0;\n            this.reqTimeAvg = -1;\n            this.reqTimeSum = 0;\n            // public speedAvg = 0\n            // public speedSum = 0\n        }\n    }\n    const mHostInfoMap = new Map();\n    function getHostInfo(host) {\n        let info = mHostInfoMap.get(host);\n        if (!info) {\n            info = new HostInfo();\n            mHostInfoMap.set(host, info);\n        }\n        return info;\n    }\n    function getHostWeight(hostInfo, now) {\n        // TODO: ...\n        if (hostInfo.reqTimeAvg !== -1) {\n            const delayScore = 100 - hostInfo.reqTimeAvg * 0.2;\n            return Math.max(delayScore, 10);\n        }\n        return 50;\n    }\n    function getUrlWeight(url, now, hostWeightMap) {\n        const urlInfo = mUrlInfoMap.get(url);\n        if (urlInfo && urlInfo.expire < now) {\n            if (urlInfo.status !== 200) {\n                return -2;\n            }\n            //  URL \n            // expire \n            return 100 + urlInfo.expire;\n        }\n        //  -1\n        if (url[0] === '/') {\n            return hostWeightMap.get(MY_HOST) ?? -1;\n        }\n        const host = getHostFromUrl(url);\n        const hostInfo = mHostInfoMap.get(host);\n        if (!hostInfo) {\n            return hostWeightMap.get(host) ?? 50;\n        }\n        return getHostWeight(hostInfo, now);\n    }\n    Network.getUrlWeight = getUrlWeight;\n    async function fetch(req) {\n        const host = getHostFromUrl(req.url);\n        const hostInfo = getHostInfo(host);\n        hostInfo.pending++;\n        const t0 = getTimeSec();\n        let res;\n        try {\n            res = await NATIVE_FETCH(req);\n        }\n        catch (err) {\n            parseFetchError(err, req, hostInfo, t0);\n            throw err;\n        }\n        finally {\n            hostInfo.pending--;\n        }\n        const maxAge = parseMaxAge(res.headers, t0);\n        switch (res.status) {\n            case 200:\n                if (req.cache !== 'no-store') {\n                    if (maxAge > 60) {\n                        addUrlInfo(res.url, 200, t0 + maxAge);\n                    }\n                }\n                break;\n            case 404:\n                addUrlInfo(res.url, 404, t0 + maxAge);\n                break;\n        }\n        //  expires \n        res._maxage = maxAge;\n        return res;\n    }\n    Network.fetch = fetch;\n    const REG_NET_ERR = /^Failed to fetch|^NetworkError|^Could not connect/;\n    function parseFetchError(err, req, hostInfo, t0) {\n        if (!navigator.onLine) {\n            return;\n        }\n        if (!REG_NET_ERR.test(err.message)) {\n            return;\n        }\n        if (req.cache === 'only-if-cached') {\n            return;\n        }\n        hostInfo.errNum++;\n        hostInfo.lastErrTime = t0;\n    }\n    function parseMaxAge(headers, t0) {\n        const cacheControl = headers.get('cache-control');\n        if (cacheControl !== null) {\n            if (cacheControl.includes('no-cache')) {\n                return 0;\n            }\n            const m = cacheControl.match(/max-age=\"?(\\d+)\"?/);\n            if (m) {\n                return +m[1];\n            }\n        }\n        const expires = headers.get('expires');\n        if (expires !== null) {\n            const t1 = Date.parse(expires) / 1000;\n            if (t1) {\n                return (t1 - t0) | 0;\n            }\n        }\n        return 300 /* DEFAULT_MAX_AGE */;\n    }\n    function parseEntries(list) {\n        const timeBase = performance.timeOrigin;\n        for (const record of list) {\n            const host = getHostFromUrl(record.name);\n            const info = getHostInfo(host);\n            info.reqNum++;\n            info.lastDoneTime = timeBase + record.responseEnd;\n            // time-allow-origin\n            if (record.responseStart > 0) {\n                const reqTime = record.responseStart - record.requestStart;\n                info.reqTimeSum += reqTime;\n                info.reqTimeAvg = info.reqTimeSum / info.reqNum;\n            }\n        }\n    }\n    async function init() {\n        await mDatabase.open({\n            'cache': {\n                keyPath: 'url'\n            },\n        });\n        const now = getTimeSec();\n        //  URL \n        await mDatabase.enum('cache', (item) => {\n            if (item.expire < now) {\n                mDatabase.delete('cache', item.url);\n                return;\n            }\n            mUrlInfoMap.set(item.url, item);\n        });\n        //  URL \n        const entries = performance.getEntriesByType('resource');\n        parseEntries(entries);\n        const observer = new PerformanceObserver(entryList => {\n            const entries = entryList.getEntries();\n            parseEntries(entries);\n        });\n        observer.observe({\n            entryTypes: ['resource']\n        });\n    }\n    Network.init = init;\n    function parseWeightConf(manifest) {\n        const zone = navigator.language.toLowerCase();\n        const zone0 = zone.split('-')[0];\n        const weightParams = manifest.getParams('@weight ' + zone) ||\n            manifest.getParams('@weight ' + zone0) ||\n            manifest.getParams('@weight');\n        if (!weightParams) {\n            const obj = ZONE_HOST_SCORE[zone] || ZONE_HOST_SCORE['*'];\n            return new Map(Object.entries(obj));\n        }\n        const map = new Map();\n        for (const [k, v] of weightParams) {\n            const num = +v;\n            if (isNaN(num)) {\n                continue;\n            }\n            map.set(k, num);\n        }\n        return map;\n    }\n    Network.parseWeightConf = parseWeightConf;\n})(Network || (Network = {}));\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER = new TextDecoder();\nfunction utf8ToBytes(str) {\n    return TEXT_ENCODER.encode(str);\n}\nfunction bytesToUtf8(bytes) {\n    return TEXT_DECODER.decode(bytes);\n}\nfunction bytesToAsc(bytes) {\n    return bytes.reduce((s, v) => s + String.fromCharCode(v), '');\n}\nfunction base64Encode(bytes) {\n    return btoa(bytesToAsc(bytes));\n}\nfunction base64Decode(str) {\n    try {\n        str = atob(str);\n    }\n    catch {\n        return;\n    }\n    const bin = new Uint8Array(str.length);\n    for (let i = 0; i < bin.length; i++) {\n        bin[i] = str.charCodeAt(i);\n    }\n    return bin;\n}\nfunction parseJson(str) {\n    try {\n        return JSON.parse(str);\n    }\n    catch {\n    }\n}\nfunction splitList(str) {\n    str = str.trim();\n    if (!str) {\n        return [];\n    }\n    return str.split(/\\s+/);\n}\nfunction parseStrOrB64(str) {\n    // json string\n    if (str[0] === '\"') {\n        str = parseJson(str);\n        if (str === undefined) {\n            return;\n        }\n        return utf8ToBytes(str);\n    }\n    // base64\n    return base64Decode(str);\n}\nconst TIME_UNIT = {\n    '': 1,\n    'ms': 1,\n    's': 1000,\n    'min': 1000 * 60,\n    'h': 1000 * 3600,\n    'd': 1000 * 3600 * 24,\n    'y': 1000 * 3600 * 24 * 365,\n};\nfunction parseTime(str) {\n    const m = str.match(/^([\\d.]{1,9})(y|d|h|min|s|ms|)$/);\n    if (!m) {\n        return NaN;\n    }\n    const [, num, unit] = m;\n    return +num * TIME_UNIT[unit];\n}\nfunction parseByteUnit(str) {\n    const m = str.match(/^([\\d.]{1,9})(k|K|M|G|)(i|)(b|B|)$/);\n    if (!m) {\n        return NaN;\n    }\n    const [, num, kMG, i, bB] = m;\n    const exponent = kMG === 'k' ? 1 :\n        kMG === 'K' ? 1 :\n            kMG === 'M' ? 2 :\n                kMG === 'G' ? 3 : 0;\n    const base = i ? 1024 : 1000;\n    const unit = bB === 'b' ? 8 : 1;\n    return +num * base ** exponent / unit;\n}\nfunction getTimeSec() {\n    return Date.now() / 1000 | 0;\n}\nfunction concatBufs(bufs, size = 0) {\n    if (size === 0) {\n        for (const v of bufs) {\n            size += v.length;\n        }\n    }\n    const ret = new Uint8Array(size);\n    let pos = 0;\n    for (const v of bufs) {\n        ret.set(v, pos);\n        pos += v.length;\n    }\n    return ret;\n}\nfunction isArrayEqual(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getPair(str, delim) {\n    const pos = str.indexOf(delim);\n    if (pos === -1) {\n        return [str];\n    }\n    return [\n        str.substring(0, pos),\n        str.substring(pos + delim.length)\n    ];\n}\nfunction mergeMap(dst, src) {\n    for (const [k, v] of src) {\n        dst.set(k, v);\n    }\n}\n/**\n * @param url absolute or relative url\n */\nfunction stripUrlQuery(url) {\n    const pos = url.indexOf('?');\n    if (pos === -1) {\n        return url;\n    }\n    return url.substring(0, pos);\n}\n/**\n * @param url absolute url\n */\nfunction getHostFromUrl(url) {\n    const m = url.match(/^https?:\\/\\/([^/]+)/);\n    return m[1];\n}\n/**\n * @param url absolute or relative url\n */\nfunction toRelUrl(url) {\n    if (url.startsWith(ROOT_PATH)) {\n        return url.substring(MY_ORIGIN.length);\n    }\n    return url;\n}\nasync function sha256(buf) {\n    const ret = await CRYPTO.digest('SHA-256', buf);\n    return new Uint8Array(ret);\n}\nconst ZONE_HOST_SCORE = {\n    'zh-cn': {\n        'ajax.cdnjs.com': 50,\n        'cdnjs.cloudflare.com': 50,\n        'cdn.jsdelivr.net': 80,\n        'raw.githubusercontent.com': 10,\n        'cdnjs.loli.net': 70,\n        'lib.baomitu.com': 80,\n        'lf6-cdn-tos.bytecdntp.com': 90,\n        'cdn.staticfile.org': 90,\n        'cdn.bootcss.com': 10,\n        'cdn.bootcdn.net': 80,\n        'unpkg.com': 50,\n        'g.alicdn.com': 90,\n        'pagecdn.io': 20,\n        'ajax.aspnetcdn.com': 60,\n        'ajax.googleapis.com': 10,\n        'code.jquery.com': 20,\n        'stackpath.bootstrapcdn.com': 30,\n        'maxcdn.bootstrapcdn.com': 30,\n        'cdn.datatables.net': 40,\n        'twemoji.maxcdn.com': 40,\n    },\n    '*': {\n        'ajax.cdnjs.com': 90,\n        'cdnjs.cloudflare.com': 90,\n        'cdn.jsdelivr.net': 40,\n        'raw.githubusercontent.com': 10,\n        'cdnjs.loli.net': 40,\n        'lib.baomitu.com': 20,\n        'lf6-cdn-tos.bytecdntp.com': 40,\n        'cdn.staticfile.org': 20,\n        'cdn.bootcss.com': 10,\n        'cdn.bootcdn.net': 20,\n        'unpkg.com': 40,\n        'g.alicdn.com': 30,\n        'pagecdn.io': 40,\n        'ajax.aspnetcdn.com': 70,\n        'ajax.googleapis.com': 90,\n        'code.jquery.com': 50,\n        'stackpath.bootstrapcdn.com': 40,\n        'maxcdn.bootstrapcdn.com': 50,\n        'cdn.datatables.net': 50,\n        'twemoji.maxcdn.com': 50,\n    },\n};\n\n//# sourceMappingURL=freecdn-main.js.map\n","/**\n * JS Hook Util\n * example: https://codepen.io/etherdream/pen/WNoQQbG?editors=0012\n */\nnamespace Hook {\n  /**\n   * hook function\n   */\n  export function func<\n    T, K extends keyof T,\n\n    // T[K] must be a function\n    F = T[K] extends (...args: infer P) => infer R\n      ? (this: T, ...args: P) => R\n      : never\n  >(\n    obj: T,\n    key: K,\n    factory: (oldFn: F) => F\n  ) {\n    const oldFn: F = obj[key] as any\n    if (!oldFn) {\n      return false\n    }\n    const newFn = factory(oldFn)\n    obj[key] = newFn as any\n    return true\n  }\n\n  /**\n   * hook property\n   */\n  export function prop<\n    T, K extends keyof T,\n\n    GETTER extends (this: T) => T[K],\n    SETTER extends (this: T, value: T[K]) => void,\n\n    GETTER_FACTORY extends (oldGetter: GETTER) => GETTER,\n    SETTER_FACTORY extends (oldSetter: SETTER) => SETTER,\n  >(\n    obj: T,\n    key: K,\n    getterFactory: GETTER_FACTORY | null,\n    setterFactory: SETTER_FACTORY | null,\n  ) {\n    const desc = Object.getOwnPropertyDescriptor(obj, key)\n    if (!desc) {\n      return false\n    }\n    if (getterFactory) {\n      func(desc, 'get', getterFactory)\n    }\n    if (setterFactory) {\n      func(desc, 'set', setterFactory)\n    }\n    Object.defineProperty(obj, key, desc)\n    return true\n  }\n}\n","declare const VER: string\ndeclare const RELEASE: never\nconst IS_DEBUG = typeof RELEASE === 'undefined'\n\n\nconst DEFAULT_PARAMS = `\n@__default__\n expires=30s\n mime=auto\n open_timeout=10s\n valid_status=200\n`\nconst DEFAULT_MANIFEST_PATH = '/freecdn-internal/freecdn-manifest.txt'\nconst MY_URL = location.href\nconst MY_HOST = location.host\nconst MY_ORIGIN = location.origin\nconst ROOT_PATH = MY_ORIGIN + '/'\n\nconst INTERNAL_DIR = 'freecdn-internal/' + (IS_DEBUG ? 'dev' : VER)\nconst INTERNAL_PATH = new URL(INTERNAL_DIR, ROOT_PATH).pathname\nconst REG_IMG_EXTS = /\\.(?:jpg|jpeg|png|apng|gif|ico|bmp)$/i\n\nconst enum LEN {\n  SHA256_BIN = 32,\n  SHA256_B64 = 44,\n  PUBKEY_B64 = 124,\n}\n\ntype params_t = ReadonlyMap<string, string>\n\nconst NATIVE_FETCH = fetch\nconst EMPTY_BUF = new Uint8Array(0)\n\nconst CRYPTO = crypto.subtle\n\n\nlet gInited: boolean | PromiseX\n\nasync function globalInit() {\n  if (gInited) {\n    return gInited\n  }\n  gInited = promisex()\n\n  await CacheManager.init()\n  await Network.init()\n  UrlConf.init()\n\n  gInited.resolve()\n  gInited = true\n}","interface RequestArgs extends RequestInit {\n  headers: Headers\n}\n\ninterface ResponseArgs extends ResponseInit {\n  headers: Headers\n  status: number\n  statusText: string\n  contentLen: number\n}\n\nclass ParamError extends Error {\n  public constructor(message: string) {\n    super(message)\n  }\n}\n\nabstract class ParamBase {\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) : may_async<Response | void> {\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) : void {\n  }\n\n  public onData(chunk: Uint8Array) : may_async<Uint8Array> {\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) : may_async<Uint8Array> {\n    return chunk\n  }\n\n  public onError(error: any) : void {\n  }\n\n  public onAbort(reason: any) : void {\n  }\n}\n\ninterface ParamSub {\n  new(...args: any[]) : ParamBase\n\n  reuse?: boolean\n\n  parseConf(conf: string) :\n    any[] |     // construct args\n    string |    // error info\n    undefined   // off\n\n  priority?: number\n}","namespace KeyManager {\n  let mKey: CryptoKey\n\n\n  export async function set(keyBase64: string) {\n    const keyBin = base64Decode(keyBase64)\n    if (!keyBin) {\n      return\n    }\n    mKey = await CRYPTO.importKey('spki', keyBin, {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    }, false, ['verify'])\n  }\n\n  export async function verify(data: Uint8Array) {\n    if (!mKey) {\n      return false\n    }\n    const linePos = data.lastIndexOf(10)  // 10 = '\\n'\n    const lineBin = data.subarray(linePos + 1)\n    const lineTxt = bytesToUtf8(lineBin)\n\n    const m = lineTxt.match(/# SIGN: ([A-Za-z0-9+/=]{88})$/)\n    if (!m) {\n      return false\n    }\n    const signTxt = m[1]\n    const signBin = base64Decode(signTxt) as Uint8Array\n    const dataBin = data.subarray(0, linePos)\n\n    return await CRYPTO.verify({\n      name: 'ECDSA',\n      hash: {\n        name: 'SHA-256'\n      },\n    }, mKey, signBin, dataBin)\n  }\n}","//\n// \n//\n// (http://foo/path/to/file)\n//    ...\n// (/path/to/file)\n//    ...\n// (@config)\n//    ...\n//  $0  lastIndex \n//\nconst REG_HEAD_LINE = /^(?:\\/|https?:|@).*/mg\n\n\nclass Manifest {\n  private readonly urlFileMap = new Map<string, FileConf>()\n  public globalParams!: params_t\n\n\n  public has(key: string) {\n    return this.urlFileMap.has(key)\n  }\n\n  public get(key: string) {\n    return this.urlFileMap.get(key)\n  }\n\n  public getParams(name: string) {\n    const fileConf = this.get(name)\n    if (fileConf) {\n      fileConf.parse()\n      return fileConf.params\n    }\n  }\n\n  public async parse(txt: string) {\n    this.parseFile(txt + DEFAULT_PARAMS)\n\n    const inc = this.urlFileMap.get('@include')\n    if (inc) {\n      const cdn = new FreeCDN()\n      cdn.manifest = this\n\n      const urls = inc.getLines()\n      const rets = urls.map(cdn.fetchText, cdn)\n      const txts = await Promise.all(rets)\n      txts.forEach(this.parseFile, this)\n    }\n  }\n\n  private parseFile(txt: string) {\n    // lazy parse\n    let name = ''\n    let last = 0\n\n    for (;;) {\n      const m = REG_HEAD_LINE.exec(txt)\n      if (last > 0) {\n        if (name[0] !== '@') {\n          name = toRelUrl(name)\n        }\n        const curr = m ? m.index : txt.length\n        const part = txt.substring(last, curr)\n        const conf = new FileConf(name, part)\n\n        this.urlFileMap.set(name, conf)\n      }\n      if (!m) {\n        break\n      }\n      name = m[0]\n      last = REG_HEAD_LINE.lastIndex\n    }\n\n    const m0 = this.getParams('@__default__') as params_t\n    const m1 = this.getParams('@global')\n\n    this.globalParams = m1 ? new Map([...m0, ...m1]) : m0\n  }\n}\n","class UrlConf {\n  private static nameClassMap: {[name: string] : ParamSub}\n\n  public static init() {\n    // \n    // \n    this.nameClassMap = {\n      // \n      'data': ParamData,\n      'bundle': ParamBundle,\n      'concat': ParamConcat,\n\n      'open_timeout': ParamOpenTimeout,\n      'recv_timeout': ParamRecvTimeout,\n      'referrer_policy': ParamReferrerPolicy,\n      'req_headers': ParamReqHeaders,\n      'valid_status': ParamValidStatus,\n\n      'headers': ParamHeaders,\n      'expires': ParamExpires,\n      'mime': ParamMime,\n      'charset': ParamCharset,\n\n      'pos': ParamPos,\n      'size': ParamSize,\n      'xor': ParamXor,\n      'br': ParamBr,\n\n      'prefix': ParamPrefix,\n      'suffix': ParamSuffix,\n      'hash': ParamHash,\n      'stream': ParamStream,\n    }\n    Object.values(this.nameClassMap).forEach((cls, i) => {\n      cls.priority = i\n    })\n  }\n\n  //  URL\n  public readonly url: string | undefined\n\n  // URL \n  public readonly frag: string | undefined\n\n\n  public constructor(url: string | undefined,\n    private readonly fileParams: params_t\n  ) {\n    if (url) {\n      [this.url, this.frag] = getPair(toRelUrl(url), '#')\n    }\n  }\n\n  public parse(manifest: Manifest) {\n    // TODO: cache result\n    const params = new Map<string, string>()\n\n    // :  <  <  < URL \n    mergeMap(params, manifest.globalParams)\n\n    // \n    if (this.url) {\n      const host = this.url[0] === '/' ? MY_HOST : getHostFromUrl(this.url)\n      const hostParams = manifest.getParams('@host ' + host)\n      if (hostParams) {\n        mergeMap(params, hostParams)\n      }\n    }\n\n    // \n    mergeMap(params, this.fileParams)\n\n    // URL  # \n    if (this.frag) {\n      const urlParams = new URLSearchParams(this.frag)\n      mergeMap(params, urlParams)\n    }\n\n    const mods: ParamBase[] = []\n\n    for (const [k, v] of params) {\n      const cls = UrlConf.nameClassMap[k]\n      if (!cls) {\n        console.warn('[FreeCDN/UrlConf] unknown param:', k)\n        continue\n      }\n      const ret = cls.parseConf(v)\n      if (ret === undefined) {\n        continue\n      }\n      if (typeof ret === 'string') {\n        console.warn('[FreeCDN/UrlConf] parseConf failed. mod:', k, 'err:', ret, 'conf:', v)\n        continue\n      }\n      const obj = new cls(...ret)\n      mods.push(obj)\n    }\n\n    mods.sort((a, b) =>\n      ((a.constructor as ParamSub).priority as number) -\n      ((b.constructor as ParamSub).priority as number)\n    )\n    return mods\n  }\n}\n","class UrlLoader {\n  private abortCtrl: AbortController | undefined\n\n  private pauseSignal: PromiseX | undefined\n  private isFetchDone = false\n\n  public bytesRead = 0\n  public onResponse!: (args: ResponseArgs) => void\n  public onData!: (chunk: Uint8Array) => void\n  public onEnd!: () => void\n  public onError!: (err: Error) => void\n\n\n  public constructor(\n    public readonly url: string | undefined,\n    private readonly paramMods: ParamBase[]) {\n  }\n\n  public async load(fileLoader: FileLoader) {\n    let isNetErr = false\n    let err: any\n    try {\n      //  fetch \n      //  catch \n      err = await this.loadUnsafe(fileLoader)\n      isNetErr = !!err\n    } catch (e) {\n      // \n      // console.assert(e instanceof ParamError, e)\n      err = e\n    }\n\n    if (err) {\n      if (this.abortCtrl && !this.abortCtrl.signal.aborted) {\n        for (const mod of this.paramMods) {\n          mod.onError(err)\n        }\n        this.onError(err)\n\n        if (!isNetErr) {\n          this.abort(err)\n        }\n      }\n    }\n  }\n\n  private async loadUnsafe(fileLoader: FileLoader) {\n    const {rawReq} = fileLoader\n    const {method} = rawReq\n    const reqArgs: RequestArgs = {\n      method,\n      referrer: rawReq.referrer,\n      referrerPolicy: 'same-origin',\n      headers: new Headers(),\n    }\n\n    if (method === 'POST' || method === 'PUT') {\n      reqArgs.body = await rawReq.clone().arrayBuffer()\n    }\n\n    let res: Response | void\n\n    for (const mod of this.paramMods) {\n      //  data bundle \n      const ret = mod.onRequest(reqArgs, fileLoader)\n      if (ret) {\n        res = isPromise(ret) ? await ret : ret\n        if (res) {\n          break\n        }\n      }\n    }\n\n    if (!res) {\n      if (!this.url) {\n        this.onError(Error('vURL no data'))\n        return\n      }\n      this.abortCtrl = new AbortController()\n      reqArgs.signal = this.abortCtrl.signal\n\n      const req = new Request(this.url, reqArgs)\n      try {\n        res = await Network.fetch(req)\n      } catch (err) {\n        return err\n      }\n    }\n    if (!res.body) {\n      return Error('cors error')\n    }\n\n    const resArgs: ResponseArgs = {\n      status: res.status,\n      statusText: res.statusText,\n      headers: new Headers(),\n      contentLen: -1,\n    }\n    if (!res.headers.has('content-encoding')) {\n      const contentLen = res.headers.get('content-length')\n      if (contentLen) {\n        resArgs.contentLen = +contentLen\n      }\n    }\n    for (const mod of this.paramMods) {\n      mod.onResponse(resArgs, fileLoader, res)\n    }\n\n    const contentRange = res.headers.get('content-range')\n    if (contentRange) {\n      const m = contentRange.match(/bytes (\\d+)-/i)\n      if (m) {\n        const rangeBegin = +m[1]\n        if (rangeBegin > 0) {\n          this.bytesRead = rangeBegin\n        }\n      }\n    }\n\n    if (resArgs.contentLen !== -1) {\n      resArgs.headers.set('content-length', resArgs.contentLen + '')\n    }\n    this.onResponse(resArgs)\n\n    const reader = res.body.getReader()\n    let buf: Uint8Array\n\n    READ: for (;;) {\n      try {\n        const {value} = await reader.read()\n        if (!value) {\n          break\n        }\n        buf = value\n      } catch (err) {\n        return err\n      }\n\n      for (const mod of this.paramMods) {\n        const ret = mod.onData(buf)\n        buf = isPromise(ret) ? await ret : ret\n        if (buf.length === 0) {\n          continue READ\n        }\n      }\n\n      if (buf.length > 0) {\n        this.pauseSignal && await this.pauseSignal\n        this.bytesRead += buf.length\n        this.onData(buf)\n      }\n    } // READ NEXT\n\n    this.isFetchDone = true\n    buf = EMPTY_BUF\n\n    for (const mod of this.paramMods) {\n      const ret = mod.onEnd(buf)\n      buf = isPromise(ret) ? await ret : ret\n    }\n\n    if (buf.length > 0) {\n      this.pauseSignal && await this.pauseSignal\n      this.bytesRead += buf.length\n      this.onData(buf)\n    }\n\n    this.onEnd()\n  }\n\n  public pause() {\n    this.pauseSignal = promisex()\n  }\n\n  public resume() {\n    this.pauseSignal?.resolve()\n    this.pauseSignal = undefined\n  }\n\n  public abort(reason: any) {\n    if (this.isFetchDone) {\n      return\n    }\n    this.abortCtrl?.abort()\n\n    for (const mod of this.paramMods) {\n      mod.onAbort(reason)\n    }\n  }\n}\n","//  trim  `#` \nconst REG_SUB_LINE = /^\\s+([^#\\s].+?)\\s*$/mg\n\n\nclass FileConf {\n  public urlConfs!: readonly UrlConf[]\n  public params!: params_t\n\n\n  public constructor(\n    public readonly name: string,\n    private text: string\n  ) {\n  }\n\n  public getLines() {\n    const lines: string[] = []\n    for (;;) {\n      const m = REG_SUB_LINE.exec(this.text)\n      if (!m) {\n        break\n      }\n      lines.push(m[1])\n    }\n    this.text = ''\n    return lines\n  }\n\n  public parse() {\n    if (this.text === '') {\n      return\n    }\n    const urlConfs: UrlConf[] = []\n    const params = new Map<string, string>()\n\n    for (const line of this.getLines()) {\n      if (/^https?:|^\\//.test(line)) {\n        const urlConf = new UrlConf(line, params)\n        urlConfs.push(urlConf)\n      } else {\n        const [key, val] = getPair(line, '=')\n        if (val === undefined) {\n          console.warn('[FreeCDN/FileConf] missing param value:', line)\n          continue\n        }\n        params.set(key, val)\n      }\n    }\n    this.params = params\n    this.urlConfs = urlConfs\n  }\n}\n","const FILE_BACKUP_PARAMS = [\n  'open_timeout',\n  'recv_timeout',\n  'hash',\n  'req_headers',\n  'valid_status',\n]\n\nclass FileLoaderError extends Error {\n  public constructor(message: string) {\n    super(message)\n  }\n  public urlErrs!: {url: string, err: Error}[]\n}\n\n\nclass FileLoader {\n  private readonly urlConfs: UrlConf[]\n  private readonly urlLoaderSet = new Set<UrlLoader>()\n\n  private vUrlConf: UrlConf | undefined\n\n  private isPaused = false\n  private isAborted = false\n  private delayTid = 0\n  private urlErrs: {url: string, err: Error}[] = []\n\n  public readonly hasRange: boolean = false\n  public readonly rangeBegin: number | undefined\n  public readonly rangeEnd: number | undefined\n  public readonly fileSize: number | undefined\n\n  private opened = false\n  private closed = false\n  public bytesRead = 0\n\n  public onOpen!: (args: ResponseArgs) => void\n  public onData!: (chunk: Uint8Array) => void\n  public onEnd!: () => void\n  public onError!: (err: FileLoaderError) => void\n\n\n  public constructor(\n    public readonly fileConf: FileConf,\n    public readonly rawReq: Request,\n    public readonly cdn: FreeCDN,\n    public range: string | null,\n    public suffix: string\n  ) {\n    const fileParams = fileConf.params\n\n    if (range) {\n      const r = this.parseReqRange(range)\n      if (r) {\n        [this.rangeBegin, this.rangeEnd] = r\n        this.hasRange = true\n        this.bytesRead = this.rangeBegin\n      }\n      const fileSize = fileParams.get('size')\n      if (fileSize) {\n        this.fileSize = +fileSize\n      }\n    }\n\n    if (fileParams.has('data') || fileParams.has('bundle') || fileParams.has('concat')) {\n      this.vUrlConf = new UrlConf(undefined, fileParams)\n    }\n\n    //  URL \n    // \n    const backupParams = new Map<string, string>()\n    for (const k of FILE_BACKUP_PARAMS) {\n      const v = fileParams.get(k)\n      if (v !== undefined) {\n        backupParams.set(k, v)\n      }\n    }\n    const backupUrlConf = new UrlConf(fileConf.name, backupParams)\n\n    this.urlConfs = fileConf.urlConfs.concat(backupUrlConf)\n  }\n\n  private parseReqRange(range: string) {\n    //  `bytes=begin-end`  `bytes=begin-` \n    const m = range.match(/bytes=(\\d+)-(\\d*)/i)\n    if (!m) {\n      return\n    }\n    const begin = +m[1]\n    const end = +m[2]   // +'' === 0\n\n    if (end !== 0 && end <= begin) {\n      return\n    }\n    return [begin, end]\n  }\n\n  private buildResRange(resArgs: ResponseArgs) {\n    const begin = this.rangeBegin as number\n    let end = 0\n    if (this.rangeEnd) {\n      end = this.rangeEnd - 1\n    } else if (this.fileSize) {\n      end = this.fileSize - 1\n    } else if (resArgs.contentLen > 0) {\n      end = resArgs.contentLen\n    }\n    const val = 'bytes ' + begin + '-' + end + '/' + (this.fileSize || '*')\n\n    // TODO: status 416\n    resArgs.status = 206\n    resArgs.headers.set('content-range', val)\n\n    if (end > 0) {\n      const len = end - begin + 1\n      resArgs.headers.set('content-length', len + '')\n    }\n  }\n\n  public open() {\n    this.loadNextUrl()\n  }\n\n  public pause() {\n    if (this.isPaused) {\n      return\n    }\n    this.isPaused = true\n\n    // TODO:  Loader \n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.pause()\n    }\n  }\n\n  public resume() {\n    if (!this.isPaused) {\n      return\n    }\n    this.isPaused = false\n\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.resume()\n    }\n  }\n\n  public abort(reason: any) {\n    if (this.isAborted) {\n      return\n    }\n    this.isAborted = true\n\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.abort(reason)\n    }\n    if (this.delayTid !== 0) {\n      clearTimeout(this.delayTid)\n    }\n  }\n\n  private getNextUrl() {\n    //  URL data  URL\n    const {vUrlConf} = this\n    if (vUrlConf) {\n      this.vUrlConf = undefined\n      return {weight: 100, conf: vUrlConf}\n    }\n\n    const {urlConfs} = this\n    const lastIndex = urlConfs.length - 1\n    if (lastIndex === -1) {\n      return\n    }\n    const now = getTimeSec()\n    let weight = -10000\n    let index = 0\n\n    urlConfs.forEach((conf, i) => {\n      const w = Network.getUrlWeight(conf.url as string, now, this.cdn.weightConf)\n      if (w > weight) {\n        weight = w\n        index = i\n      }\n    })\n\n    //  urlConfs[index]\n    const conf = urlConfs[index]\n    urlConfs[index] = urlConfs[lastIndex]\n    urlConfs.length = lastIndex\n\n    return {weight, conf}\n  }\n\n  public loadNextUrl(delay = 0) {\n    const ret = this.getNextUrl()\n    if (!ret) {\n      if (this.urlLoaderSet.size === 0) {\n        const err = new FileLoaderError('failed to load: ' + this.getSourceUrl())\n        err.urlErrs = this.urlErrs\n        this.onError(err)\n      }\n      return\n    }\n    const {weight, conf} = ret\n\n    if (weight < 0 && delay > 0) {\n      //  URL \n      this.delayTid = setTimeout(() => {\n        this.delayTid = 0\n        this.createUrlLoader(conf)\n      }, delay)\n      return\n    }\n    this.createUrlLoader(conf)\n  }\n\n  public getSourceUrl() {\n    return this.fileConf.name + this.suffix\n  }\n\n  private getTargetUrl(url: string) {\n    if (url.endsWith('/')) {\n      return url + this.suffix\n    }\n    return url\n  }\n\n  private createUrlLoader(urlConf: UrlConf) {\n    const url = urlConf.url && this.getTargetUrl(urlConf.url)\n    const mods = urlConf.parse(this.cdn.manifest as Manifest)\n\n    const urlLoader = new UrlLoader(url, mods)\n    this.urlLoaderSet.add(urlLoader)\n\n    urlLoader.onData = (chunk) => {\n      if (this.closed) {\n        return\n      }\n      const add = urlLoader.bytesRead - this.bytesRead\n      if (add <= 0) {\n        // \n        return\n      }\n      if (add !== chunk.length) {\n        chunk = chunk.subarray(-add)\n      }\n      this.bytesRead = urlLoader.bytesRead\n\n      if (this.rangeEnd) {\n        const exceed = this.bytesRead - this.rangeEnd\n        if (exceed > 0) {\n          chunk = chunk.subarray(0, -exceed)\n          this.onData(chunk)\n          urlLoader.onEnd()\n          return\n        }\n      }\n      this.onData(chunk)\n    }\n\n    urlLoader.onEnd = () => {\n      if (this.closed) {\n        return\n      }\n      this.closed = true\n      this.onEnd()\n      this.abort('TASK_DONE')\n    }\n\n    urlLoader.onError = (err) => {\n      this.urlErrs.push({url: urlLoader.url || '', err})\n      this.urlLoaderSet.delete(urlLoader)\n      this.loadNextUrl()\n    }\n\n    urlLoader.onResponse = (resArgs) => {\n      if (this.opened) {\n        return\n      }\n      if (this.hasRange) {\n        this.buildResRange(resArgs)\n      }\n      this.opened = true\n      this.onOpen(resArgs)\n    }\n\n    urlLoader.load(this)\n  }\n}\n","const enum UpdaterConf {\n  FETCH_TIMEOUT = 1000 * 3,\n\n  DEFAULT_INTERVAL = 1000 * 300,\n  MIN_INTERVAL = 1000,\n\n  SET_SVC_DELAY = 1000 * 5,\n  WS_RETRY_DELAY = 1000 * 20,\n}\n\nconst EMPTY_PARAMS: params_t = new Map()\n\n\nclass Updater {\n  private readonly manifestUrl: string\n  private readonly urlWsMap = new Map<string, WebSocket>()\n  private readonly wsArgs: string = ''\n\n  private updateSignal: PromiseX<boolean> | undefined\n  private manifestHash = EMPTY_BUF\n  private pollingTimer = 0\n  private pollingInterval = UpdaterConf.DEFAULT_INTERVAL\n  private lastTime = 0\n  private setSvcTimer = 0\n  private backupUrls: string[] = []\n\n\n  public constructor(\n    manifestPath: string,\n    private onAvailable: (manifest: Manifest) => void\n  ) {\n    const url = new URL(manifestPath, MY_URL)\n    console.assert(url.host === MY_HOST)\n\n    const path = url.pathname + url.search\n    if (path !== DEFAULT_MANIFEST_PATH) {\n      this.wsArgs = '?manifest=' + encodeURIComponent(path)\n    }\n    this.manifestUrl = path\n  }\n\n  private async getManifestFromCache() {\n    const res = await CacheManager.findCache(this.manifestUrl)\n    if (!res) {\n      return\n    }\n    const buf = await res.arrayBuffer()\n    const bin = new Uint8Array(buf)\n\n    // \n    if (!await KeyManager.verify(bin)) {\n      return\n    }\n    const txt = bytesToUtf8(bin)\n    const manifest = new Manifest()\n    await manifest.parse(txt)\n    return manifest\n  }\n\n  public async init() {\n    const manifest = await this.getManifestFromCache()\n    if (manifest) {\n      // \n      this.onAvailable(manifest)\n    }\n    await this.update()\n  }\n\n  public async update() {\n    if (this.updateSignal) {\n      return this.updateSignal\n    }\n    const now = Date.now()\n    if (now - this.lastTime < UpdaterConf.MIN_INTERVAL) {\n      return true\n    }\n    this.lastTime = now\n    this.updateSignal = promisex()\n\n    let ret = false\n    try {\n      ret = await this.updateUnsafe()\n    } catch (err) {\n      console.error('[FreeCDN/Updater] update err:', err)\n    }\n    this.updateSignal.resolve(ret)\n    this.updateSignal = undefined\n    return ret\n  }\n\n  private async updateUnsafe() {\n    // from current site\n    const data = await this.fetchManifest(this.manifestUrl)\n    if (data) {\n      await this.applyManifest(data)\n      return true\n    }\n    console.warn('[FreeCDN/Updater] failed to fetch 1st manifest:', this.manifestUrl)\n\n    if (this.backupUrls.length === 0) {\n      console.warn('[FreeCDN/Updater] no backup url')\n      return false\n    }\n\n    // from backup sites\n    for (const url of this.backupUrls) {\n      const data = await this.fetchManifest(url)\n      if (!data) {\n        console.warn('[FreeCDN/Updater] failed to fetch 3rd manifest:', url)\n        continue\n      }\n      if (!await KeyManager.verify(data)) {\n        console.warn('[FreeCDN/Updater] failed to verify 3rd manifest:', url)\n        continue\n      }\n      await this.applyManifest(data)\n      return true\n    }\n    console.warn('[FreeCDN/Updater] failed to reload')\n    return false\n  }\n\n  private async fetchManifest(url: string) {\n    const ctl = new AbortController()\n    const tid = setTimeout(() => {\n      ctl.abort()\n    }, UpdaterConf.FETCH_TIMEOUT)\n\n    const req = new Request(url, {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\n      cache: 'no-cache',\n      signal: ctl.signal,\n    })\n    try {\n      const res = await Network.fetch(req)\n      const bin = await res.arrayBuffer()\n      return new Uint8Array(bin)\n    } catch {\n    } finally {\n      clearTimeout(tid)\n    }\n  }\n\n  private async applyManifest(bytes: Uint8Array) {\n    const hash = await sha256(bytes)\n    if (isArrayEqual(this.manifestHash, hash)) {\n      return\n    }\n    this.manifestHash = hash\n\n    // \n    const res = new Response(bytes)\n    res.headers.set('content-length', bytes.length + '')\n    CacheManager.addCache(this.manifestUrl, res)\n\n    const manifest = new Manifest()\n    const txt = bytesToUtf8(bytes)\n\n    await manifest.parse(txt)\n    this.onAvailable(manifest)\n  }\n\n  public applyConfs(params: params_t) {\n    this.backupUrls = this.parseBackupParam(params)\n\n    const interval = this.parseIntervalParam(params)\n    this.setPollingInterval(interval)\n\n    const svcUrls = this.parseServicesParam(params)\n    if (this.setSvcTimer > 0) {\n      clearTimeout(this.setSvcTimer)\n    }\n    // \n    this.setSvcTimer = setTimeout(() => {\n      this.setSvcTimer = 0\n      this.setServices(svcUrls)\n    }, UpdaterConf.SET_SVC_DELAY)\n  }\n\n  private parseBackupParam(params: params_t) {\n    const str = params.get('backup') || ''\n    return splitList(str)\n  }\n\n  private parseIntervalParam(params: params_t) {\n    const str = params.get('interval')\n    if (str) {\n      const num = parseTime(str)\n      if (!isNaN(num)) {\n        return num\n      }\n      console.warn('[FreeCDN/Updater] invalid interval:', str)\n    }\n    return UpdaterConf.DEFAULT_INTERVAL\n  }\n\n  private parseServicesParam(params: params_t) {\n    const str = params.get('services') || ''\n    return splitList(str)\n  }\n\n  private setPollingInterval(interval: number) {\n    if (this.pollingInterval === interval) {\n      return\n    }\n    this.pollingInterval === interval\n\n    if (this.pollingTimer) {\n      clearInterval(this.pollingTimer)\n    }\n    if (interval > 0) {\n      this.pollingTimer = setInterval(() => {\n        this.update()\n      }, interval)\n    }\n  }\n\n  private setServices(urls: string[]) {\n    for (const [url, ws] of this.urlWsMap) {\n      if (!urls.includes(url)) {\n        ws.onclose = null\n        ws.close()\n        this.urlWsMap.delete(url)\n      }\n    }\n    for (const url of urls) {\n      if (!this.urlWsMap.has(url)) {\n        this.createSvc(url)\n      }\n    }\n  }\n\n  private createSvc(url: string) {\n    const ws = new WebSocket(url + this.wsArgs)\n    ws.binaryType = 'arraybuffer'\n    ws.onmessage = (e) => {\n      const hashBin = new Uint8Array(e.data)\n      if (isArrayEqual(this.manifestHash, hashBin)) {\n        return\n      }\n      this.update()\n    }\n    ws.onclose = () => {\n      this.urlWsMap.delete(url)\n\n      setTimeout(() => {\n        this.createSvc(url)\n      }, UpdaterConf.WS_RETRY_DELAY)\n    }\n    this.urlWsMap.set(url, ws)\n  }\n}","///<reference path=\"global.ts\"/>\n///<reference path=\"param-base.ts\"/>\n///<reference path=\"key-manager.ts\"/>\n///<reference path=\"manifest.ts\"/>\n///<reference path=\"url-conf.ts\"/>\n///<reference path=\"url-loader.ts\"/>\n///<reference path=\"file-conf.ts\"/>\n///<reference path=\"file-loader.ts\"/>\n///<reference path=\"updater.ts\"/>\n\n\nclass FreeCDN {\n  public enableCacheStorage = true\n  public manifest: Manifest | undefined\n  public isSubReq = false\n\n  private readonly updater: Updater | undefined\n  public weightConf = new Map<string, number>()\n  private inited = false\n\n\n  public constructor(manifestUrl?: string) {\n    if (!manifestUrl) {\n      return\n    }\n    const updater = new Updater(manifestUrl, manifest => {\n      this.manifest = manifest\n\n      const updateConf = manifest.getParams('@update') || EMPTY_PARAMS\n      updater.applyConfs(updateConf)\n\n      // \n      this.weightConf = Network.parseWeightConf(manifest)\n    })\n\n    this.updater = updater\n  }\n\n  public async fetch(input: RequestInfo, init?: RequestInit) {\n    const req = (input instanceof Request && !init)\n      ? input\n      : new Request(input, init)\n\n    if (!/^https?:/.test(req.url)) {\n      return NATIVE_FETCH(req)\n    }\n\n    const {manifest} = this\n    if (!manifest) {\n      return Network.fetch(req)\n    }\n\n    let fileConf: FileConf | undefined\n    let suffix = ''\n\n    FIND: for (;;) {\n      const urlObj = new URL(req.url)\n\n      //  URL \n      const originPrefix = urlObj.origin === MY_ORIGIN ? '' : urlObj.origin\n\n      //  URL \n      if (urlObj.search) {\n        fileConf = manifest.get(originPrefix + urlObj.pathname + urlObj.search)\n        if (fileConf) {\n          break\n        }\n      }\n\n      //  `/`\n      const path = urlObj.pathname.replace(/\\/{2,}/g, '/')\n      const file = originPrefix + path\n\n      //  avifwebp \n      if (REG_IMG_EXTS.test(file) && req.mode !== 'cors' && !req.integrity) {\n        const accept = req.headers.get('accept') || ''\n        if (accept.includes('image/avif')) {\n          fileConf = manifest.get(file + '.avif')\n          if (fileConf) {\n            break\n          }\n        }\n        if (accept.includes('image/webp')) {\n          fileConf = manifest.get(file + '.webp')\n          if (fileConf) {\n            break\n          }\n        }\n      }\n\n      fileConf = manifest.get(file)\n      if (fileConf) {\n        break\n      }\n      if (file.endsWith('/')) {\n        fileConf = manifest.get(file + 'index.html')\n        if (fileConf) {\n          break\n        }\n      }\n      //  `/` \n      if (manifest.has(file + '/index.html')) {\n        return Response.redirect(file + '/')\n      }\n\n      // \n      //  suffix  /path/to/file?a=1\n      //  /path/ suffix  `to/file?a=1`\n\n      //  `/` \n      let dir = path.replace(/[^/]*$/, '')\n\n      for (;;) {\n        fileConf = manifest.get(originPrefix + dir)\n        if (fileConf) {\n          suffix = path.substring(dir.length) + urlObj.search\n          break FIND\n        }\n        if (dir === '/') {\n          break\n        }\n        //  `/` \n        dir = dir.replace(/[^/]+\\/$/, '')\n      }\n\n      // \n      return Network.fetch(req)\n    }\n\n    fileConf.parse()\n\n    let fileHash = ''\n    const hashParam = fileConf.params.get('hash')\n    if (hashParam && hashParam.length === LEN.SHA256_B64) {\n      fileHash = hashParam\n    }\n\n    const range = req.headers.get('range')\n\n    const cacheable = this.enableCacheStorage && fileHash && !range\n    if (cacheable) {\n      const res = await CacheManager.findHash(fileHash)\n      if (res) {\n        return res\n      }\n    }\n\n    const fileLoader = new FileLoader(fileConf, req, this, range, suffix)\n    const promiseObj = promisex<Response>()\n\n    req.signal.addEventListener('abort', () => {\n      const reason = (req.signal as any).reason || 'unknown'\n      fileLoader.abort(reason)\n    })\n\n    //  hash  hash\n    if (fileHash) {\n      fileLoader.onOpen = (args) => {\n        fileLoader.onData = (body) => {\n          const res = new Response(body, args)\n          if (cacheable && body.length < 1024 * 1024 * 5) {\n            const cacheRes = res.clone()\n            // \n            cacheRes.headers.set('content-length', body.length + '')\n            cacheRes.headers.set('x-raw-url', req.url)\n            CacheManager.addHash(fileHash, cacheRes)\n          }\n          promiseObj.resolve(res)\n        }\n      }\n      fileLoader.onError = (err) => {\n        console.warn('[FreeCDN]', err.message, err.urlErrs)\n        promiseObj.reject(err)\n      }\n      fileLoader.onEnd = () => {\n      }\n      fileLoader.open()\n      return promiseObj\n    }\n\n    //  hash  hash\n    let controller: ReadableStreamDefaultController<Uint8Array>\n\n    const checkPressure = () => {\n      const {desiredSize} = controller\n      if (desiredSize === null) {\n        console.warn('desiredSize is null')\n        return\n      }\n      if (desiredSize <= 0) {\n        fileLoader.pause()\n      } else {\n        fileLoader.resume()\n      }\n    }\n\n    const stream = new ReadableStream({\n      start(c) {\n        controller = c\n      },\n      pull: checkPressure,\n      cancel(reason: any) {\n        console.warn('[FreeCDN] stream cancel:', reason)\n        fileLoader.abort(reason)\n      },\n    })\n\n    fileLoader.onData = (chunk) => {\n      controller.enqueue(chunk)\n      checkPressure()\n    }\n    fileLoader.onEnd = () => {\n      controller.close()\n    }\n    fileLoader.onError = (err) => {\n      controller.error()\n      console.warn('[FreeCDN]', err.message, err.urlErrs)\n      promiseObj.reject(err)\n    }\n    fileLoader.onOpen = (args) => {\n      const res = new Response(stream, args)\n      promiseObj.resolve(res)\n    }\n    fileLoader.open()\n    return promiseObj\n  }\n\n  public async fetchText(url: string) {\n    const res = await this.fetch(url)\n    return res.text()\n  }\n\n  public async fetchBin(url: string) {\n    const res = await this.fetch(url)\n    const buf = await res.arrayBuffer()\n    return new Uint8Array(buf)\n  }\n\n  public async fetchBlob(url: string) {\n    const res = await this.fetch(url)\n    const buf = await res.arrayBuffer()\n    const type = res.headers.get('content-type') || ''\n    return new Blob([buf], {type})\n  }\n\n  public async update() {\n    if (this.updater) {\n      return this.updater.update()\n    }\n    return false\n  }\n\n  public async setPublicKey(keyB64: string) {\n    if (keyB64.length !== LEN.PUBKEY_B64) {\n      keyB64 = `MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE${keyB64}==`\n    }\n    await KeyManager.set(keyB64)\n  }\n\n  public async init() {\n    console.assert(!this.inited)\n    this.inited = true\n\n    await globalInit()\n\n    if (this.updater) {\n      await this.updater.init()\n    }\n  }\n}","//\n// Promise Utils\n//\ntype may_async<T> = T | Promise<T>\n\ntype resolve_t<T> = (value: may_async<T>) => void\ntype reject_t = (reason?: any) => void\n\n\ninterface PromiseX<T = void> extends Promise<T> {\n  readonly resolve: resolve_t<T>\n  readonly reject: reject_t\n}\n\n// non-callback style Promise\nfunction promisex<T = void>() : PromiseX<T> {\n  let resolve: resolve_t<T>\n  let reject: reject_t\n\n  const p = new Promise((a, b) => {\n    resolve = a\n    reject = b\n  }) as PromiseX<T>\n\n  // @ts-ignore\n  p.resolve = resolve\n\n  // @ts-ignore\n  p.reject = reject\n\n  return p\n}\n\n// faster than instanceof\nfunction isPromise(obj: any /* except nullable */ | Promise<any>) : obj is Promise<any> {\n  return typeof obj.then === 'function'\n}","///<reference path=\"../../core-lib/src/freecdn.ts\"/>\n///<reference path=\"../../core-lib/src/promisex.ts\"/>\n///<reference path=\"hook.ts\"/>\n\n\ndeclare const Q: any[]\n\n\nnamespace Sw {\n  const GLOBAL: ServiceWorkerGlobalScope = self as any\n\n  const mLoaderJsRes = new Response('/* freecdn is installed */', {\n    headers: {\n      'content-type': 'text/javascript',\n      'cache-control': 'max-age=3600',\n    },\n  })\n\n  let mFreeCDN: FreeCDN\n\n  let mIniting: PromiseX | null\n  let mResUrlMap: WeakMap<Response, string>\n\n\n  //  SW \n  function sharedModeInit() {\n    Hook.func(GLOBAL, 'fetch', oldFn => sharedModeHandler)\n\n    Hook.func(Cache.prototype, 'add', oldFn => async function(req) {\n      const res = await sharedModeHandler(req)\n      await this.put(req, res)\n    })\n\n    Hook.func(Cache.prototype, 'addAll', oldFn => async function(reqs) {\n      const tasks = reqs.map(req => this.add(req))\n      await Promise.all(tasks)\n    })\n\n    mResUrlMap = new WeakMap()\n\n    //  Response  url  hook  url\n    Hook.prop(Response.prototype, 'url',\n      getter => function() {\n        return mResUrlMap.get(this) || getter.call(this)\n      },\n      /* setter */ null\n    )\n\n    Hook.func(Response.prototype, 'clone', oldFn => function() {\n      const res = oldFn.call(this)\n      const url = mResUrlMap.get(this)\n      if (url) {\n        mResUrlMap.set(res, url)\n      }\n      return res\n    })\n  }\n\n  async function sharedModeHandler(input: RequestInfo, init?: RequestInit) {\n    if (mIniting) {\n      // freecdn \n      await mIniting\n    }\n    const req = (input instanceof Request && !init)\n      ? input\n      : new Request(input, init)\n\n    const res = await mFreeCDN.fetch(req)\n    mResUrlMap.set(res, req.url)\n    return res\n  }\n\n  //  freecdn-loader.min.js \n  function loaderModeInit() {\n    type tuple = Parameters<typeof loaderModeHandler>\n\n    //  Q.push loader-js  event  promise\n    Q.push = loaderModeHandler as any\n\n    while (Q.length) {\n      const args = Q.splice(0, 3) as tuple\n      loaderModeHandler(...args)\n    }\n  }\n\n  function loaderModeHandler(\n    e: FetchEvent,\n    resolve: resolve_t<Response>,\n    reject: reject_t,\n  ) {\n    const req = e.request\n\n    // debug\n    if (req.url.endsWith('/freecdn-update')) {\n      mFreeCDN.update().then(result => {\n        const res = new Response('updated. success: ' + result, {\n          headers: {\n            'content-type': 'text/html',\n          },\n        })\n        resolve(res)\n      })\n      return\n    }\n\n    if (req.url === MY_URL) {\n      resolve(mLoaderJsRes.clone())\n      return\n    }\n\n    mFreeCDN.fetch(req).then(resolve, reject)\n  }\n\n  async function main() {\n    mFreeCDN = new FreeCDN('freecdn-internal/freecdn-manifest.txt')\n\n    const isSharedMode = !!(GLOBAL as any).FREECDN_SHARED_MODE\n\n    let publicKey: string | undefined\n\n    if (isSharedMode) {\n      mFreeCDN.enableCacheStorage = false\n      mIniting = promisex()\n\n      //  await hook  hook\n      sharedModeInit()\n      publicKey = (GLOBAL as any).FREECDN_PUBLIC_KEY\n    } else {\n      publicKey = Q.shift()\n    }\n\n    if (publicKey) {\n      await mFreeCDN.setPublicKey(publicKey)\n    }\n    await mFreeCDN.init()\n\n    if (isSharedMode) {\n      mIniting?.resolve()\n      mIniting = null\n    } else {\n      loaderModeInit()\n    }\n\n    console.log('[FreeCDN] service worker inited')\n  }\n  main()\n}","declare const BR_GLUE_HASH: string\ndeclare const BR_WASM_HASH: string\n\nconst enum ParamBrConf {\n  WASM_LOAD_TIMEOUT = 1000 * 20,\n  IN_BUF_LEN = 1024 * 128,\n  OUT_BUF_LEN = 1024 * 512,\n}\n\nclass ParamBr extends ParamBase {\n  private static hasErr = false\n  private static signal: PromiseX | undefined\n  private static asmMod: any\n\n  private static inPtr: number\n  private static outPtr: number\n\n\n  private static async init() {\n    if (this.signal) {\n      return\n    }\n    this.signal = promisex()\n\n    const BR_WASM_PATH = `${INTERNAL_PATH}/br/br.wasm`\n    const BR_GLUE_PATH = `${INTERNAL_PATH}/br/` + (IS_DEBUG ? 'br.js' : 'br.min.js')\n\n    const BR_MANIFEST = IS_DEBUG ? '' : `\n${BR_WASM_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.wasm\n\thash=${BR_WASM_HASH}\n\n${BR_GLUE_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.min.js\n\thash=${BR_GLUE_HASH}\n`\n    const onError = () => {\n      this.hasErr = true\n      this.signal?.resolve()\n    }\n    const timer = setTimeout(onError, ParamBrConf.WASM_LOAD_TIMEOUT)\n\n    const asmMod: any = {\n      locateFile: () => BR_WASM_PATH,\n      onRuntimeInitialized: () => {\n        this.inPtr = asmMod._AllocInBuf(ParamBrConf.IN_BUF_LEN)\n        this.outPtr = asmMod._AllocOutBuf(ParamBrConf.OUT_BUF_LEN)\n\n        clearTimeout(timer)\n        this.signal?.resolve()\n        this.signal = undefined\n      },\n      onAbort: (reason: any) => {\n        console.warn('[FreeCDN/Br] wasm onAbort:', reason)\n        onError()\n      },\n      print: (msg: any) => {\n        console.warn('[FreeCDN/Br] wasm print:', msg)\n      },\n      printErr: (err: any) => {\n        console.warn('[FreeCDN/Br] wasm printErr:', err)\n      },\n    }\n\n    const manifest = new Manifest()\n    await manifest.parse(BR_MANIFEST)\n\n    const cdn = new FreeCDN()\n    cdn.manifest = manifest\n\n    const onFetch: typeof cdn.fetch = async (...args) => {\n      try {\n        return await cdn.fetch(...args)\n      } catch (err) {\n        console.warn('[FreeCDN/Br] failed to load wasm')\n        onError()\n        throw err\n      }\n    }\n    try {\n      const js = await cdn.fetchText(BR_GLUE_PATH)\n      const fn = Function('Module', 'fetch', js)\n      fn(asmMod, onFetch)\n    } catch {\n      console.warn('[FreeCDN/Br] failed to execute glue js')\n      onError()\n      return\n    }\n    this.asmMod = asmMod\n  }\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    if (conf === 'on') {\n      if (!this.asmMod) {\n        this.init()\n      }\n      return []\n    }\n    return 'invalid value'\n  }\n\n\n  private state = 0\n\n  public constructor() {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    resArgs.contentLen = -1\n  }\n\n  public async onData(chunk: Uint8Array) {\n    if (ParamBr.signal) {\n      await this.waitWasm()\n    }\n    return this.process(chunk)\n  }\n\n  public async onEnd(chunk: Uint8Array) {\n    if (ParamBr.signal) {\n      await this.waitWasm()\n    }\n    // ???\n    let buf = EMPTY_BUF\n    if (chunk.length > 0) {\n      buf = this.process(chunk)\n    }\n    this.destory()\n    return buf\n  }\n\n  private async waitWasm() {\n    await ParamBr.signal\n    if (ParamBr.hasErr) {\n      throw new ParamError('failed to load br decoder')\n    }\n  }\n\n  private process(chunk: Uint8Array) {\n    // brotli/c/include/decode.h\n    const enum RET {\n      ERROR = 0,\n      SUCCESS = 1,\n      NEEDS_MORE_INPUT = 2,\n      NEEDS_MORE_OUTPUT = 3\n    }\n    const asmObj = ParamBr.asmMod\n    const HEAPU8 = asmObj.HEAPU8 as Uint8Array\n\n    if (this.state === 0) {\n      this.state = asmObj._Init()\n    }\n\n    const outBufs: Uint8Array[] = []\n\n    for (let p = 0; p < chunk.length; p += ParamBrConf.IN_BUF_LEN) {\n      const inBuf = chunk.subarray(p, p + ParamBrConf.IN_BUF_LEN)\n      HEAPU8.set(inBuf, ParamBr.inPtr)\n\n      let avaiablelIn = inBuf.length\n      let availableOut = 0\n      do {\n        const ret = asmObj._Update(this.state, 0, avaiablelIn)\n\n        if (ret === RET.ERROR) {\n          const err = asmObj._GetErrorCode()\n          this.destory()\n          throw new ParamError('br decode failed. code: ' + err)\n        }\n        avaiablelIn = asmObj._GetAvailableIn()\n        availableOut = asmObj._GetAvailableOut()\n\n        const len = ParamBrConf.OUT_BUF_LEN - availableOut\n        if (len === 0) {\n          continue\n        }\n        // use slice (copy), not subarray (ref)\n        const outBuf = HEAPU8.slice(ParamBr.outPtr, ParamBr.outPtr + len)\n        outBufs.push(outBuf)\n      } while (asmObj._HasMoreOutput(this.state))\n    }\n\n    if (outBufs.length === 1) {\n      return outBufs[0]\n    }\n    return concatBufs(outBufs)\n  }\n\n  private destory() {\n    ParamBr.asmMod._Destroy(this.state)\n  }\n}\n","type bundle_file_map_t = Map<string /* path */, Response>\n\nclass ParamBundle extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    if (!/^https?:|^\\//.test(conf)) {\n      return 'invalid url'\n    }\n    return [conf]\n  }\n\n  private static cacheMap = new Map<string /* pkgUrl */,\n    may_async<bundle_file_map_t>\n  >()\n\n\n  public constructor(\n    private readonly packUrl: string\n  ) {\n    super()\n  }\n\n  public async onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    if (fileLoader.cdn.isSubReq) {\n      return\n    }\n    let fileMap: bundle_file_map_t\n\n    const r = ParamBundle.cacheMap.get(this.packUrl)\n    if (r === undefined) {\n      const signal = promisex<bundle_file_map_t>()\n      ParamBundle.cacheMap.set(this.packUrl, signal)\n\n      fileMap = new Map()\n      await this.loadPkg(fileLoader, fileMap)\n\n      ParamBundle.cacheMap.set(this.packUrl, fileMap)\n      signal.resolve(fileMap)\n\n    } else if (isPromise(r)) {\n      fileMap = await r\n    } else {\n      fileMap = r\n    }\n\n    const path = fileLoader.suffix || ''\n    const res = fileMap.get(path)\n    if (res) {\n      return res.clone()\n    }\n    if (path === '') {\n      const res = fileMap.get('index.html')\n      if (res) {\n        fileLoader.suffix = 'index.html'\n        return res.clone()\n      }\n      return\n    }\n    if (path.endsWith('/')) {\n      const res = fileMap.get(path + 'index.html')\n      if (res) {\n        fileLoader.suffix = path + 'index.html'\n        return res.clone()\n      }\n      return\n    }\n    if (fileMap.has(path + '/index.html')) {\n      fileLoader.suffix = path + '/index.html'\n      return new Response(\"<script>location.pathname+='/'</script>\")\n    }\n  }\n\n  private async loadPkg(fileLoader: FileLoader, fileMap: bundle_file_map_t) {\n    type conf_t = {\n      [file: string]: {\n        [headerName: string] : string | number\n      }\n    }\n\n    // TODO: support stream\n    const cdn = new FreeCDN()\n    cdn.manifest = fileLoader.cdn.manifest\n    cdn.weightConf = fileLoader.cdn.weightConf\n    cdn.isSubReq = true\n\n    let pkgBin: Uint8Array\n    try {\n      pkgBin = await cdn.fetchBin(this.packUrl)\n    } catch {\n      this.warn('failed to load')\n      return\n    }\n\n    const pos = pkgBin.indexOf(13 /* '\\r' */)\n    if (pos === -1) {\n      this.warn('missing header')\n      return\n    }\n    const confBin = pkgBin.subarray(0, pos)\n    const confMap: conf_t = parseJson(bytesToUtf8(confBin))\n    if (!confMap) {\n      this.warn('invalid header')\n      return\n    }\n\n    const bodyBin = pkgBin.subarray(pos + 1)\n    let offset = 0\n\n    for (const [file, conf] of Object.entries(confMap)) {\n      const len = +conf['content-length']\n      if (!(len >= 0)) {\n        this.warn('invalid content-length')\n        return\n      }\n      if (offset + len > bodyBin.length) {\n        this.warn('invalid offset')\n        return\n      }\n      const fileBuf = bodyBin.subarray(offset, offset + len)\n      const res = new Response(fileBuf, {\n        headers: confMap[file] as HeadersInit\n      })\n      fileMap.set(file, res)\n\n      offset += len\n    }\n  }\n\n  private warn(msg: string) {\n    console.warn('[FreeCDN/Bundle]', msg, this.packUrl)\n  }\n}","const REG_TEXT_MIME = /^text\\/|^application\\/(?:javascript|json)|\\+xml$/\n\n\nclass ParamCharset extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf !== 'off') {\n      return [conf]\n    }\n  }\n\n\n  public constructor(\n    private readonly charset: string\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    const type = resArgs.headers.get('content-type') || ''\n    if (REG_TEXT_MIME.test(type)) {\n      resArgs.headers.set('content-type', type + '; charset=' + this.charset)\n    }\n  }\n}\n","class ParamConcat extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    const urls = splitList(conf)\n    if (urls.length === 0) {\n      return 'missing url'\n    }\n    let partLen = parseByteUnit(urls[0])\n    if (partLen > 0) {\n      urls.shift()\n    } else {\n      partLen = -1\n    }\n    for (const url of urls) {\n      if (!/^https?:|^\\//.test(url)) {\n        return 'invalid url'\n      }\n    }\n    return [partLen, urls]\n  }\n\n\n  public constructor(\n    private readonly partLen: number,\n    private readonly urls: string\n  ) {\n    super()\n  }\n\n  private abortCtrl: AbortController | undefined\n\n  public async onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    if (fileLoader.cdn.isSubReq) {\n      return\n    }\n    const manifest = fileLoader.cdn.manifest as Manifest\n    const fileInfos: {url: string, size: number}[] = []\n\n    const REG_WILDCARD = /\\[(\\d+)-(\\d+)\\]/\n\n    for (const url of this.urls) {\n      let beginNum = 0\n      let endNum = 0\n      let padNum = 0\n\n      //  [begin-end]\n      // begin  0\n      const m = url.match(REG_WILDCARD)\n      if (m) {\n        const beginStr = m[1]\n        beginNum = +beginStr\n        endNum = +m[2]\n        padNum = beginStr[0] === '0' ? beginStr.length : 0\n      }\n\n      for (let i = beginNum; i <= endNum; i++) {\n        const realUrl = m\n          ? url.replace(REG_WILDCARD, (i + '').padStart(padNum, '0'))\n          : url\n\n        const fileConf = manifest.get(realUrl)\n        if (fileConf) {\n          fileConf.parse()\n\n          //  size \n          const size = fileConf.params.get('size')\n          fileInfos.push({\n            url: fileConf.name,\n            size: size ? +size : this.partLen,\n          })\n        } else {\n          fileInfos.push({url: realUrl, size: this.partLen})\n        }\n      }\n    }\n    fileInfos.reverse()\n\n    const headers = new Headers()\n\n    //  range \n    const {rangeBegin} = fileLoader\n    if (rangeBegin && rangeBegin > 0) {\n      let pos = 0\n\n      for (let i = fileInfos.length - 1; i >= 0; i--) {\n        const {size} = fileInfos[i]\n        if (size === -1) {\n          // \n          break\n        }\n        if (pos + size > rangeBegin) {\n          //  FileLoader \n          if (pos) {\n            headers.set('content-range', `bytes ${pos}-/*`)\n          }\n          break\n        }\n        fileInfos.pop()\n        pos += size\n      }\n    }\n\n    const cdn = new FreeCDN()\n    cdn.manifest = fileLoader.cdn.manifest\n    cdn.weightConf = fileLoader.cdn.weightConf\n    cdn.isSubReq = true\n\n    let reader: ReadableStreamDefaultReader<Uint8Array>\n    let controller: ReadableStreamDefaultController<Uint8Array>\n\n    const openNextFile = async() => {\n      const info = fileInfos.pop()\n      if (!info) {\n        controller.close()\n        return false\n      }\n      this.abortCtrl = new AbortController()\n\n      let res: Response\n      try {\n        res = await cdn.fetch(info.url, {\n          signal: this.abortCtrl.signal,\n        })\n      } catch (err) {\n        controller.error(err)\n        return false\n      }\n      if (!res.body) {\n        return Error('no body')\n      }\n      reader = res.body.getReader()\n      return true\n    }\n\n    const readNextChunk = async() => {\n      let buf: Uint8Array | undefined\n      try {\n        const {value} = await reader.read()\n        buf = value\n      } catch (err) {\n        controller.error(err)\n        return\n      }\n      if (buf) {\n        controller.enqueue(buf)\n      } else {\n        if (await openNextFile()) {\n          await readNextChunk()\n        }\n      }\n    }\n\n    const stream = new ReadableStream({\n      async start(c: typeof controller) {\n        controller = c\n        await openNextFile()\n      },\n      pull: readNextChunk,\n    })\n    return new Response(stream, {headers})\n  }\n\n  public onAbort(reason: any) {\n    if (this.abortCtrl) {\n      this.abortCtrl.abort(reason)\n      this.abortCtrl = undefined\n    }\n  }\n}","class ParamData extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onRequest() {\n    return new Response(this.bytes)\n  }\n}\n","class ParamExpires extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const time = parseTime(conf)\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    const seconds = time / 1000 | 0\n    return [seconds]\n  }\n\n\n  public constructor(\n    private readonly seconds: number\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    // \n    const rawMaxAge = (rawRes as any)._maxage\n    const maxAge = rawMaxAge < this.seconds ? rawMaxAge : this.seconds\n\n    resArgs.headers.append('cache-control', 'max-age=' + maxAge)\n  }\n}\n","const enum ParamHashConf {\n  MAX_QUEUE_LEN = 64 * 1024 * 1024\n}\n\nclass ParamHash extends ParamBase {\n\n  public static parseConf(conf: string) {\n    // conf format:\n    // [blksize;]hash1,hash2,...\n    let blkLen = 1e9\n    let hashes = conf\n\n    const pos = conf.indexOf(';')\n    if (pos > 0) {\n      const blkLenStr = conf.substring(0, pos)\n      hashes = conf.substring(pos + 1)\n      blkLen = parseByteUnit(blkLenStr)\n      if (isNaN(blkLen)) {\n        return 'invalid block length'\n      }\n    }\n    const hashBins: Uint8Array[] = []\n    const hashB64s = hashes.split(',')\n\n    //  pop \n    for (let i = hashB64s.length - 1; i !== -1; i--) {\n      const bin = base64Decode(hashB64s[i])\n      if (!bin || bin.length !== LEN.SHA256_BIN) {\n        return 'invalid block hash'\n      }\n      hashBins.push(bin)\n    }\n    return [blkLen, hashBins]\n  }\n\n\n  private readonly queueArr: Uint8Array[] = []\n  private queueLen = 0\n  private hasData = false\n\n  public constructor(\n    private readonly blkLen: number,\n    private readonly hashBins: Uint8Array[]\n  ) {\n    super()\n  }\n\n  public async onData(chunk: Uint8Array) {\n    this.hasData = true\n    this.queueLen += chunk.length\n\n    if (this.queueLen > ParamHashConf.MAX_QUEUE_LEN) {\n      throw new ParamError('max queue length exceeded')\n    }\n\n    if (this.queueLen >= this.blkLen) {\n      // let queueLen be integer multiple of blkLen\n      const remain = this.queueLen % this.blkLen\n      if (remain) {\n        const head = chunk.subarray(0, -remain)\n        this.queueArr.push(head)\n        this.queueLen -= remain\n      } else {\n        this.queueArr.push(chunk)\n      }\n      const blks = await this.pull()\n      this.queueLen = remain\n\n      if (remain) {\n        const tail = chunk.subarray(-remain)\n        this.queueArr.push(tail)\n      }\n      return blks\n    }\n\n    this.queueArr.push(chunk)\n    return EMPTY_BUF\n  }\n\n  public async onEnd(chunk: Uint8Array) {\n    if (chunk.length > 0) {\n      this.queueLen += chunk.length\n      this.queueArr.push(chunk)\n    }\n    if (this.queueLen === 0) {\n      if (!this.hasData) {\n        await this.verify(EMPTY_BUF)\n      }\n      return EMPTY_BUF\n    }\n    return this.pull()\n  }\n\n  private async pull() {\n    const blks = concatBufs(this.queueArr, this.queueLen)\n    this.queueArr.length = 0\n\n    for (let p = 0; p < blks.length; p += this.blkLen) {\n      const blk = blks.subarray(p, p + this.blkLen)\n      await this.verify(blk)\n    }\n    return blks\n  }\n\n  private async verify(blk: Uint8Array) {\n    const hashExp = this.hashBins.pop()\n    if (!hashExp) {\n      throw new ParamError('missing hash')\n    }\n    const hashGot = await sha256(blk)\n\n    if (!isArrayEqual(hashExp, hashGot)) {\n      const exp = base64Encode(hashExp)\n      const got = base64Encode(hashGot)\n      throw new ParamError(`hash incorrect. expected: ${exp}, but got: ${got}`)\n    }\n  }\n}\n","class ParamHeaders extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    return ParamReqHeaders.parse(conf)\n  }\n\n\n  public constructor(\n    private readonly headers: readonly [string, string][],\n    private readonly preserveAll: boolean\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    if (this.preserveAll) {\n      for (const [k, v] of rawRes.headers) {\n        resArgs.headers.set(k, v)\n      }\n      for (const [k, v] of this.headers) {\n        resArgs.headers.set(k, v)\n      }\n      return\n    }\n\n    for (const [k, v] of this.headers) {\n      if (v === '') {\n        // preserve\n        const rawVal = rawRes.headers.get(k)\n        if (rawVal !== null) {\n          resArgs.headers.set(k, rawVal)\n        }\n      } else {\n        // add\n        resArgs.headers.set(k, v)\n      }\n    }\n  }\n}\n","class ParamOpenTimeout extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const time = parseTime(conf)\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    return [time]\n  }\n\n\n  private tid = 0\n\n\n  public constructor(\n    private readonly time: number,\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    this.tid = setTimeout(() => {\n      const delay = Math.max(this.time, 5000)\n      fileLoader.loadNextUrl(delay)\n    }, this.time)\n  }\n\n  public onResponse() {\n    this.stopTimer()\n  }\n\n  public onError() {\n    this.stopTimer()\n  }\n\n  public onAbort() {\n    this.stopTimer()\n  }\n\n  private stopTimer() {\n    if (this.tid > 0) {\n      clearTimeout(this.tid)\n      this.tid = 0\n    }\n  }\n}\n","class ParamPos extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const pos = parseByteUnit(conf)\n    if (isNaN(pos)) {\n      return 'invalid byte format'\n    }\n    if (pos === 0) {\n      return\n    }\n    return [pos]\n  }\n\n\n  public constructor(\n    private remain: number\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    if (resArgs.contentLen !== -1) {\n      if ((resArgs.contentLen -= this.remain) < 0) {\n        resArgs.contentLen = 0\n      }\n    }\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.remain <= 0) {\n      return chunk\n    }\n    const remain = (this.remain -= chunk.length)\n    if (remain >= 0) {\n      return EMPTY_BUF\n    }\n    // if remain < 0, return last -remain bytes\n    return chunk.subarray(remain)\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}","class ParamPrefix extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  private done = false\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    if (resArgs.contentLen >= 0) {\n      resArgs.contentLen += this.bytes.length\n    }\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.done) {\n      return chunk\n    }\n    this.done = true\n    return concatBufs([this.bytes, chunk])\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    // for empty file\n    return this.onData(chunk)\n  }\n}\n","class ParamRecvTimeout extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const [n, t] = conf.split('/')\n    const bytes = parseByteUnit(n)\n    const time = parseTime(t)\n    if (isNaN(bytes)) {\n      return 'invalid byte format'\n    }\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    return [bytes, time]\n  }\n\n\n  private fileLoader!: FileLoader\n  private tid = 0\n  private sum = 0\n\n  public constructor(\n    private readonly bytes: number,\n    private readonly time: number,\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    this.fileLoader = fileLoader\n  }\n\n  public onResponse() {\n    this.tid = setInterval(() => {\n      if (this.sum <= this.bytes) {\n        this.stopTimer()\n        this.fileLoader.loadNextUrl()\n      }\n      this.sum = 0\n    }, this.time)\n  }\n\n  public onData(chunk: Uint8Array) {\n    this.sum += chunk.length\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    this.stopTimer()\n    return chunk\n  }\n\n  public onError() {\n    this.stopTimer()\n  }\n\n  public onAbort() {\n    this.stopTimer()\n  }\n\n  private stopTimer() {\n    if (this.tid > 0) {\n      clearInterval(this.tid)\n      this.tid = 0\n    }\n  }\n}\n","const REG_REFFERER_POLICY = /^(?:no-referrer|unsafe-url|origin|same-origin|strict-origin|no-referrer-when-downgrade|origin-when-cross-origin|strict-origin-when-cross-origin)$/\n\n\nclass ParamReferrerPolicy extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf === 'raw') {\n      return ['']\n    }\n    if (!REG_REFFERER_POLICY.test(conf)) {\n      return 'invalid value'\n    }\n    return [conf]\n  }\n\n\n  public constructor(\n    private readonly policy: ReferrerPolicy\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    reqArgs.referrerPolicy = this.policy || fileLoader.rawReq.referrerPolicy\n  }\n}\n","class ParamReqHeaders extends ParamBase {\n  public static reuse = true\n\n  public static parse(conf: string) {\n    const headers: [string, string][] = []\n    let preserveAll = false\n\n    // {\"header-to-preserve\": \"\", \"header-to-add\": \"val\"}\n    const map = parseJson(conf)\n    if (typeof map !== 'object') {\n      return 'invalid format'\n    }\n    for (const [k, v] of Object.entries(map)) {\n      if (k === '*') {\n        preserveAll = true\n      } else {\n        headers.push([k, v + ''])\n      }\n    }\n    return [headers, preserveAll]\n  }\n\n  public static parseConf(conf: string) {\n    return this.parse(conf)\n  }\n\n\n  public constructor(\n    private readonly headers: readonly [string, string][],\n    private readonly preserveAll: boolean\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    const {rawReq} = fileLoader\n\n    if (this.preserveAll) {\n      for (const [k, v] of rawReq.headers) {\n        reqArgs.headers.set(k, v)\n      }\n      for (const [k, v] of this.headers) {\n        reqArgs.headers.set(k, v)\n      }\n      return\n    }\n\n    for (const [k, v] of this.headers) {\n      if (k === 'referer') {\n        reqArgs.referrer = v || rawReq.referrer\n        continue\n      }\n      if (v === '') {\n        // preserve\n        const rawVal = rawReq.headers.get(k)\n        if (rawVal !== null) {\n          reqArgs.headers.set(k, rawVal)\n        }\n      } else {\n        // add\n        reqArgs.headers.set(k, v)\n      }\n    }\n  }\n}\n","class ParamSize extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const size = parseByteUnit(conf)\n    if (isNaN(size)) {\n      return 'invalid byte format'\n    }\n    return [size]\n  }\n\n\n  public constructor(\n    private remain: number\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    resArgs.contentLen = this.remain\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.remain <= 0) {\n      return EMPTY_BUF\n    }\n    const remain = (this.remain -= chunk.length)\n    if (remain >= 0) {\n      return chunk\n    }\n    // remain < 0, return [0, END + remain)\n    return chunk.subarray(0, remain)\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}\n","const enum ParamStreamConf {\n  MAX_QUEUE_LEN = 64 * 1024 * 1024\n}\n\nclass ParamStream extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'on') {\n      // default\n      return\n    }\n    if (conf === 'off') {\n      return []\n    }\n    return 'invalid value'\n  }\n\n\n  private readonly queueArr: Uint8Array[] = []\n  private queueLen = 0\n\n  public constructor() {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    this.queueLen += chunk.length\n    if (this.queueLen > ParamStreamConf.MAX_QUEUE_LEN) {\n      throw new ParamError('max queue length exceeded')\n    }\n    this.queueArr.push(chunk)\n    return EMPTY_BUF\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    if (chunk.length > 0) {\n      // unlikely\n      this.onData(chunk)\n    }\n    return concatBufs(this.queueArr, this.queueLen)\n  }\n}\n","class ParamSuffix extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    if (resArgs.contentLen >= 0) {\n      resArgs.contentLen += this.bytes.length\n    }\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    if (chunk.length === 0) {\n      return this.bytes\n    }\n    return concatBufs([chunk, this.bytes])\n  }\n}\n","class ParamValidStatus extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf === '*') {\n      return\n    }\n    const codes = conf.split(',').map(Number)\n    return [codes]\n  }\n\n\n  public constructor(\n    private readonly codes: number[]\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    if (!this.codes.includes(rawRes.status)) {\n      throw new ParamError('invalid http status: ' + rawRes.status)\n    }\n  }\n}\n","class ParamXor extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const key = +conf | 0\n    if (key < 0 || key > 255) {\n      return 'invalid value'\n    }\n    return [key]\n  }\n\n\n  public constructor(\n    private readonly key: number\n  ) {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    // TODO: u32 optimize\n    for (let i = 0; i < chunk.length; i++) {\n      chunk[i] ^= this.key\n    }\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}\n","namespace CacheManager {\n  let mCache: Cache\n\n  // TODO: LRU\n\n  export async function init() {\n    if (!mCache) {\n      mCache = await caches.open('.freecdn')\n    }\n  }\n\n  export async function findHash(hash: string) {\n    const res = await findCache('/' + hash)\n    if (!res) {\n      return\n    }\n    const buf = await res.clone().arrayBuffer()\n    const bin = new Uint8Array(buf)\n    const hashGot = await sha256(bin)\n    const hashExp = base64Decode(hash)\n    if (!hashExp) {\n      return\n    }\n    if (!isArrayEqual(hashGot, hashExp)) {\n      console.warn('[FreeCDN/CacheManager] bad cache:', hash)\n      delCache('/' + hash)\n      return\n    }\n    return res\n  }\n\n  export async function addHash(hash: string, res: Response) {\n    await addCache('/' + hash, res)\n  }\n\n  export function findCache(reqInfo: RequestInfo) {\n    return mCache.match(reqInfo)\n  }\n\n  export async function addCache(reqInfo: RequestInfo, res: Response) {\n    try {\n      await mCache.put(reqInfo, res)\n    } catch {\n    }\n  }\n\n  export function delCache(reqInfo: RequestInfo) {\n    return mCache.delete(reqInfo)\n  }\n}\n","namespace Network {\n  const enum Conf {\n    DEFAULT_MAX_AGE = 300,\n  }\n\n  const mDatabase = new Database('.freecdn')\n\n  interface UrlInfo {\n    url: string,\n    status: number,\n    expire: number,\n  }\n  const mUrlInfoMap = new Map<string, UrlInfo>()\n\n  function addUrlInfo(url: string, status: number, expire: number) {\n    if (mUrlInfoMap.has(url)) {\n      return\n    }\n    const info: UrlInfo = {url, status, expire}\n    mUrlInfoMap.set(url, info)\n\n    mDatabase.put('cache', info)\n  }\n\n\n  class HostInfo {\n    public lastDoneTime = 0\n    public lastErrTime = 0\n\n    public pending = 0\n    // public protocol = 1\n\n    public errNum = 0\n    public reqNum = 0\n    public reqTimeAvg = -1\n    public reqTimeSum = 0\n    // public speedAvg = 0\n    // public speedSum = 0\n  }\n  const mHostInfoMap = new Map<string, HostInfo>()\n\n  function getHostInfo(host: string) {\n    let info = mHostInfoMap.get(host)\n    if (!info) {\n      info = new HostInfo()\n      mHostInfoMap.set(host, info)\n    }\n    return info\n  }\n\n  function getHostWeight(hostInfo: HostInfo, now: number) {\n    // TODO: ...\n    if (hostInfo.reqTimeAvg !== -1) {\n      const delayScore = 100 - hostInfo.reqTimeAvg * 0.2\n      return Math.max(delayScore, 10)\n    }\n    return 50\n  }\n\n  export function getUrlWeight(url: string, now: number, hostWeightMap: Map<string, number>) {\n    const urlInfo = mUrlInfoMap.get(url)\n    if (urlInfo && urlInfo.expire < now) {\n      if (urlInfo.status !== 200) {\n        return -2\n      }\n      //  URL \n      // expire \n      return 100 + urlInfo.expire\n    }\n\n    //  -1\n    if (url[0] === '/') {\n      return hostWeightMap.get(MY_HOST) ?? -1\n    }\n    const host = getHostFromUrl(url)\n    const hostInfo = mHostInfoMap.get(host)\n    if (!hostInfo) {\n      return hostWeightMap.get(host) ?? 50\n    }\n    return getHostWeight(hostInfo, now)\n  }\n\n  export async function fetch(req: Request) {\n    const host = getHostFromUrl(req.url)\n    const hostInfo = getHostInfo(host)\n    hostInfo.pending++\n\n    const t0 = getTimeSec()\n\n    let res: Response\n    try {\n      res = await NATIVE_FETCH(req)\n    } catch (err: any) {\n      parseFetchError(err, req, hostInfo, t0)\n      throw err\n    } finally {\n      hostInfo.pending--\n    }\n\n    const maxAge = parseMaxAge(res.headers, t0)\n\n    switch (res.status) {\n    case 200:\n      if (req.cache !== 'no-store') {\n        if (maxAge > 60) {\n          addUrlInfo(res.url, 200, t0 + maxAge)\n        }\n      }\n      break\n    case 404:\n      addUrlInfo(res.url, 404, t0 + maxAge)\n      break\n    }\n\n    //  expires \n    (res as any)._maxage = maxAge\n\n    return res\n  }\n\n  const REG_NET_ERR = /^Failed to fetch|^NetworkError|^Could not connect/\n\n  function parseFetchError(err: Error, req: Request, hostInfo: HostInfo, t0: number) {\n    if (!navigator.onLine) {\n      return\n    }\n    if (!REG_NET_ERR.test(err.message)) {\n      return\n    }\n    if (req.cache === 'only-if-cached') {\n      return\n    }\n    hostInfo.errNum++\n    hostInfo.lastErrTime = t0\n  }\n\n  function parseMaxAge(headers: Headers, t0: number) {\n    const cacheControl = headers.get('cache-control')\n    if (cacheControl !== null) {\n      if (cacheControl.includes('no-cache')) {\n        return 0\n      }\n      const m = cacheControl.match(/max-age=\"?(\\d+)\"?/)\n      if (m) {\n        return +m[1]\n      }\n    }\n    const expires = headers.get('expires')\n    if (expires !== null) {\n      const t1 = Date.parse(expires) / 1000\n      if (t1) {\n        return (t1 - t0) | 0\n      }\n    }\n    return Conf.DEFAULT_MAX_AGE\n  }\n\n\n  function parseEntries(list: PerformanceEntryList) {\n    const timeBase = performance.timeOrigin\n\n    for (const record of list as PerformanceResourceTiming[]) {\n      const host = getHostFromUrl(record.name)\n      const info = getHostInfo(host)\n\n      info.reqNum++\n      info.lastDoneTime = timeBase + record.responseEnd\n\n      // time-allow-origin\n      if (record.responseStart > 0) {\n        const reqTime = record.responseStart - record.requestStart\n        info.reqTimeSum += reqTime\n        info.reqTimeAvg = info.reqTimeSum / info.reqNum\n      }\n    }\n  }\n\n\n  export async function init() {\n    await mDatabase.open({\n      'cache': {\n        keyPath: 'url'\n      },\n    })\n\n    const now = getTimeSec()\n\n    //  URL \n    await mDatabase.enum('cache', (item: UrlInfo) => {\n      if (item.expire < now) {\n        mDatabase.delete('cache', item.url)\n        return\n      }\n      mUrlInfoMap.set(item.url, item)\n    })\n\n    //  URL \n    const entries = performance.getEntriesByType('resource')\n    parseEntries(entries)\n\n    const observer = new PerformanceObserver(entryList => {\n      const entries = entryList.getEntries()\n      parseEntries(entries)\n    })\n    observer.observe({\n      entryTypes: ['resource']\n    })\n  }\n\n\n  export function parseWeightConf(manifest: Manifest) {\n    const zone = navigator.language.toLowerCase()\n    const zone0 = zone.split('-')[0]\n    const weightParams =\n      manifest.getParams('@weight ' + zone) ||\n      manifest.getParams('@weight ' + zone0) ||\n      manifest.getParams('@weight')\n\n    if (!weightParams) {\n      const obj = ZONE_HOST_SCORE[zone] || ZONE_HOST_SCORE['*']\n      return new Map(Object.entries(obj))\n    }\n\n    const map = new Map<string, number>()\n    for (const [k, v] of weightParams) {\n      const num = +v\n      if (isNaN(num)) {\n        continue\n      }\n      map.set(k, num)\n    }\n    return map\n  }\n}\n","class ParamMime extends ParamBase {\n  public static reuse = true\n\n  private static extTypeMap: ReadonlyMap<string, string>\n  static {\n    const map = new Map<string, string>()\n\n    for (const item of MIME_DATA.split(';')) {\n      const [mime, exts] = getPair(item, ':') as string[]\n\n      for (const ext of exts.split(',')) {\n        map.set(ext, mime)\n      }\n    }\n    this.extTypeMap = map\n  }\n\n  public static parseConf(conf: string) {\n    if (conf === 'auto') {\n      // likely\n      return ['']\n    }\n    return [conf]\n  }\n\n\n  public constructor(\n    private readonly mime: string\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    let type: string | undefined\n\n    if (this.mime === '') {\n      const url = fileLoader.getSourceUrl()\n      if (!url.includes('?')) {\n        const m = url.match(/\\.(\\w+)$/)\n        if (m) {\n          const ext = m[1].toLowerCase()\n          type = ParamMime.extTypeMap.get(ext)\n        }\n      }\n      if (!type) {\n        const rawType = rawRes.headers.get('content-type')\n        if (rawType) {\n          type = getPair(rawType, ';')[0]\n        } else {\n          type = 'application/octet-stream'\n        }\n      }\n    } else {\n      type = this.mime\n    }\n    resArgs.headers.set('content-type', type)\n  }\n}\n","const MIME_DATA = 'application/andrew-inset:ez;application/applixware:aw;application/atom+xml:atom;application/atomcat+xml:atomcat;application/atomdeleted+xml:atomdeleted;application/atomsvc+xml:atomsvc;application/atsc-dwd+xml:dwd;application/atsc-held+xml:held;application/atsc-rsat+xml:rsat;application/bdoc:bdoc;application/calendar+xml:xcs;application/ccxml+xml:ccxml;application/cdfx+xml:cdfx;application/cdmi-capability:cdmia;application/cdmi-container:cdmic;application/cdmi-domain:cdmid;application/cdmi-object:cdmio;application/cdmi-queue:cdmiq;application/cu-seeme:cu;application/dash+xml:mpd;application/davmount+xml:davmount;application/docbook+xml:dbk;application/dssc+der:dssc;application/dssc+xml:xdssc;application/ecmascript:ecma,es;application/emma+xml:emma;application/emotionml+xml:emotionml;application/epub+zip:epub;application/exi:exi;application/fdt+xml:fdt;application/font-tdpfr:pfr;application/geo+json:geojson;application/gml+xml:gml;application/gpx+xml:gpx;application/gxf:gxf;application/gzip:gz;application/hjson:hjson;application/hyperstudio:stk;application/inkml+xml:ink,inkml;application/ipfix:ipfix;application/its+xml:its;application/java-archive:jar,war,ear;application/java-serialized-object:ser;application/java-vm:class;application/javascript:js,mjs;application/json:json,map;application/json5:json5;application/jsonml+json:jsonml;application/ld+json:jsonld;application/lgr+xml:lgr;application/lost+xml:lostxml;application/mac-binhex40:hqx;application/mac-compactpro:cpt;application/mads+xml:mads;application/manifest+json:webmanifest;application/marc:mrc;application/marcxml+xml:mrcx;application/mathematica:ma,nb,mb;application/mathml+xml:mathml;application/mbox:mbox;application/mediaservercontrol+xml:mscml;application/metalink+xml:metalink;application/metalink4+xml:meta4;application/mets+xml:mets;application/mmt-aei+xml:maei;application/mmt-usd+xml:musd;application/mods+xml:mods;application/mp21:m21,mp21;application/mp4:mp4s,m4p;application/mrb-consumer+xml:xdf;application/mrb-publish+xml:xdf;application/msword:doc,dot;application/mxf:mxf;application/n-quads:nq;application/n-triples:nt;application/node:cjs;application/octet-stream:bin,dms,lrf,mar,so,dist,distz,pkg,bpk,dump,elc,deploy,exe,dll,deb,dmg,iso,img,msi,msp,msm,buffer;application/oda:oda;application/oebps-package+xml:opf;application/ogg:ogx;application/omdoc+xml:omdoc;application/onenote:onetoc,onetoc2,onetmp,onepkg;application/oxps:oxps;application/p2p-overlay+xml:relo;application/patch-ops-error+xml:xer;application/pdf:pdf;application/pgp-encrypted:pgp;application/pgp-signature:asc,sig;application/pics-rules:prf;application/pkcs10:p10;application/pkcs7-mime:p7m,p7c;application/pkcs7-signature:p7s;application/pkcs8:p8;application/pkix-attr-cert:ac;application/pkix-cert:cer;application/pkix-crl:crl;application/pkix-pkipath:pkipath;application/pkixcmp:pki;application/pls+xml:pls;application/postscript:ai,eps,ps;application/provenance+xml:provx;application/pskc+xml:pskcxml;application/raml+yaml:raml;application/rdf+xml:rdf,owl;application/reginfo+xml:rif;application/relax-ng-compact-syntax:rnc;application/resource-lists+xml:rl;application/resource-lists-diff+xml:rld;application/rls-services+xml:rs;application/route-apd+xml:rapd;application/route-s-tsid+xml:sls;application/route-usd+xml:rusd;application/rpki-ghostbusters:gbr;application/rpki-manifest:mft;application/rpki-roa:roa;application/rsd+xml:rsd;application/rss+xml:rss;application/rtf:rtf;application/sbml+xml:sbml;application/scvp-cv-request:scq;application/scvp-cv-response:scs;application/scvp-vp-request:spq;application/scvp-vp-response:spp;application/sdp:sdp;application/senml+xml:senmlx;application/sensml+xml:sensmlx;application/set-payment-initiation:setpay;application/set-registration-initiation:setreg;application/shf+xml:shf;application/sieve:siv,sieve;application/smil+xml:smi,smil;application/sparql-query:rq;application/sparql-results+xml:srx;application/srgs:gram;application/srgs+xml:grxml;application/sru+xml:sru;application/ssdl+xml:ssdl;application/ssml+xml:ssml;application/swid+xml:swidtag;application/tei+xml:tei,teicorpus;application/thraud+xml:tfi;application/timestamped-data:tsd;application/toml:toml;application/ttml+xml:ttml;application/ubjson:ubj;application/urc-ressheet+xml:rsheet;application/urc-targetdesc+xml:td;application/voicexml+xml:vxml;application/wasm:wasm;application/widget:wgt;application/winhlp:hlp;application/wsdl+xml:wsdl;application/wspolicy+xml:wspolicy;application/xaml+xml:xaml;application/xcap-att+xml:xav;application/xcap-caps+xml:xca;application/xcap-diff+xml:xdf;application/xcap-el+xml:xel;application/xcap-error+xml:xer;application/xcap-ns+xml:xns;application/xenc+xml:xenc;application/xhtml+xml:xhtml,xht;application/xliff+xml:xlf;application/xml:xml,xsl,xsd,rng;application/xml-dtd:dtd;application/xop+xml:xop;application/xproc+xml:xpl;application/xslt+xml:xsl,xslt;application/xspf+xml:xspf;application/xv+xml:mxml,xhvml,xvml,xvm;application/yang:yang;application/yin+xml:yin;application/zip:zip;audio/3gpp:3gpp;audio/adpcm:adp;audio/amr:amr;audio/basic:au,snd;audio/midi:mid,midi,kar,rmi;audio/mobile-xmf:mxmf;audio/mp3:mp3;audio/mp4:m4a,mp4a;audio/mpeg:mpga,mp2,mp2a,mp3,m2a,m3a;audio/ogg:oga,ogg,spx,opus;audio/s3m:s3m;audio/silk:sil;audio/wav:wav;audio/wave:wav;audio/webm:weba;audio/xm:xm;font/collection:ttc;font/otf:otf;font/ttf:ttf;font/woff:woff;font/woff2:woff2;image/aces:exr;image/apng:apng;image/avif:avif;image/bmp:bmp;image/cgm:cgm;image/dicom-rle:drle;image/emf:emf;image/fits:fits;image/g3fax:g3;image/gif:gif;image/heic:heic;image/heic-sequence:heics;image/heif:heif;image/heif-sequence:heifs;image/hej2k:hej2;image/hsj2:hsj2;image/ief:ief;image/jls:jls;image/jp2:jp2,jpg2;image/jpeg:jpeg,jpg,jpe;image/jph:jph;image/jphc:jhc;image/jpm:jpm;image/jpx:jpx,jpf;image/jxr:jxr;image/jxra:jxra;image/jxrs:jxrs;image/jxs:jxs;image/jxsc:jxsc;image/jxsi:jxsi;image/jxss:jxss;image/ktx:ktx;image/ktx2:ktx2;image/png:png;image/sgi:sgi;image/svg+xml:svg,svgz;image/t38:t38;image/tiff:tif,tiff;image/tiff-fx:tfx;image/webp:webp;image/wmf:wmf;message/disposition-notification:disposition-notification;message/global:u8msg;message/global-delivery-status:u8dsn;message/global-disposition-notification:u8mdn;message/global-headers:u8hdr;message/rfc822:eml,mime;model/3mf:3mf;model/gltf+json:gltf;model/gltf-binary:glb;model/iges:igs,iges;model/mesh:msh,mesh,silo;model/mtl:mtl;model/obj:obj;model/stl:stl;model/vrml:wrl,vrml;model/x3d+binary:x3db,x3dbz;model/x3d+fastinfoset:x3db;model/x3d+vrml:x3dv,x3dvz;model/x3d+xml:x3d,x3dz;model/x3d-vrml:x3dv;text/cache-manifest:appcache,manifest;text/calendar:ics,ifb;text/coffeescript:coffee,litcoffee;text/css:css;text/csv:csv;text/html:html,htm,shtml;text/jade:jade;text/jsx:jsx;text/less:less;text/markdown:markdown,md;text/mathml:mml;text/mdx:mdx;text/n3:n3;text/plain:txt,text,conf,def,list,log,in,ini;text/richtext:rtx;text/rtf:rtf;text/sgml:sgml,sgm;text/shex:shex;text/slim:slim,slm;text/spdx:spdx;text/stylus:stylus,styl;text/tab-separated-values:tsv;text/troff:t,tr,roff,man,me,ms;text/turtle:ttl;text/uri-list:uri,uris,urls;text/vcard:vcard;text/vtt:vtt;text/xml:xml;text/yaml:yaml,yml;video/3gpp:3gp,3gpp;video/3gpp2:3g2;video/h261:h261;video/h263:h263;video/h264:h264;video/iso.segment:m4s;video/jpeg:jpgv;video/jpm:jpm,jpgm;video/mj2:mj2,mjp2;video/mp2t:ts;video/mp4:mp4,mp4v,mpg4;video/mpeg:mpeg,mpg,mpe,m1v,m2v;video/ogg:ogv;video/quicktime:qt,mov;video/webm:webm'\n","class Database {\n  private db!: IDBDatabase\n\n\n  public constructor(\n    private readonly name: string\n  ) {\n  }\n\n  public open(opts: {\n    [table: string] : IDBObjectStoreParameters\n  }) {\n    const s = promisex()\n    const req = indexedDB.open(this.name)\n\n    req.onsuccess = () => {\n      const idb = req.result\n      this.db = idb\n\n      idb.onclose = () => {\n        console.warn('[FreeCDN/Database] indexedDB disconnected, reopen...')\n        this.open(opts)\n      }\n      s.resolve()\n    }\n    req.onerror = (e) => {\n      console.warn('[FreeCDN/Database] indexedDB open error:', e)\n      s.reject(req.error)\n    }\n    req.onupgradeneeded = () => {\n      const idb = req.result\n      for (const [k, v] of Object.entries(opts)) {\n        idb.createObjectStore(k, v)\n      }\n    }\n    return s\n  }\n\n  public close() {\n    this.db.close()\n  }\n\n  public get(table: string, key: any) {\n    const s = promisex<any>()\n    const obj = this.getStore(table, 'readonly')\n    const req = obj.get(key)\n\n    req.onsuccess = () => {\n      s.resolve(req.result)\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public put(table: string, record: any) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readwrite')\n    const req = obj.put(record)\n\n    req.onsuccess = () => {\n      s.resolve()\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public delete(table: string, key: any) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readwrite')\n    const req = obj.delete(key)\n\n    req.onsuccess = () => {\n      s.resolve()\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public enum(\n    table: string,\n    callback: (result: any) => boolean | void,\n    ...args: Parameters<typeof IDBObjectStore.prototype.openCursor>\n  ) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readonly')\n    const req = obj.openCursor(...args)\n\n    req.onsuccess = () => {\n      const {result} = req\n      if (!result) {\n        s.resolve()\n        return\n      }\n      const ret = callback(result.value)\n      if (ret !== false) {\n        result.continue()\n      }\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  private getStore(table: string, mode: IDBTransactionMode) {\n    return this.db\n      .transaction(table, mode)\n      .objectStore(table)\n  }\n}\n","const TEXT_ENCODER = new TextEncoder()\nconst TEXT_DECODER = new TextDecoder()\n\nfunction utf8ToBytes(str: string) : Uint8Array {\n  return TEXT_ENCODER.encode(str)\n}\n\nfunction bytesToUtf8(bytes: Uint8Array) : string {\n  return TEXT_DECODER.decode(bytes)\n}\n\nfunction bytesToAsc(bytes: Uint8Array) : string {\n  return bytes.reduce((s, v) => s + String.fromCharCode(v), '')\n}\n\nfunction base64Encode(bytes: Uint8Array) : string {\n  return btoa(bytesToAsc(bytes))\n}\n\nfunction base64Decode(str: string) : Uint8Array | undefined {\n  try {\n    str = atob(str)\n  } catch {\n    return\n  }\n  const bin = new Uint8Array(str.length)\n  for (let i = 0; i < bin.length; i++) {\n    bin[i] = str.charCodeAt(i)\n  }\n  return bin\n}\n\nfunction parseJson(str: string) {\n  try {\n    return JSON.parse(str)\n  } catch {\n  }\n}\n\nfunction splitList(str: string) : string[] {\n  str = str.trim()\n  if (!str) {\n    return []\n  }\n  return str.split(/\\s+/)\n}\n\nfunction parseStrOrB64(str: string) : Uint8Array | undefined {\n  // json string\n  if (str[0] === '\"') {\n    str = parseJson(str)\n    if (str === undefined) {\n      return\n    }\n    return utf8ToBytes(str)\n  }\n  // base64\n  return base64Decode(str)\n}\n\nconst TIME_UNIT: {[key: string] : number} = {\n  ''   : 1,\n  'ms' : 1,\n  's'  : 1000,\n  'min': 1000 * 60,\n  'h'  : 1000 * 3600,\n  'd'  : 1000 * 3600 * 24,\n  'y'  : 1000 * 3600 * 24 * 365,\n}\n\nfunction parseTime(str: string) : number {\n  const m = str.match(/^([\\d.]{1,9})(y|d|h|min|s|ms|)$/)\n  if (!m) {\n    return NaN\n  }\n  const [, num, unit] = m\n  return +num * TIME_UNIT[unit]\n}\n\nfunction parseByteUnit(str: string) : number {\n  const m = str.match(/^([\\d.]{1,9})(k|K|M|G|)(i|)(b|B|)$/)\n  if (!m) {\n    return NaN\n  }\n  const [, num, kMG, i, bB] = m\n  const exponent =\n    kMG === 'k' ? 1 :\n    kMG === 'K' ? 1 :\n    kMG === 'M' ? 2 :\n    kMG === 'G' ? 3 : 0\n\n  const base = i ? 1024 : 1000\n  const unit = bB === 'b' ? 8 : 1\n  return +num * base ** exponent / unit\n}\n\nfunction getTimeSec() : number {\n  return Date.now() / 1000 | 0\n}\n\nfunction concatBufs(bufs: Uint8Array[], size = 0) : Uint8Array {\n  if (size === 0) {\n    for (const v of bufs) {\n      size += v.length\n    }\n  }\n  const ret = new Uint8Array(size)\n  let pos = 0\n  for (const v of bufs) {\n    ret.set(v, pos)\n    pos += v.length\n  }\n  return ret\n}\n\n\nfunction isArrayEqual<T>(b1: ArrayLike<T>, b2: ArrayLike<T>) : boolean {\n  if (b1.length !== b2.length) {\n    return false\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n\nfunction getPair(str: string, delim: string) : [string, string?] {\n  const pos = str.indexOf(delim)\n  if (pos === -1) {\n    return [str]\n  }\n  return [\n    str.substring(0, pos),\n    str.substring(pos + delim.length)\n  ]\n}\n\nfunction mergeMap<K, V>(dst: Map<K, V>, src: Iterable<[K, V]>) : void {\n  for (const [k, v] of src) {\n    dst.set(k, v)\n  }\n}\n\n/**\n * @param url absolute or relative url\n */\nfunction stripUrlQuery(url: string) : string {\n  const pos = url.indexOf('?')\n  if (pos === -1) {\n    return url\n  }\n  return url.substring(0, pos)\n}\n\n/**\n * @param url absolute url\n */\nfunction getHostFromUrl(url: string) : string {\n  const m = url.match(/^https?:\\/\\/([^/]+)/) as string[]\n  return m[1]\n}\n\n/**\n * @param url absolute or relative url\n */\nfunction toRelUrl(url: string) : string {\n  if (url.startsWith(ROOT_PATH)) {\n    return url.substring(MY_ORIGIN.length)\n  }\n  return url\n}\n\nasync function sha256(buf: Uint8Array) : Promise<Uint8Array> {\n  const ret = await CRYPTO.digest('SHA-256', buf)\n  return new Uint8Array(ret)\n}\n","const ZONE_HOST_SCORE: {\n  [zone: string]: {\n    [host: string]: number\n  }\n} = {\n  'zh-cn': {\n    'ajax.cdnjs.com': 50,\n    'cdnjs.cloudflare.com': 50,\n    'cdn.jsdelivr.net': 80,\n    'raw.githubusercontent.com': 10,\n    'cdnjs.loli.net': 70,\n    'lib.baomitu.com': 80,\n    'lf6-cdn-tos.bytecdntp.com': 90,\n    'cdn.staticfile.org': 90,\n    'cdn.bootcss.com': 10,\n    'cdn.bootcdn.net': 80,\n    'unpkg.com': 50,\n    'g.alicdn.com': 90,\n    'pagecdn.io': 20,\n    'ajax.aspnetcdn.com': 60,\n    'ajax.googleapis.com': 10,\n    'code.jquery.com': 20,\n    'stackpath.bootstrapcdn.com': 30,\n    'maxcdn.bootstrapcdn.com': 30,\n    'cdn.datatables.net': 40,\n    'twemoji.maxcdn.com': 40,\n  },\n  '*': {\n    'ajax.cdnjs.com': 90,\n    'cdnjs.cloudflare.com': 90,\n    'cdn.jsdelivr.net': 40,\n    'raw.githubusercontent.com': 10,\n    'cdnjs.loli.net': 40,\n    'lib.baomitu.com': 20,\n    'lf6-cdn-tos.bytecdntp.com': 40,\n    'cdn.staticfile.org': 20,\n    'cdn.bootcss.com': 10,\n    'cdn.bootcdn.net': 20,\n    'unpkg.com': 40,\n    'g.alicdn.com': 30,\n    'pagecdn.io': 40,\n    'ajax.aspnetcdn.com': 70,\n    'ajax.googleapis.com': 90,\n    'code.jquery.com': 50,\n    'stackpath.bootstrapcdn.com': 40,\n    'maxcdn.bootstrapcdn.com': 50,\n    'cdn.datatables.net': 50,\n    'twemoji.maxcdn.com': 50,\n  },\n}"]}