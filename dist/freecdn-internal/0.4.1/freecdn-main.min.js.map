{"version":3,"sources":["freecdn-main.js","main-js/src/hook.ts","core-lib/src/global.ts","core-lib/src/param-base.ts","core-lib/src/key-manager.ts","core-lib/src/manifest.ts","core-lib/src/url-conf.ts","core-lib/src/url-loader.ts","core-lib/src/file-conf.ts","core-lib/src/file-loader.ts","core-lib/src/updater.ts","core-lib/src/freecdn.ts","core-lib/src/promisex.ts","main-js/src/sw.ts","core-lib/src/param-mods/br.ts","core-lib/src/param-mods/bundle.ts","core-lib/src/param-mods/charset.ts","core-lib/src/param-mods/concat.ts","core-lib/src/param-mods/data.ts","core-lib/src/param-mods/expires.ts","core-lib/src/param-mods/hash.ts","core-lib/src/param-mods/headers.ts","core-lib/src/param-mods/open-timeout.ts","core-lib/src/param-mods/pos.ts","core-lib/src/param-mods/prefix.ts","core-lib/src/param-mods/recv-timeout.ts","core-lib/src/param-mods/referrer-policy.ts","core-lib/src/param-mods/req-headers.ts","core-lib/src/param-mods/size.ts","core-lib/src/param-mods/stream.ts","core-lib/src/param-mods/suffix.ts","core-lib/src/param-mods/valid-status.ts","core-lib/src/param-mods/xor.ts","core-lib/src/cache-manager.ts","core-lib/src/network.ts","core-lib/src/param-mods/mime/mime.ts","core-lib/src/param-mods/mime/mime-data.ts","core-lib/src/database.ts","core-lib/src/reader.ts","core-lib/src/util.ts","core-lib/src/zone-host.ts"],"names":["Hook","func","obj","key","factory","oldFn","newFn","prop","getterFactory","setterFactory","desc","Object","getOwnPropertyDescriptor","defineProperty","MY_URL","location","href","MY_HOST","host","MY_ORIGIN","origin","ROOT_PATH","INTERNAL_PATH","URL","pathname","REG_IMG_EXTS","NATIVE_FETCH","fetch","EMPTY_BUF","Uint8Array","CRYPTO","crypto","subtle","gInited","ParamError","Error","constructor","message","super","ParamBase","onRequest","reqArgs","fileLoader","onResponse","resArgs","rawRes","onData","chunk","onEnd","onError","error","onAbort","reason","KeyManager","mKey","set","async","keyBase64","keyBin","base64Decode","importKey","name","namedCurve","verify","data","linePos","lastIndexOf","m","bytesToUtf8","subarray","match","signBin","dataBin","hash","REG_HEAD_LINE","Manifest","this","urlFileMap","Map","has","get","getParams","fileConf","parse","params","txt","parseFile","inc","cdn","FreeCDN","manifest","rets","getLines","map","fetchText","Promise","all","forEach","last","exec","toRelUrl","curr","index","length","part","substring","conf","FileConf","lastIndex","m0","m1","globalParams","UrlConf","url","fileParams","frag","getPair","static","nameClassMap","ParamData","bundle","ParamBundle","concat","ParamConcat","open_timeout","ParamOpenTimeout","recv_timeout","ParamRecvTimeout","referrer_policy","ParamReferrerPolicy","req_headers","ParamReqHeaders","valid_status","ParamValidStatus","headers","ParamHeaders","expires","ParamExpires","mime","ParamMime","charset","ParamCharset","pos","ParamPos","size","ParamSize","xor","ParamXor","br","ParamBr","prefix","ParamPrefix","suffix","ParamSuffix","ParamHash","stream","ParamStream","values","cls","i","priority","mergeMap","getHostFromUrl","hostParams","URLSearchParams","mods","k","v","console","warn","ret","parseConf","undefined","push","sort","a","b","UrlLoader","paramMods","isFetchDone","bytesRead","err","isNetErr","loadUnsafe","e","abortCtrl","signal","aborted","mod","abort","rawReq","method","referrer","referrerPolicy","Headers","res","body","clone","arrayBuffer","isPromise","AbortController","req","Request","Network","status","statusText","contentLen","contentRange","rangeBegin","reader","getReader","buf","READ","value","read","pauseSignal","pause","promisex","resume","resolve","REG_SUB_LINE","text","lines","urlConfs","line","test","urlConf","val","FILE_BACKUP_PARAMS","FileLoaderError","FileLoader","range","urlLoaderSet","Set","isPaused","isAborted","delayTid","urlErrs","hasRange","opened","closed","r","parseReqRange","rangeEnd","fileSize","vUrlConf","backupParams","backupUrlConf","begin","end","buildResRange","len","open","loadNextUrl","urlLoader","clearTimeout","getNextUrl","weight","now","getTimeSec","w","getUrlWeight","weightConf","delay","getSourceUrl","setTimeout","createUrlLoader","getTargetUrl","endsWith","add","exceed","delete","onOpen","load","EMPTY_PARAMS","Updater","manifestPath","onAvailable","urlWsMap","wsArgs","manifestHash","pollingTimer","pollingInterval","lastTime","setSvcTimer","backupUrls","assert","path","search","encodeURIComponent","manifestUrl","CacheManager","findCache","bin","getManifestFromCache","update","updateSignal","Date","updateUnsafe","fetchManifest","applyManifest","ctl","tid","cache","bytes","sha256","isArrayEqual","Response","addCache","applyConfs","parseBackupParam","interval","parseIntervalParam","setPollingInterval","svcUrls","parseServicesParam","setServices","splitList","str","num","parseTime","isNaN","clearInterval","setInterval","urls","ws","includes","onclose","close","createSvc","WebSocket","binaryType","onmessage","hashBin","enableCacheStorage","isSubReq","inited","updater","updateConf","parseWeightConf","input","init","FIND","urlObj","originPrefix","replace","file","mode","integrity","accept","redirect","dir","fileHash","hashParam","cacheable","findHash","promiseObj","addEventListener","resBody","args","cacheRes","addHash","reject","controller","checkPressure","desiredSize","ReadableStream","start","c","pull","cancel","enqueue","type","Blob","keyB64","globalInit","p","then","Sw","GLOBAL","self","mLoaderJsRes","mFreeCDN","mIniting","mResUrlMap","sharedModeHandler","loaderModeHandler","request","result","isSharedMode","FREECDN_SHARED_MODE","publicKey","Cache","prototype","put","reqs","tasks","WeakMap","getter","call","FREECDN_PUBLIC_KEY","Q","shift","setPublicKey","splice","loaderModeInit","log","main","state","BR_WASM_PATH","BR_GLUE_PATH","BR_MANIFEST","hasErr","timer","asmMod","locateFile","onRuntimeInitialized","inPtr","_AllocInBuf","outPtr","_AllocOutBuf","print","msg","printErr","onFetch","js","Function","fn","waitWasm","process","destory","asmObj","HEAPU8","_Init","outBufs","inBuf","availIn","availOut","_Update","_GetErrorCode","_GetAvailableIn","_GetAvailableOut","outBuf","slice","_HasMoreOutput","concatBufs","_Destroy","packUrl","fileMap","loadPkg","catch","bind","ReaderError","fileMapSignal","Reader","source","delimPos","findAsync","confMap","parseJson","readBytesAsync","keys","entries","fileLen","fileBuf","REG_TEXT_MIME","reuse","partLen","parseByteUnit","fileInfos","REG_WILDCARD","beginNum","endNum","padNum","beginStr","realUrl","padStart","reverse","pop","openNextFile","info","readNextChunk","parseStrOrB64","seconds","time","rawMaxAge","_maxage","maxAge","append","blkLen","hashBins","hasData","hashes","indexOf","blkLenStr","hashB64s","split","feed","availLen","remain","blks","readBytesSync","blk","hashExp","hashGot","exp","base64Encode","got","preserveAll","rawVal","Math","max","stopTimer","done","sum","n","t","REG_REFFERER_POLICY","policy","queueArr","queueLen","codes","Number","_a","ext","toLowerCase","extTypeMap","rawType","item","exts","mCache","reqInfo","delCache","caches","Database","opts","s","indexedDB","onsuccess","idb","db","onerror","onupgradeneeded","createObjectStore","table","getStore","record","enum","callback","openCursor","continue","transaction","objectStore","mDatabase","mUrlInfoMap","addUrlInfo","expire","HostInfo","lastDoneTime","lastErrTime","pending","errNum","reqNum","reqTimeAvg","reqTimeSum","mHostInfoMap","getHostInfo","hostWeightMap","urlInfo","hostInfo","delayScore","getHostWeight","t0","navigator","onLine","REG_NET_ERR","parseFetchError","cacheControl","t1","parseMaxAge","parseEntries","list","timeBase","performance","timeOrigin","responseEnd","responseStart","reqTime","requestStart","keyPath","getEntriesByType","PerformanceObserver","entryList","getEntries","observe","entryTypes","zone","language","zone0","weightParams","ZONE_HOST_SCORE","chunks","offset","head","readU32Sync","readU16Sync","readU8Sync","byte","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","decode","btoa","reduce","String","fromCharCode","bytesToAsc","atob","charCodeAt","JSON","trim","encode","utf8ToBytes","TIME_UNIT","ms","min","h","d","y","NaN","unit","kMG","bB","bufs","b1","b2","delim","dst","src","startsWith","digest"],"mappings":"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","file":"freecdn-main.min.js","sourcesContent":["\"use strict\";\n/**\n * JS Hook Util\n * example: https://codepen.io/etherdream/pen/WNoQQbG?editors=0012\n */\nvar Hook;\n(function (Hook) {\n    /**\n     * hook function\n     */\n    function func(obj, key, factory) {\n        const oldFn = obj[key];\n        if (!oldFn) {\n            return false;\n        }\n        const newFn = factory(oldFn);\n        obj[key] = newFn;\n        return true;\n    }\n    Hook.func = func;\n    /**\n     * hook property\n     */\n    function prop(obj, key, getterFactory, setterFactory) {\n        const desc = Object.getOwnPropertyDescriptor(obj, key);\n        if (!desc) {\n            return false;\n        }\n        if (getterFactory) {\n            func(desc, 'get', getterFactory);\n        }\n        if (setterFactory) {\n            func(desc, 'set', setterFactory);\n        }\n        Object.defineProperty(obj, key, desc);\n        return true;\n    }\n    Hook.prop = prop;\n})(Hook || (Hook = {}));\nconst IS_DEBUG = typeof RELEASE === 'undefined';\nconst DEFAULT_PARAMS = `\n@__default__\n expires=30s\n mime=auto\n open_timeout=10s\n valid_status=200\n`;\nconst DEFAULT_MANIFEST_PATH = '/freecdn-internal/freecdn-manifest.txt';\nconst MY_URL = location.href;\nconst MY_HOST = location.host;\nconst MY_ORIGIN = location.origin;\nconst ROOT_PATH = MY_ORIGIN + '/';\nconst INTERNAL_DIR = 'freecdn-internal/' + (IS_DEBUG ? 'dev' : VER);\nconst INTERNAL_PATH = new URL(INTERNAL_DIR, ROOT_PATH).pathname;\nconst REG_IMG_EXTS = /\\.(?:jpg|jpeg|png|apng|gif|ico|bmp)$/i;\nconst NATIVE_FETCH = fetch;\nconst EMPTY_BUF = new Uint8Array(0);\nconst CRYPTO = crypto.subtle;\nlet gInited;\nasync function globalInit() {\n    if (gInited) {\n        return gInited;\n    }\n    gInited = promisex();\n    await CacheManager.init();\n    await Network.init();\n    UrlConf.init();\n    gInited.resolve();\n    gInited = true;\n}\nclass ParamError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass ParamBase {\n    onRequest(reqArgs, fileLoader) {\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n    }\n    onData(chunk) {\n        return chunk;\n    }\n    onEnd(chunk) {\n        return chunk;\n    }\n    onError(error) {\n    }\n    onAbort(reason) {\n    }\n}\nvar KeyManager;\n(function (KeyManager) {\n    let mKey;\n    async function set(keyBase64) {\n        const keyBin = base64Decode(keyBase64);\n        if (!keyBin) {\n            return;\n        }\n        mKey = await CRYPTO.importKey('spki', keyBin, {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, false, ['verify']);\n    }\n    KeyManager.set = set;\n    async function verify(data) {\n        if (!mKey) {\n            return false;\n        }\n        const linePos = data.lastIndexOf(10); // 10 = '\\n'\n        const lineBin = data.subarray(linePos + 1);\n        const lineTxt = bytesToUtf8(lineBin);\n        const m = lineTxt.match(/# SIGN: ([A-Za-z0-9+/=]{88})$/);\n        if (!m) {\n            return false;\n        }\n        const signTxt = m[1];\n        const signBin = base64Decode(signTxt);\n        const dataBin = data.subarray(0, linePos);\n        return await CRYPTO.verify({\n            name: 'ECDSA',\n            hash: {\n                name: 'SHA-256'\n            },\n        }, mKey, signBin, dataBin);\n    }\n    KeyManager.verify = verify;\n})(KeyManager || (KeyManager = {}));\n//\n// 匹配清单中的文件块。例如：\n//\n// (http://foo/path/to/file)\n//    ...\n// (/path/to/file)\n//    ...\n// (@config)\n//    ...\n// 其中 $0 为文件名，内容部分只匹配不捕获，之后通过 lastIndex 截取\n//\nconst REG_HEAD_LINE = /^(?:\\/|https?:|@).*/mg;\nclass Manifest {\n    constructor() {\n        this.urlFileMap = new Map();\n    }\n    has(key) {\n        return this.urlFileMap.has(key);\n    }\n    get(key) {\n        return this.urlFileMap.get(key);\n    }\n    getParams(name) {\n        const fileConf = this.get(name);\n        if (fileConf) {\n            fileConf.parse();\n            return fileConf.params;\n        }\n    }\n    async parse(txt) {\n        this.parseFile(txt + DEFAULT_PARAMS);\n        const inc = this.urlFileMap.get('@include');\n        if (inc) {\n            const cdn = new FreeCDN();\n            cdn.manifest = this;\n            const urls = inc.getLines();\n            const rets = urls.map(cdn.fetchText, cdn);\n            const txts = await Promise.all(rets);\n            txts.forEach(this.parseFile, this);\n        }\n    }\n    parseFile(txt) {\n        // lazy parse\n        let name = '';\n        let last = 0;\n        for (;;) {\n            const m = REG_HEAD_LINE.exec(txt);\n            if (last > 0) {\n                if (name[0] !== '@') {\n                    name = toRelUrl(name);\n                }\n                const curr = m ? m.index : txt.length;\n                const part = txt.substring(last, curr);\n                const conf = new FileConf(name, part);\n                this.urlFileMap.set(name, conf);\n            }\n            if (!m) {\n                break;\n            }\n            name = m[0];\n            last = REG_HEAD_LINE.lastIndex;\n        }\n        const m0 = this.getParams('@__default__');\n        const m1 = this.getParams('@global');\n        this.globalParams = m1 ? new Map([...m0, ...m1]) : m0;\n    }\n}\nclass UrlConf {\n    constructor(url, fileParams) {\n        this.fileParams = fileParams;\n        if (url) {\n            [this.url, this.frag] = getPair(toRelUrl(url), '#');\n        }\n    }\n    static init() {\n        // 为了让代码更简洁，这里没有逐一引用各个参数对应的文件\n        // 如果该列表定义在全局，会出现依赖顺序的问题\n        this.nameClassMap = {\n            // 参数优先级（越前面的参数优先执行）\n            'data': ParamData,\n            'bundle': ParamBundle,\n            'concat': ParamConcat,\n            'open_timeout': ParamOpenTimeout,\n            'recv_timeout': ParamRecvTimeout,\n            'referrer_policy': ParamReferrerPolicy,\n            'req_headers': ParamReqHeaders,\n            'valid_status': ParamValidStatus,\n            'headers': ParamHeaders,\n            'expires': ParamExpires,\n            'mime': ParamMime,\n            'charset': ParamCharset,\n            'pos': ParamPos,\n            'size': ParamSize,\n            'xor': ParamXor,\n            'br': ParamBr,\n            'prefix': ParamPrefix,\n            'suffix': ParamSuffix,\n            'hash': ParamHash,\n            'stream': ParamStream,\n        };\n        Object.values(this.nameClassMap).forEach((cls, i) => {\n            cls.priority = i;\n        });\n    }\n    parse(manifest) {\n        // TODO: cache result\n        const params = new Map();\n        // 参数优先级: 全局参数 < 站点参数 < 文件参数 < URL 参数\n        mergeMap(params, manifest.globalParams);\n        // 站点参数\n        if (this.url) {\n            const host = this.url[0] === '/' ? MY_HOST : getHostFromUrl(this.url);\n            const hostParams = manifest.getParams('@host ' + host);\n            if (hostParams) {\n                mergeMap(params, hostParams);\n            }\n        }\n        // 文件参数\n        mergeMap(params, this.fileParams);\n        // URL 参数（定义在 # 后面）\n        if (this.frag) {\n            const urlParams = new URLSearchParams(this.frag);\n            mergeMap(params, urlParams);\n        }\n        const mods = [];\n        for (const [k, v] of params) {\n            const cls = UrlConf.nameClassMap[k];\n            if (!cls) {\n                console.warn('[FreeCDN/UrlConf] unknown param:', k);\n                continue;\n            }\n            const ret = cls.parseConf(v);\n            if (ret === undefined) {\n                continue;\n            }\n            if (typeof ret === 'string') {\n                console.warn('[FreeCDN/UrlConf] parseConf failed. mod:', k, 'err:', ret, 'conf:', v);\n                continue;\n            }\n            const obj = new cls(...ret);\n            mods.push(obj);\n        }\n        mods.sort((a, b) => (a.constructor.priority) -\n            (b.constructor.priority));\n        return mods;\n    }\n}\nclass UrlLoader {\n    constructor(url, paramMods) {\n        this.url = url;\n        this.paramMods = paramMods;\n        this.isFetchDone = false;\n        this.bytesRead = 0;\n    }\n    async load(fileLoader) {\n        let isNetErr = false;\n        let err;\n        try {\n            // 网络错误（包括 fetch 被终止产生的错误）\n            // 不同浏览器错误信息不同，因此不用 catch 判断，而是通过返回值\n            err = await this.loadUnsafe(fileLoader);\n            isNetErr = !!err;\n        }\n        catch (e) {\n            // 参数模块抛出的错误（也有可能是脚本错误）\n            // console.assert(e instanceof ParamError, e)\n            err = e;\n        }\n        if (err) {\n            if (this.abortCtrl && !this.abortCtrl.signal.aborted) {\n                for (const mod of this.paramMods) {\n                    mod.onError(err);\n                }\n                this.onError(err);\n                if (!isNetErr) {\n                    this.abort(err);\n                }\n            }\n        }\n    }\n    async loadUnsafe(fileLoader) {\n        const { rawReq } = fileLoader;\n        const { method } = rawReq;\n        const reqArgs = {\n            method,\n            referrer: rawReq.referrer,\n            referrerPolicy: 'same-origin',\n            headers: new Headers(),\n        };\n        if (method === 'POST' || method === 'PUT') {\n            reqArgs.body = await rawReq.clone().arrayBuffer();\n        }\n        let res;\n        for (const mod of this.paramMods) {\n            // 可直接返回响应（例如 data 参数、bundle 参数）\n            const ret = mod.onRequest(reqArgs, fileLoader);\n            if (ret) {\n                res = isPromise(ret) ? await ret : ret;\n                if (res) {\n                    break;\n                }\n            }\n        }\n        if (!res) {\n            if (!this.url) {\n                this.onError(Error('vURL no data'));\n                return;\n            }\n            this.abortCtrl = new AbortController();\n            reqArgs.signal = this.abortCtrl.signal;\n            const req = new Request(this.url, reqArgs);\n            try {\n                res = await Network.fetch(req);\n            }\n            catch (err) {\n                return err;\n            }\n        }\n        if (!res.body) {\n            return Error('cors error');\n        }\n        const resArgs = {\n            status: res.status,\n            statusText: res.statusText,\n            headers: new Headers(),\n            contentLen: -1,\n        };\n        if (!res.headers.has('content-encoding')) {\n            const contentLen = res.headers.get('content-length');\n            if (contentLen) {\n                resArgs.contentLen = +contentLen;\n            }\n        }\n        for (const mod of this.paramMods) {\n            mod.onResponse(resArgs, fileLoader, res);\n        }\n        const contentRange = res.headers.get('content-range');\n        if (contentRange) {\n            const m = contentRange.match(/bytes (\\d+)-/i);\n            if (m) {\n                const rangeBegin = +m[1];\n                if (rangeBegin > 0) {\n                    this.bytesRead = rangeBegin;\n                }\n            }\n        }\n        if (resArgs.contentLen >= 0) {\n            resArgs.headers.set('content-length', resArgs.contentLen + '');\n        }\n        this.onResponse(resArgs);\n        const reader = res.body.getReader();\n        let buf;\n        READ: for (;;) {\n            try {\n                const { value } = await reader.read();\n                if (!value) {\n                    break;\n                }\n                buf = value;\n            }\n            catch (err) {\n                return err;\n            }\n            for (const mod of this.paramMods) {\n                const ret = mod.onData(buf);\n                buf = isPromise(ret) ? await ret : ret;\n                if (buf.length === 0) {\n                    continue READ;\n                }\n            }\n            if (buf.length > 0) {\n                this.pauseSignal && await this.pauseSignal;\n                this.bytesRead += buf.length;\n                this.onData(buf);\n            }\n        } // READ NEXT\n        this.isFetchDone = true;\n        buf = EMPTY_BUF;\n        for (const mod of this.paramMods) {\n            const ret = mod.onEnd(buf);\n            buf = isPromise(ret) ? await ret : ret;\n        }\n        if (buf.length > 0) {\n            this.pauseSignal && await this.pauseSignal;\n            this.bytesRead += buf.length;\n            this.onData(buf);\n        }\n        this.onEnd();\n    }\n    pause() {\n        this.pauseSignal = promisex();\n    }\n    resume() {\n        this.pauseSignal.resolve();\n        this.pauseSignal = undefined;\n    }\n    abort(reason) {\n        if (this.isFetchDone) {\n            return;\n        }\n        this.abortCtrl?.abort();\n        for (const mod of this.paramMods) {\n            mod.onAbort(reason);\n        }\n    }\n}\n// 匹配缩进开头的行，捕获 trim 后的内容（排除 `#` 注释行）\nconst REG_SUB_LINE = /^\\s+([^#\\s].+?)\\s*$/mg;\nclass FileConf {\n    constructor(name, text) {\n        this.name = name;\n        this.text = text;\n    }\n    getLines() {\n        const lines = [];\n        for (;;) {\n            const m = REG_SUB_LINE.exec(this.text);\n            if (!m) {\n                break;\n            }\n            lines.push(m[1]);\n        }\n        this.text = '';\n        return lines;\n    }\n    parse() {\n        if (this.text === '') {\n            return;\n        }\n        const urlConfs = [];\n        const params = new Map();\n        for (const line of this.getLines()) {\n            if (/^https?:|^\\//.test(line)) {\n                const urlConf = new UrlConf(line, params);\n                urlConfs.push(urlConf);\n            }\n            else {\n                const [key, val] = getPair(line, '=');\n                if (val === undefined) {\n                    console.warn('[FreeCDN/FileConf] missing param value:', line);\n                    continue;\n                }\n                params.set(key, val);\n            }\n        }\n        this.params = params;\n        this.urlConfs = urlConfs;\n    }\n}\nconst FILE_BACKUP_PARAMS = [\n    'open_timeout',\n    'recv_timeout',\n    'hash',\n    'req_headers',\n    'valid_status',\n];\nclass FileLoaderError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass FileLoader {\n    constructor(fileConf, rawReq, cdn, range, suffix) {\n        this.fileConf = fileConf;\n        this.rawReq = rawReq;\n        this.cdn = cdn;\n        this.range = range;\n        this.suffix = suffix;\n        this.urlLoaderSet = new Set();\n        this.isPaused = false;\n        this.isAborted = false;\n        this.delayTid = 0;\n        this.urlErrs = [];\n        this.hasRange = false;\n        this.opened = false;\n        this.closed = false;\n        this.bytesRead = 0;\n        const fileParams = fileConf.params;\n        if (range) {\n            const r = this.parseReqRange(range);\n            if (r) {\n                [this.rangeBegin, this.rangeEnd] = r;\n                this.hasRange = true;\n                this.bytesRead = this.rangeBegin;\n            }\n            const fileSize = fileParams.get('size');\n            if (fileSize) {\n                this.fileSize = +fileSize;\n            }\n        }\n        if (fileParams.has('data') || fileParams.has('bundle') || fileParams.has('concat')) {\n            this.vUrlConf = new UrlConf(undefined, fileParams);\n        }\n        // 原始 URL 作为后备资源\n        // 禁止修改原始内容，因此只保留白名单中的参数\n        const backupParams = new Map();\n        for (const k of FILE_BACKUP_PARAMS) {\n            const v = fileParams.get(k);\n            if (v !== undefined) {\n                backupParams.set(k, v);\n            }\n        }\n        const backupUrlConf = new UrlConf(fileConf.name, backupParams);\n        this.urlConfs = fileConf.urlConfs.concat(backupUrlConf);\n    }\n    parseReqRange(range) {\n        // 目前只考虑 `bytes=begin-end` 和 `bytes=begin-` 格式\n        const m = range.match(/bytes=(\\d+)-(\\d*)/i);\n        if (!m) {\n            return;\n        }\n        const begin = +m[1];\n        const end = +m[2]; // +'' === 0\n        if (end !== 0 && end <= begin) {\n            return;\n        }\n        return [begin, end];\n    }\n    buildResRange(resArgs) {\n        const begin = this.rangeBegin;\n        let end = 0;\n        if (this.rangeEnd) {\n            end = this.rangeEnd - 1;\n        }\n        else if (this.fileSize) {\n            end = this.fileSize - 1;\n        }\n        else if (resArgs.contentLen > 0) {\n            end = resArgs.contentLen;\n        }\n        const val = 'bytes ' + begin + '-' + end + '/' + (this.fileSize || '*');\n        // TODO: status 416\n        resArgs.status = 206;\n        resArgs.headers.set('content-range', val);\n        if (end > 0) {\n            const len = end - begin + 1;\n            resArgs.headers.set('content-length', len + '');\n        }\n    }\n    open() {\n        this.loadNextUrl();\n    }\n    pause() {\n        if (this.isPaused) {\n            return;\n        }\n        this.isPaused = true;\n        // TODO: 进度落后的 Loader 无需暂停\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.pause();\n        }\n    }\n    resume() {\n        if (!this.isPaused) {\n            return;\n        }\n        this.isPaused = false;\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.resume();\n        }\n    }\n    abort(reason) {\n        if (this.isAborted) {\n            return;\n        }\n        this.isAborted = true;\n        for (const urlLoader of this.urlLoaderSet) {\n            urlLoader.abort(reason);\n        }\n        if (this.delayTid !== 0) {\n            clearTimeout(this.delayTid);\n        }\n    }\n    getNextUrl() {\n        // 优先使用虚拟 URL（例如存在 data 参数时，无需使用真实 URL）\n        const { vUrlConf } = this;\n        if (vUrlConf) {\n            this.vUrlConf = undefined;\n            return { weight: 100, conf: vUrlConf };\n        }\n        const { urlConfs } = this;\n        const lastIndex = urlConfs.length - 1;\n        if (lastIndex === -1) {\n            return;\n        }\n        const now = getTimeSec();\n        let weight = -10000;\n        let index = 0;\n        urlConfs.forEach((conf, i) => {\n            const w = Network.getUrlWeight(conf.url, now, this.cdn.weightConf);\n            if (w > weight) {\n                weight = w;\n                index = i;\n            }\n        });\n        // 删除 urlConfs[index]\n        const conf = urlConfs[index];\n        urlConfs[index] = urlConfs[lastIndex];\n        urlConfs.length = lastIndex;\n        return { weight, conf };\n    }\n    loadNextUrl(delay = 0) {\n        const ret = this.getNextUrl();\n        if (!ret) {\n            if (this.urlLoaderSet.size === 0) {\n                const err = new FileLoaderError('failed to load: ' + this.getSourceUrl());\n                err.urlErrs = this.urlErrs;\n                this.onError(err);\n            }\n            return;\n        }\n        const { weight, conf } = ret;\n        if (weight < 0 && delay > 0) {\n            // 并行加载多个备用 URL 时，推迟低权重的站点（例如当前站点、收费站点）\n            this.delayTid = setTimeout(() => {\n                this.delayTid = 0;\n                this.createUrlLoader(conf);\n            }, delay);\n            return;\n        }\n        this.createUrlLoader(conf);\n    }\n    getSourceUrl() {\n        return this.fileConf.name + this.suffix;\n    }\n    getTargetUrl(url) {\n        if (url.endsWith('/')) {\n            return url + this.suffix;\n        }\n        return url;\n    }\n    createUrlLoader(urlConf) {\n        const url = urlConf.url && this.getTargetUrl(urlConf.url);\n        const mods = urlConf.parse(this.cdn.manifest);\n        const urlLoader = new UrlLoader(url, mods);\n        this.urlLoaderSet.add(urlLoader);\n        urlLoader.onData = (chunk) => {\n            if (this.closed) {\n                return;\n            }\n            const add = urlLoader.bytesRead - this.bytesRead;\n            if (add <= 0) {\n                // 当前节点的进度落后于总进度，丢弃收到的数据\n                return;\n            }\n            if (add !== chunk.length) {\n                chunk = chunk.subarray(-add);\n            }\n            this.bytesRead = urlLoader.bytesRead;\n            if (this.rangeEnd) {\n                const exceed = this.bytesRead - this.rangeEnd;\n                if (exceed > 0) {\n                    chunk = chunk.subarray(0, -exceed);\n                    this.onData(chunk);\n                    urlLoader.onEnd();\n                    return;\n                }\n            }\n            this.onData(chunk);\n        };\n        urlLoader.onEnd = () => {\n            if (this.closed) {\n                return;\n            }\n            this.closed = true;\n            this.onEnd();\n            this.abort('TASK_DONE');\n        };\n        urlLoader.onError = (err) => {\n            this.urlErrs.push({ url: urlLoader.url || '', err });\n            this.urlLoaderSet.delete(urlLoader);\n            this.loadNextUrl();\n        };\n        urlLoader.onResponse = (resArgs) => {\n            if (this.opened) {\n                return;\n            }\n            if (this.hasRange) {\n                this.buildResRange(resArgs);\n            }\n            this.opened = true;\n            this.onOpen(resArgs);\n        };\n        urlLoader.load(this);\n    }\n}\nconst EMPTY_PARAMS = new Map();\nclass Updater {\n    constructor(manifestPath, onAvailable) {\n        this.onAvailable = onAvailable;\n        this.urlWsMap = new Map();\n        this.wsArgs = '';\n        this.manifestHash = EMPTY_BUF;\n        this.pollingTimer = 0;\n        this.pollingInterval = 300000 /* DEFAULT_INTERVAL */;\n        this.lastTime = 0;\n        this.setSvcTimer = 0;\n        this.backupUrls = [];\n        const url = new URL(manifestPath, MY_URL);\n        console.assert(url.host === MY_HOST);\n        const path = url.pathname + url.search;\n        if (path !== DEFAULT_MANIFEST_PATH) {\n            this.wsArgs = '?manifest=' + encodeURIComponent(path);\n        }\n        this.manifestUrl = path;\n    }\n    async getManifestFromCache() {\n        const res = await CacheManager.findCache(this.manifestUrl);\n        if (!res) {\n            return;\n        }\n        const buf = await res.arrayBuffer();\n        const bin = new Uint8Array(buf);\n        // 使用公钥校验缓存配置（缓存可被恶意脚本篡改）\n        if (!await KeyManager.verify(bin)) {\n            return;\n        }\n        const txt = bytesToUtf8(bin);\n        const manifest = new Manifest();\n        await manifest.parse(txt);\n        return manifest;\n    }\n    async init() {\n        const manifest = await this.getManifestFromCache();\n        if (manifest) {\n            // 先使用本地缓存的配置\n            this.onAvailable(manifest);\n        }\n        await this.update();\n    }\n    async update() {\n        if (this.updateSignal) {\n            return this.updateSignal;\n        }\n        const now = Date.now();\n        if (now - this.lastTime < 1000 /* MIN_INTERVAL */) {\n            return true;\n        }\n        this.lastTime = now;\n        this.updateSignal = promisex();\n        let ret = false;\n        try {\n            ret = await this.updateUnsafe();\n        }\n        catch (err) {\n            console.error('[FreeCDN/Updater] update err:', err);\n        }\n        this.updateSignal.resolve(ret);\n        this.updateSignal = undefined;\n        return ret;\n    }\n    async updateUnsafe() {\n        // from current site\n        const data = await this.fetchManifest(this.manifestUrl);\n        if (data) {\n            await this.applyManifest(data);\n            return true;\n        }\n        console.warn('[FreeCDN/Updater] failed to fetch 1st manifest:', this.manifestUrl);\n        if (this.backupUrls.length === 0) {\n            console.warn('[FreeCDN/Updater] no backup url');\n            return false;\n        }\n        // from backup sites\n        for (const url of this.backupUrls) {\n            const data = await this.fetchManifest(url);\n            if (!data) {\n                console.warn('[FreeCDN/Updater] failed to fetch 3rd manifest:', url);\n                continue;\n            }\n            if (!await KeyManager.verify(data)) {\n                console.warn('[FreeCDN/Updater] failed to verify 3rd manifest:', url);\n                continue;\n            }\n            await this.applyManifest(data);\n            return true;\n        }\n        console.warn('[FreeCDN/Updater] failed to reload');\n        return false;\n    }\n    async fetchManifest(url) {\n        const ctl = new AbortController();\n        const tid = setTimeout(() => {\n            ctl.abort();\n        }, 3000 /* FETCH_TIMEOUT */);\n        const req = new Request(url, {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\n            cache: 'no-cache',\n            signal: ctl.signal,\n        });\n        try {\n            const res = await Network.fetch(req);\n            const bin = await res.arrayBuffer();\n            return new Uint8Array(bin);\n        }\n        catch {\n        }\n        finally {\n            clearTimeout(tid);\n        }\n    }\n    async applyManifest(bytes) {\n        const hash = await sha256(bytes);\n        if (isArrayEqual(this.manifestHash, hash)) {\n            return;\n        }\n        this.manifestHash = hash;\n        // 缓存最新的清单内容\n        const res = new Response(bytes);\n        res.headers.set('content-length', bytes.length + '');\n        CacheManager.addCache(this.manifestUrl, res);\n        const manifest = new Manifest();\n        const txt = bytesToUtf8(bytes);\n        await manifest.parse(txt);\n        this.onAvailable(manifest);\n    }\n    applyConfs(params) {\n        this.backupUrls = this.parseBackupParam(params);\n        const interval = this.parseIntervalParam(params);\n        this.setPollingInterval(interval);\n        const svcUrls = this.parseServicesParam(params);\n        if (this.setSvcTimer > 0) {\n            clearTimeout(this.setSvcTimer);\n        }\n        // 延时开启，减少对业务的性能影响\n        this.setSvcTimer = setTimeout(() => {\n            this.setSvcTimer = 0;\n            this.setServices(svcUrls);\n        }, 5000 /* SET_SVC_DELAY */);\n    }\n    parseBackupParam(params) {\n        const str = params.get('backup') || '';\n        return splitList(str);\n    }\n    parseIntervalParam(params) {\n        const str = params.get('interval');\n        if (str) {\n            const num = parseTime(str);\n            if (!isNaN(num)) {\n                return num;\n            }\n            console.warn('[FreeCDN/Updater] invalid interval:', str);\n        }\n        return 300000 /* DEFAULT_INTERVAL */;\n    }\n    parseServicesParam(params) {\n        const str = params.get('services') || '';\n        return splitList(str);\n    }\n    setPollingInterval(interval) {\n        if (this.pollingInterval === interval) {\n            return;\n        }\n        this.pollingInterval === interval;\n        if (this.pollingTimer) {\n            clearInterval(this.pollingTimer);\n        }\n        if (interval > 0) {\n            this.pollingTimer = setInterval(() => {\n                this.update();\n            }, interval);\n        }\n    }\n    setServices(urls) {\n        for (const [url, ws] of this.urlWsMap) {\n            if (!urls.includes(url)) {\n                ws.onclose = null;\n                ws.close();\n                this.urlWsMap.delete(url);\n            }\n        }\n        for (const url of urls) {\n            if (!this.urlWsMap.has(url)) {\n                this.createSvc(url);\n            }\n        }\n    }\n    createSvc(url) {\n        const ws = new WebSocket(url + this.wsArgs);\n        ws.binaryType = 'arraybuffer';\n        ws.onmessage = (e) => {\n            const hashBin = new Uint8Array(e.data);\n            if (isArrayEqual(this.manifestHash, hashBin)) {\n                return;\n            }\n            this.update();\n        };\n        ws.onclose = () => {\n            this.urlWsMap.delete(url);\n            setTimeout(() => {\n                this.createSvc(url);\n            }, 20000 /* WS_RETRY_DELAY */);\n        };\n        this.urlWsMap.set(url, ws);\n    }\n}\n///<reference path=\"global.ts\"/>\n///<reference path=\"param-base.ts\"/>\n///<reference path=\"key-manager.ts\"/>\n///<reference path=\"manifest.ts\"/>\n///<reference path=\"url-conf.ts\"/>\n///<reference path=\"url-loader.ts\"/>\n///<reference path=\"file-conf.ts\"/>\n///<reference path=\"file-loader.ts\"/>\n///<reference path=\"updater.ts\"/>\nclass FreeCDN {\n    constructor(manifestUrl) {\n        this.enableCacheStorage = true;\n        this.isSubReq = false;\n        this.weightConf = new Map();\n        this.inited = false;\n        if (!manifestUrl) {\n            return;\n        }\n        const updater = new Updater(manifestUrl, manifest => {\n            this.manifest = manifest;\n            const updateConf = manifest.getParams('@update') || EMPTY_PARAMS;\n            updater.applyConfs(updateConf);\n            // 权重参数\n            this.weightConf = Network.parseWeightConf(manifest);\n        });\n        this.updater = updater;\n    }\n    async fetch(input, init) {\n        const req = (input instanceof Request && !init)\n            ? input\n            : new Request(input, init);\n        if (!/^https?:/.test(req.url)) {\n            return NATIVE_FETCH(req);\n        }\n        const { manifest } = this;\n        if (!manifest) {\n            return Network.fetch(req);\n        }\n        let fileConf;\n        let suffix = '';\n        FIND: for (;;) {\n            const urlObj = new URL(req.url);\n            // 同源 URL 使用相对路径，不同源使用完整路径（和清单中格式保持一致）\n            const originPrefix = urlObj.origin === MY_ORIGIN ? '' : urlObj.origin;\n            // 带参数的 URL 尝试完整匹配\n            if (urlObj.search) {\n                fileConf = manifest.get(originPrefix + urlObj.pathname + urlObj.search);\n                if (fileConf) {\n                    break;\n                }\n            }\n            // 合并路径中连续的 `/`\n            const path = urlObj.pathname.replace(/\\/{2,}/g, '/');\n            const file = originPrefix + path;\n            // 优先使用 avif、webp 版本\n            if (REG_IMG_EXTS.test(file) && req.mode !== 'cors' && !req.integrity) {\n                const accept = req.headers.get('accept') || '';\n                if (accept.includes('image/avif')) {\n                    fileConf = manifest.get(file + '.avif');\n                    if (fileConf) {\n                        break;\n                    }\n                }\n                if (accept.includes('image/webp')) {\n                    fileConf = manifest.get(file + '.webp');\n                    if (fileConf) {\n                        break;\n                    }\n                }\n            }\n            fileConf = manifest.get(file);\n            if (fileConf) {\n                break;\n            }\n            if (file.endsWith('/')) {\n                fileConf = manifest.get(file + 'index.html');\n                if (fileConf) {\n                    break;\n                }\n            }\n            // 重定向到 `/` 结尾的路径\n            if (manifest.has(file + '/index.html')) {\n                return Response.redirect(file + '/');\n            }\n            // 目录匹配\n            // 尾部保存到 suffix 变量。例如访问 /path/to/file?a=1\n            // 清单若存在 /path/ 文件，suffix 则为 `to/file?a=1`\n            // 删除末尾的文件名。保持 `/` 结尾\n            let dir = path.replace(/[^/]*$/, '');\n            for (;;) {\n                fileConf = manifest.get(originPrefix + dir);\n                if (fileConf) {\n                    suffix = path.substring(dir.length) + urlObj.search;\n                    break FIND;\n                }\n                if (dir === '/') {\n                    break;\n                }\n                // 删除末尾的目录名。保持 `/` 结尾\n                dir = dir.replace(/[^/]+\\/$/, '');\n            }\n            // 清单中无匹配，直接转发\n            return Network.fetch(req);\n        }\n        fileConf.parse();\n        let fileHash = '';\n        const hashParam = fileConf.params.get('hash');\n        if (hashParam && hashParam.length === 44 /* SHA256_B64 */) {\n            fileHash = hashParam;\n        }\n        const range = req.headers.get('range');\n        const cacheable = this.enableCacheStorage && fileHash && !range;\n        if (cacheable) {\n            const res = await CacheManager.findHash(fileHash);\n            if (res) {\n                return res;\n            }\n        }\n        const fileLoader = new FileLoader(fileConf, req, this, range, suffix);\n        const promiseObj = promisex();\n        req.signal.addEventListener('abort', () => {\n            const reason = req.signal.reason || 'unknown';\n            fileLoader.abort(reason);\n        });\n        // 如果文件只有一个 hash 则不用流模式（必须完整下载才能校验 hash）\n        if (fileHash) {\n            let resArgs;\n            let resBody;\n            fileLoader.onOpen = (args) => {\n                resArgs = args;\n            };\n            fileLoader.onData = (body) => {\n                resBody = body;\n            };\n            fileLoader.onEnd = () => {\n                const body = resBody || EMPTY_BUF;\n                const res = new Response(body, resArgs);\n                if (cacheable && body.length < 1024 * 1024 * 5) {\n                    const cacheRes = res.clone();\n                    // 字段可在控制台列表中显示，方便调试\n                    cacheRes.headers.set('content-length', body.length + '');\n                    cacheRes.headers.set('x-raw-url', req.url);\n                    CacheManager.addHash(fileHash, cacheRes);\n                }\n                promiseObj.resolve(res);\n            };\n            fileLoader.onError = (err) => {\n                console.warn('[FreeCDN]', err.message, err.urlErrs);\n                promiseObj.reject(err);\n            };\n            fileLoader.open();\n            return promiseObj;\n        }\n        // 如果文件有多个 hash 或没有 hash，可使用流模式\n        let controller;\n        const checkPressure = () => {\n            const { desiredSize } = controller;\n            if (desiredSize === null) {\n                console.warn('desiredSize is null');\n                return;\n            }\n            if (desiredSize <= 0) {\n                fileLoader.pause();\n            }\n            else {\n                fileLoader.resume();\n            }\n        };\n        const stream = new ReadableStream({\n            start(c) {\n                controller = c;\n            },\n            pull: checkPressure,\n            cancel(reason) {\n                console.warn('[FreeCDN] stream cancel:', reason);\n                fileLoader.abort(reason);\n            },\n        });\n        fileLoader.onData = (chunk) => {\n            controller.enqueue(chunk);\n            checkPressure();\n        };\n        fileLoader.onEnd = () => {\n            controller.close();\n        };\n        fileLoader.onError = (err) => {\n            controller.error(err);\n            console.warn('[FreeCDN]', err.message, err.urlErrs);\n            promiseObj.reject(err);\n        };\n        fileLoader.onOpen = (args) => {\n            const res = new Response(stream, args);\n            promiseObj.resolve(res);\n        };\n        fileLoader.open();\n        return promiseObj;\n    }\n    async fetchText(url) {\n        const res = await this.fetch(url);\n        return res.text();\n    }\n    async fetchBin(url) {\n        const res = await this.fetch(url);\n        const buf = await res.arrayBuffer();\n        return new Uint8Array(buf);\n    }\n    async fetchBlob(url) {\n        const res = await this.fetch(url);\n        const buf = await res.arrayBuffer();\n        const type = res.headers.get('content-type') || '';\n        return new Blob([buf], { type });\n    }\n    async update() {\n        if (this.updater) {\n            return this.updater.update();\n        }\n        return false;\n    }\n    async setPublicKey(keyB64) {\n        if (keyB64.length !== 124 /* PUBKEY_B64 */) {\n            keyB64 = `MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE${keyB64}==`;\n        }\n        await KeyManager.set(keyB64);\n    }\n    async init() {\n        console.assert(!this.inited);\n        this.inited = true;\n        await globalInit();\n        if (this.updater) {\n            await this.updater.init();\n        }\n    }\n}\n// non-callback style Promise\nfunction promisex() {\n    let resolve;\n    let reject;\n    const p = new Promise((a, b) => {\n        resolve = a;\n        reject = b;\n    });\n    // @ts-ignore\n    p.resolve = resolve;\n    // @ts-ignore\n    p.reject = reject;\n    return p;\n}\n// faster than instanceof\nfunction isPromise(obj) {\n    return typeof obj.then === 'function';\n}\n///<reference path=\"../../core-lib/src/freecdn.ts\"/>\n///<reference path=\"../../core-lib/src/promisex.ts\"/>\n///<reference path=\"hook.ts\"/>\nvar Sw;\n(function (Sw) {\n    const GLOBAL = self;\n    const mLoaderJsRes = new Response('/* freecdn is installed */', {\n        headers: {\n            'content-type': 'text/javascript',\n            'cache-control': 'max-age=3600',\n        },\n    });\n    let mFreeCDN;\n    let mIniting;\n    let mResUrlMap;\n    // 共享模式（脚本通过业务方的 SW 引入）\n    function sharedModeInit() {\n        Hook.func(GLOBAL, 'fetch', oldFn => sharedModeHandler);\n        Hook.func(Cache.prototype, 'add', oldFn => async function (req) {\n            const res = await sharedModeHandler(req);\n            await this.put(req, res);\n        });\n        Hook.func(Cache.prototype, 'addAll', oldFn => async function (reqs) {\n            const tasks = reqs.map(req => this.add(req));\n            await Promise.all(tasks);\n        });\n        mResUrlMap = new WeakMap();\n        // 由于自定义的 Response 对象 url 为空，因此通过 hook 的方式保留原始 url\n        Hook.prop(Response.prototype, 'url', getter => function () {\n            return mResUrlMap.get(this) || getter.call(this);\n        }, \n        /* setter */ null);\n        Hook.func(Response.prototype, 'clone', oldFn => function () {\n            const res = oldFn.call(this);\n            const url = mResUrlMap.get(this);\n            if (url) {\n                mResUrlMap.set(res, url);\n            }\n            return res;\n        });\n    }\n    async function sharedModeHandler(input, init) {\n        if (mIniting) {\n            // freecdn 仍在初始化中（例如加载清单文件）\n            await mIniting;\n        }\n        const req = (input instanceof Request && !init)\n            ? input\n            : new Request(input, init);\n        const res = await mFreeCDN.fetch(req);\n        mResUrlMap.set(res, req.url);\n        return res;\n    }\n    // 独占模式（通过 freecdn-loader.min.js 引入）\n    function loaderModeInit() {\n        // 重写 Q.push，这样 loader-js 可直接传递 event 和 promise\n        Q.push = loaderModeHandler;\n        while (Q.length) {\n            const args = Q.splice(0, 3);\n            loaderModeHandler(...args);\n        }\n    }\n    function loaderModeHandler(e, resolve, reject) {\n        const req = e.request;\n        // debug\n        if (req.url.endsWith('/freecdn-update')) {\n            mFreeCDN.update().then(result => {\n                const res = new Response('updated. success: ' + result, {\n                    headers: {\n                        'content-type': 'text/html',\n                    },\n                });\n                resolve(res);\n            });\n            return;\n        }\n        if (req.url === MY_URL) {\n            resolve(mLoaderJsRes.clone());\n            return;\n        }\n        mFreeCDN.fetch(req).then(resolve, reject);\n    }\n    async function main() {\n        mFreeCDN = new FreeCDN('freecdn-internal/freecdn-manifest.txt');\n        const isSharedMode = !!GLOBAL.FREECDN_SHARED_MODE;\n        let publicKey;\n        if (isSharedMode) {\n            mFreeCDN.enableCacheStorage = false;\n            mIniting = promisex();\n            // 在此之前不要使用 await，否则安装 hook 会被推迟，导致初始化时无法触发 hook\n            sharedModeInit();\n            publicKey = GLOBAL.FREECDN_PUBLIC_KEY;\n        }\n        else {\n            publicKey = Q.shift();\n        }\n        if (publicKey) {\n            await mFreeCDN.setPublicKey(publicKey);\n        }\n        await mFreeCDN.init();\n        if (isSharedMode) {\n            mIniting?.resolve();\n            mIniting = null;\n        }\n        else {\n            loaderModeInit();\n        }\n        console.log('[FreeCDN] service worker inited');\n    }\n    main();\n})(Sw || (Sw = {}));\nclass ParamBr extends ParamBase {\n    constructor() {\n        super();\n        this.state = 0;\n    }\n    static async init() {\n        if (this.signal) {\n            return;\n        }\n        this.signal = promisex();\n        const BR_WASM_PATH = `${INTERNAL_PATH}/br/br.wasm`;\n        const BR_GLUE_PATH = `${INTERNAL_PATH}/br/` + (IS_DEBUG ? 'br.js' : 'br.min.js');\n        const BR_MANIFEST = IS_DEBUG ? '' : `\n${BR_WASM_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.wasm\n\thash=${BR_WASM_HASH}\n\n${BR_GLUE_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.min.js\n\thash=${BR_GLUE_HASH}\n`;\n        const onError = () => {\n            this.hasErr = true;\n            this.signal?.resolve();\n        };\n        const timer = setTimeout(onError, 20000 /* WASM_LOAD_TIMEOUT */);\n        const asmMod = {\n            locateFile: () => BR_WASM_PATH,\n            onRuntimeInitialized: () => {\n                this.inPtr = asmMod._AllocInBuf(131072 /* IN_BUF_LEN */);\n                this.outPtr = asmMod._AllocOutBuf(524288 /* OUT_BUF_LEN */);\n                clearTimeout(timer);\n                this.signal?.resolve();\n                this.signal = undefined;\n            },\n            onAbort: (reason) => {\n                console.warn('[FreeCDN/Br] wasm onAbort:', reason);\n                onError();\n            },\n            print: (msg) => {\n                console.warn('[FreeCDN/Br] wasm print:', msg);\n            },\n            printErr: (err) => {\n                console.warn('[FreeCDN/Br] wasm printErr:', err);\n            },\n        };\n        const manifest = new Manifest();\n        await manifest.parse(BR_MANIFEST);\n        const cdn = new FreeCDN();\n        cdn.manifest = manifest;\n        const onFetch = async (...args) => {\n            try {\n                return await cdn.fetch(...args);\n            }\n            catch (err) {\n                console.warn('[FreeCDN/Br] failed to load wasm');\n                onError();\n                throw err;\n            }\n        };\n        try {\n            const js = await cdn.fetchText(BR_GLUE_PATH);\n            const fn = Function('Module', 'fetch', js);\n            fn(asmMod, onFetch);\n        }\n        catch {\n            console.warn('[FreeCDN/Br] failed to execute glue js');\n            onError();\n            return;\n        }\n        this.asmMod = asmMod;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        if (conf === 'on') {\n            if (!this.asmMod) {\n                this.init();\n            }\n            return [];\n        }\n        return 'invalid value';\n    }\n    onResponse(resArgs) {\n        resArgs.contentLen = -1;\n    }\n    async onData(chunk) {\n        if (ParamBr.signal) {\n            await this.waitWasm();\n        }\n        return this.process(chunk);\n    }\n    async onEnd(chunk) {\n        if (ParamBr.signal) {\n            await this.waitWasm();\n        }\n        // ???\n        let buf = EMPTY_BUF;\n        if (chunk.length > 0) {\n            buf = this.process(chunk);\n        }\n        this.destory();\n        return buf;\n    }\n    async waitWasm() {\n        await ParamBr.signal;\n        if (ParamBr.hasErr) {\n            throw new ParamError('failed to load br decoder');\n        }\n    }\n    process(chunk) {\n        const asmObj = ParamBr.asmMod;\n        const HEAPU8 = asmObj.HEAPU8;\n        if (this.state === 0) {\n            this.state = asmObj._Init();\n        }\n        const outBufs = [];\n        for (let p = 0; p < chunk.length; p += 131072 /* IN_BUF_LEN */) {\n            const inBuf = chunk.subarray(p, p + 131072 /* IN_BUF_LEN */);\n            HEAPU8.set(inBuf, ParamBr.inPtr);\n            let availIn = inBuf.length;\n            let availOut = 0;\n            do {\n                const ret = asmObj._Update(this.state, 0, availIn);\n                if (ret === 0 /* ERROR */) {\n                    const err = asmObj._GetErrorCode();\n                    this.destory();\n                    throw new ParamError('br decode failed. code: ' + err);\n                }\n                availIn = asmObj._GetAvailableIn();\n                availOut = asmObj._GetAvailableOut();\n                const len = 524288 /* OUT_BUF_LEN */ - availOut;\n                if (len === 0) {\n                    continue;\n                }\n                // use slice (copy), not subarray (ref)\n                const outBuf = HEAPU8.slice(ParamBr.outPtr, ParamBr.outPtr + len);\n                outBufs.push(outBuf);\n            } while (asmObj._HasMoreOutput(this.state));\n        }\n        if (outBufs.length === 1) {\n            return outBufs[0];\n        }\n        return concatBufs(outBufs);\n    }\n    destory() {\n        ParamBr.asmMod._Destroy(this.state);\n    }\n}\nParamBr.hasErr = false;\nclass ParamBundle extends ParamBase {\n    constructor(packUrl) {\n        super();\n        this.packUrl = packUrl;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        if (!/^https?:|^\\//.test(conf)) {\n            return 'invalid url';\n        }\n        return [conf];\n    }\n    async onRequest(reqArgs, fileLoader) {\n        if (fileLoader.cdn.isSubReq) {\n            return;\n        }\n        let fileMap = ParamBundle.cache.get(this.packUrl);\n        if (!fileMap) {\n            // init\n            fileMap = promisex();\n            ParamBundle.cache.set(this.packUrl, fileMap);\n            this.loadPkg(fileLoader, fileMap)\n                .catch(fileMap.reject.bind(fileMap));\n        }\n        if (isPromise(fileMap)) {\n            try {\n                fileMap = await fileMap;\n            }\n            catch (err) {\n                if (typeof err === 'string') {\n                    this.warn(err);\n                }\n                else {\n                    console.assert(err instanceof ReaderError, err);\n                }\n                return;\n            }\n        }\n        let res;\n        for (;;) {\n            const path = fileLoader.suffix;\n            res = fileMap.get(path);\n            if (res) {\n                break;\n            }\n            if (path === '') {\n                res = fileMap.get('index.html');\n                if (res) {\n                    fileLoader.suffix = 'index.html';\n                }\n                break;\n            }\n            if (path.endsWith('/')) {\n                res = fileMap.get(path + 'index.html');\n                if (res) {\n                    fileLoader.suffix = path + 'index.html';\n                }\n                break;\n            }\n            if (fileMap.has(path + '/index.html')) {\n                fileLoader.suffix = path + '/index.html';\n                return new Response(\"<script>location.pathname+='/'</script>\");\n            }\n            break;\n        }\n        if (!res) {\n            return;\n        }\n        if (res === 1 /* LOADING */) {\n            // register callback\n            res = promisex();\n            fileMap.set(fileLoader.suffix, res);\n        }\n        if (isPromise(res)) {\n            res = await res;\n        }\n        return res.clone();\n    }\n    async loadPkg(fileLoader, fileMapSignal) {\n        const fileMap = new Map();\n        const cdn = new FreeCDN();\n        cdn.manifest = fileLoader.cdn.manifest;\n        cdn.weightConf = fileLoader.cdn.weightConf;\n        cdn.isSubReq = true;\n        const reader = new Reader();\n        try {\n            const res = await cdn.fetch(this.packUrl);\n            reader.source = res.body.getReader();\n        }\n        catch {\n            throw 'failed to load';\n        }\n        // delimiter `\\r`\n        const delimPos = await reader.findAsync(13);\n        if (delimPos === -1) {\n            throw 'missing header';\n        }\n        const confBin = await reader.readBytesAsync(delimPos + 1);\n        const confMap = parseJson(bytesToUtf8(confBin));\n        if (!confMap || typeof confMap !== 'object') {\n            throw 'invalid header';\n        }\n        for (const path of Object.keys(confMap)) {\n            fileMap.set(path, 1 /* LOADING */);\n        }\n        fileMapSignal.resolve(fileMap);\n        for (const [path, headers] of Object.entries(confMap)) {\n            const fileLen = +headers['content-length'];\n            if (!(fileLen >= 0)) {\n                throw 'invalid content-length';\n            }\n            const fileBuf = await reader.readBytesAsync(fileLen);\n            const res = new Response(fileBuf, {\n                headers: confMap[path],\n            });\n            const signal = fileMap.get(path);\n            if (signal !== 1 /* LOADING */) {\n                signal.resolve(res);\n            }\n            fileMap.set(path, res);\n        }\n    }\n    warn(msg) {\n        console.warn('[FreeCDN/Bundle]', msg, this.packUrl);\n    }\n}\nParamBundle.cache = new Map();\nconst REG_TEXT_MIME = /^text\\/|^application\\/(?:javascript|json)|\\+xml$/;\nclass ParamCharset extends ParamBase {\n    constructor(charset) {\n        super();\n        this.charset = charset;\n    }\n    static parseConf(conf) {\n        if (conf !== 'off') {\n            return [conf];\n        }\n    }\n    onResponse(resArgs) {\n        const type = resArgs.headers.get('content-type') || '';\n        if (REG_TEXT_MIME.test(type)) {\n            resArgs.headers.set('content-type', type + '; charset=' + this.charset);\n        }\n    }\n}\nParamCharset.reuse = true;\nclass ParamConcat extends ParamBase {\n    constructor(partLen, urls) {\n        super();\n        this.partLen = partLen;\n        this.urls = urls;\n    }\n    static parseConf(conf) {\n        if (conf === 'off') {\n            return;\n        }\n        const urls = splitList(conf);\n        if (urls.length === 0) {\n            return 'missing url';\n        }\n        let partLen = parseByteUnit(urls[0]);\n        if (partLen > 0) {\n            urls.shift();\n        }\n        else {\n            partLen = -1;\n        }\n        for (const url of urls) {\n            if (!/^https?:|^\\//.test(url)) {\n                return 'invalid url';\n            }\n        }\n        return [partLen, urls];\n    }\n    async onRequest(reqArgs, fileLoader) {\n        if (fileLoader.cdn.isSubReq) {\n            return;\n        }\n        const manifest = fileLoader.cdn.manifest;\n        const fileInfos = [];\n        const REG_WILDCARD = /\\[(\\d+)-(\\d+)\\]/;\n        for (const url of this.urls) {\n            let beginNum = 0;\n            let endNum = 0;\n            let padNum = 0;\n            // 通配格式 [begin-end]\n            // begin 左侧可有多个 0，用于固定数字长度\n            const m = url.match(REG_WILDCARD);\n            if (m) {\n                const beginStr = m[1];\n                beginNum = +beginStr;\n                endNum = +m[2];\n                padNum = beginStr[0] === '0' ? beginStr.length : 0;\n            }\n            for (let i = beginNum; i <= endNum; i++) {\n                const realUrl = m\n                    ? url.replace(REG_WILDCARD, (i + '').padStart(padNum, '0'))\n                    : url;\n                const fileConf = manifest.get(realUrl);\n                if (fileConf) {\n                    fileConf.parse();\n                    // 如果文件在清单中，优先使用 size 参数作为长度\n                    const size = fileConf.params.get('size');\n                    fileInfos.push({\n                        url: fileConf.name,\n                        size: size ? +size : this.partLen,\n                    });\n                }\n                else {\n                    fileInfos.push({ url: realUrl, size: this.partLen });\n                }\n            }\n        }\n        fileInfos.reverse();\n        const headers = new Headers();\n        // 排除 range 之前的文件\n        const { rangeBegin } = fileLoader;\n        if (rangeBegin && rangeBegin > 0) {\n            let pos = 0;\n            for (let i = fileInfos.length - 1; i >= 0; i--) {\n                const { size } = fileInfos[i];\n                if (size === -1) {\n                    // 文件长度未知，停止排除\n                    break;\n                }\n                if (pos + size > rangeBegin) {\n                    // 当前文件多余部分由 FileLoader 丢弃\n                    if (pos) {\n                        headers.set('content-range', `bytes ${pos}-`);\n                    }\n                    break;\n                }\n                fileInfos.pop();\n                pos += size;\n            }\n        }\n        const cdn = new FreeCDN();\n        cdn.manifest = fileLoader.cdn.manifest;\n        cdn.weightConf = fileLoader.cdn.weightConf;\n        cdn.isSubReq = true;\n        let reader;\n        let controller;\n        const openNextFile = async () => {\n            const info = fileInfos.pop();\n            if (!info) {\n                controller.close();\n                return false;\n            }\n            this.abortCtrl = new AbortController();\n            try {\n                const res = await cdn.fetch(info.url, {\n                    signal: this.abortCtrl.signal,\n                });\n                reader = res.body.getReader();\n            }\n            catch (err) {\n                controller.error(err);\n                return false;\n            }\n            return true;\n        };\n        const readNextChunk = async () => {\n            let buf;\n            try {\n                const { value } = await reader.read();\n                buf = value;\n            }\n            catch (err) {\n                controller.error(err);\n                return;\n            }\n            if (buf) {\n                controller.enqueue(buf);\n            }\n            else {\n                if (await openNextFile()) {\n                    await readNextChunk();\n                }\n            }\n        };\n        const stream = new ReadableStream({\n            async start(c) {\n                controller = c;\n                await openNextFile();\n            },\n            pull: readNextChunk,\n        });\n        return new Response(stream, { headers });\n    }\n    onAbort(reason) {\n        if (this.abortCtrl) {\n            this.abortCtrl.abort(reason);\n            this.abortCtrl = undefined;\n        }\n    }\n}\nclass ParamData extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onRequest() {\n        return new Response(this.bytes);\n    }\n}\nParamData.reuse = true;\nclass ParamExpires extends ParamBase {\n    constructor(seconds) {\n        super();\n        this.seconds = seconds;\n    }\n    static parseConf(conf) {\n        const time = parseTime(conf);\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        const seconds = time / 1000 | 0;\n        return [seconds];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        // 过期时间不小于实际值，防止经常变化的资源无法及时更新\n        const rawMaxAge = rawRes._maxage;\n        const maxAge = rawMaxAge < this.seconds ? rawMaxAge : this.seconds;\n        resArgs.headers.append('cache-control', 'max-age=' + maxAge);\n    }\n}\nParamExpires.reuse = true;\nclass ParamHash extends ParamBase {\n    constructor(blkLen, hashBins) {\n        super();\n        this.blkLen = blkLen;\n        this.hashBins = hashBins;\n        this.reader = new Reader();\n        this.hasData = false;\n    }\n    static parseConf(conf) {\n        // conf format:\n        // [blksize;]hash1,hash2,...\n        let blkLen = 1e9;\n        let hashes = conf;\n        const pos = conf.indexOf(';');\n        if (pos > 0) {\n            const blkLenStr = conf.substring(0, pos);\n            hashes = conf.substring(pos + 1);\n            blkLen = parseByteUnit(blkLenStr);\n            if (isNaN(blkLen)) {\n                return 'invalid block length';\n            }\n        }\n        const hashBins = [];\n        const hashB64s = hashes.split(',');\n        // 倒序存储，之后 pop 取出\n        for (let i = hashB64s.length - 1; i !== -1; i--) {\n            const bin = base64Decode(hashB64s[i]);\n            if (!bin || bin.length !== 32 /* SHA256_BIN */) {\n                return 'invalid block hash';\n            }\n            hashBins.push(bin);\n        }\n        return [blkLen, hashBins];\n    }\n    onData(chunk) {\n        this.hasData = true;\n        this.reader.feed(chunk);\n        if (this.reader.availLen > 52428800 /* MAX_QUEUE */) {\n            throw new ParamError('max queue length exceeded');\n        }\n        if (this.reader.availLen < this.blkLen) {\n            return EMPTY_BUF;\n        }\n        return this.pull(this.reader.availLen % this.blkLen);\n    }\n    async onEnd(chunk) {\n        if (chunk.length > 0) {\n            this.reader.feed(chunk);\n        }\n        if (this.reader.availLen === 0) {\n            if (!this.hasData) {\n                await this.verify(EMPTY_BUF);\n            }\n            return EMPTY_BUF;\n        }\n        return this.pull(0);\n    }\n    async pull(remain) {\n        const blks = this.reader.readBytesSync(this.reader.availLen - remain);\n        for (let p = 0; p < blks.length; p += this.blkLen) {\n            const blk = blks.subarray(p, p + this.blkLen);\n            await this.verify(blk);\n        }\n        return blks;\n    }\n    async verify(blk) {\n        const hashExp = this.hashBins.pop();\n        if (!hashExp) {\n            throw new ParamError('missing hash');\n        }\n        const hashGot = await sha256(blk);\n        if (!isArrayEqual(hashExp, hashGot)) {\n            const exp = base64Encode(hashExp);\n            const got = base64Encode(hashGot);\n            throw new ParamError(`hash incorrect. expected: ${exp}, but got: ${got}`);\n        }\n    }\n}\nclass ParamHeaders extends ParamBase {\n    constructor(headers, preserveAll) {\n        super();\n        this.headers = headers;\n        this.preserveAll = preserveAll;\n    }\n    static parseConf(conf) {\n        return ParamReqHeaders.parse(conf);\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        if (this.preserveAll) {\n            for (const [k, v] of rawRes.headers) {\n                resArgs.headers.set(k, v);\n            }\n            for (const [k, v] of this.headers) {\n                resArgs.headers.set(k, v);\n            }\n            return;\n        }\n        for (const [k, v] of this.headers) {\n            if (v === '') {\n                // preserve\n                const rawVal = rawRes.headers.get(k);\n                if (rawVal !== null) {\n                    resArgs.headers.set(k, rawVal);\n                }\n            }\n            else {\n                // add\n                resArgs.headers.set(k, v);\n            }\n        }\n    }\n}\nParamHeaders.reuse = true;\nclass ParamOpenTimeout extends ParamBase {\n    constructor(time) {\n        super();\n        this.time = time;\n        this.tid = 0;\n    }\n    static parseConf(conf) {\n        const time = parseTime(conf);\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        return [time];\n    }\n    onRequest(reqArgs, fileLoader) {\n        this.tid = setTimeout(() => {\n            const delay = Math.max(this.time, 5000);\n            fileLoader.loadNextUrl(delay);\n        }, this.time);\n    }\n    onResponse() {\n        this.stopTimer();\n    }\n    onError() {\n        this.stopTimer();\n    }\n    onAbort() {\n        this.stopTimer();\n    }\n    stopTimer() {\n        if (this.tid > 0) {\n            clearTimeout(this.tid);\n            this.tid = 0;\n        }\n    }\n}\nclass ParamPos extends ParamBase {\n    constructor(remain) {\n        super();\n        this.remain = remain;\n    }\n    static parseConf(conf) {\n        const pos = parseByteUnit(conf);\n        if (isNaN(pos)) {\n            return 'invalid byte format';\n        }\n        if (pos === 0) {\n            return;\n        }\n        return [pos];\n    }\n    onResponse(resArgs) {\n        if (resArgs.contentLen >= 0) {\n            if ((resArgs.contentLen -= this.remain) < 0) {\n                resArgs.contentLen = 0;\n            }\n        }\n    }\n    onData(chunk) {\n        if (this.remain <= 0) {\n            return chunk;\n        }\n        const remain = (this.remain -= chunk.length);\n        if (remain >= 0) {\n            return EMPTY_BUF;\n        }\n        // if remain < 0, return last -remain bytes\n        return chunk.subarray(remain);\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nclass ParamPrefix extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n        this.done = false;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onResponse(resArgs) {\n        if (resArgs.contentLen >= 0) {\n            resArgs.contentLen += this.bytes.length;\n        }\n    }\n    onData(chunk) {\n        if (this.done) {\n            return chunk;\n        }\n        this.done = true;\n        return concatBufs([this.bytes, chunk]);\n    }\n    onEnd(chunk) {\n        // for empty file\n        return this.onData(chunk);\n    }\n}\nclass ParamRecvTimeout extends ParamBase {\n    constructor(bytes, time) {\n        super();\n        this.bytes = bytes;\n        this.time = time;\n        this.tid = 0;\n        this.sum = 0;\n    }\n    static parseConf(conf) {\n        const [n, t] = conf.split('/');\n        const bytes = parseByteUnit(n);\n        const time = parseTime(t);\n        if (isNaN(bytes)) {\n            return 'invalid byte format';\n        }\n        if (isNaN(time)) {\n            return 'invalid time format';\n        }\n        return [bytes, time];\n    }\n    onRequest(reqArgs, fileLoader) {\n        this.fileLoader = fileLoader;\n    }\n    onResponse() {\n        this.tid = setInterval(() => {\n            if (this.sum <= this.bytes) {\n                this.stopTimer();\n                this.fileLoader.loadNextUrl();\n            }\n            this.sum = 0;\n        }, this.time);\n    }\n    onData(chunk) {\n        this.sum += chunk.length;\n        return chunk;\n    }\n    onEnd(chunk) {\n        this.stopTimer();\n        return chunk;\n    }\n    onError() {\n        this.stopTimer();\n    }\n    onAbort() {\n        this.stopTimer();\n    }\n    stopTimer() {\n        if (this.tid > 0) {\n            clearInterval(this.tid);\n            this.tid = 0;\n        }\n    }\n}\nconst REG_REFFERER_POLICY = /^(?:no-referrer|unsafe-url|origin|same-origin|strict-origin|no-referrer-when-downgrade|origin-when-cross-origin|strict-origin-when-cross-origin)$/;\nclass ParamReferrerPolicy extends ParamBase {\n    constructor(policy) {\n        super();\n        this.policy = policy;\n    }\n    static parseConf(conf) {\n        if (conf === 'raw') {\n            return [''];\n        }\n        if (!REG_REFFERER_POLICY.test(conf)) {\n            return 'invalid value';\n        }\n        return [conf];\n    }\n    onRequest(reqArgs, fileLoader) {\n        reqArgs.referrerPolicy = this.policy || fileLoader.rawReq.referrerPolicy;\n    }\n}\nParamReferrerPolicy.reuse = true;\nclass ParamReqHeaders extends ParamBase {\n    constructor(headers, preserveAll) {\n        super();\n        this.headers = headers;\n        this.preserveAll = preserveAll;\n    }\n    static parse(conf) {\n        const headers = [];\n        let preserveAll = false;\n        // {\"header-to-preserve\": \"\", \"header-to-add\": \"val\"}\n        const map = parseJson(conf);\n        if (typeof map !== 'object') {\n            return 'invalid format';\n        }\n        for (const [k, v] of Object.entries(map)) {\n            if (k === '*') {\n                preserveAll = true;\n            }\n            else {\n                headers.push([k, v + '']);\n            }\n        }\n        return [headers, preserveAll];\n    }\n    static parseConf(conf) {\n        return this.parse(conf);\n    }\n    onRequest(reqArgs, fileLoader) {\n        const { rawReq } = fileLoader;\n        if (this.preserveAll) {\n            for (const [k, v] of rawReq.headers) {\n                reqArgs.headers.set(k, v);\n            }\n            for (const [k, v] of this.headers) {\n                reqArgs.headers.set(k, v);\n            }\n            return;\n        }\n        for (const [k, v] of this.headers) {\n            if (k === 'referer') {\n                reqArgs.referrer = v || rawReq.referrer;\n                continue;\n            }\n            if (v === '') {\n                // preserve\n                const rawVal = rawReq.headers.get(k);\n                if (rawVal !== null) {\n                    reqArgs.headers.set(k, rawVal);\n                }\n            }\n            else {\n                // add\n                reqArgs.headers.set(k, v);\n            }\n        }\n    }\n}\nParamReqHeaders.reuse = true;\nclass ParamSize extends ParamBase {\n    constructor(remain) {\n        super();\n        this.remain = remain;\n    }\n    static parseConf(conf) {\n        const size = parseByteUnit(conf);\n        if (isNaN(size)) {\n            return 'invalid byte format';\n        }\n        return [size];\n    }\n    onResponse(resArgs) {\n        resArgs.contentLen = this.remain;\n    }\n    onData(chunk) {\n        if (this.remain <= 0) {\n            return EMPTY_BUF;\n        }\n        const remain = (this.remain -= chunk.length);\n        if (remain >= 0) {\n            return chunk;\n        }\n        // remain < 0, return [0, END + remain)\n        return chunk.subarray(0, remain);\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nclass ParamStream extends ParamBase {\n    constructor() {\n        super();\n        this.queueArr = [];\n        this.queueLen = 0;\n    }\n    static parseConf(conf) {\n        if (conf === 'on') {\n            // default\n            return;\n        }\n        if (conf === 'off') {\n            return [];\n        }\n        return 'invalid value';\n    }\n    onData(chunk) {\n        this.queueLen += chunk.length;\n        if (this.queueLen > 52428800 /* MAX_QUEUE */) {\n            throw new ParamError('max queue length exceeded');\n        }\n        this.queueArr.push(chunk);\n        return EMPTY_BUF;\n    }\n    onEnd(chunk) {\n        if (chunk.length > 0) {\n            // unlikely\n            this.onData(chunk);\n        }\n        return concatBufs(this.queueArr, this.queueLen);\n    }\n}\nclass ParamSuffix extends ParamBase {\n    constructor(bytes) {\n        super();\n        this.bytes = bytes;\n    }\n    static parseConf(conf) {\n        const bytes = parseStrOrB64(conf);\n        if (!bytes) {\n            return 'invalid format';\n        }\n        return [bytes];\n    }\n    onResponse(resArgs) {\n        if (resArgs.contentLen >= 0) {\n            resArgs.contentLen += this.bytes.length;\n        }\n    }\n    onEnd(chunk) {\n        if (chunk.length === 0) {\n            return this.bytes;\n        }\n        return concatBufs([chunk, this.bytes]);\n    }\n}\nParamSuffix.reuse = true;\nclass ParamValidStatus extends ParamBase {\n    constructor(codes) {\n        super();\n        this.codes = codes;\n    }\n    static parseConf(conf) {\n        if (conf === '*') {\n            return;\n        }\n        const codes = conf.split(',').map(Number);\n        return [codes];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        if (!this.codes.includes(rawRes.status)) {\n            throw new ParamError('invalid http status: ' + rawRes.status);\n        }\n    }\n}\nParamValidStatus.reuse = true;\nclass ParamXor extends ParamBase {\n    constructor(key) {\n        super();\n        this.key = key;\n    }\n    static parseConf(conf) {\n        const key = +conf >>> 0;\n        if (key > 255) {\n            return 'invalid value';\n        }\n        return [key];\n    }\n    onData(chunk) {\n        // TODO: u32 optimize\n        for (let i = 0; i < chunk.length; i++) {\n            chunk[i] ^= this.key;\n        }\n        return chunk;\n    }\n    onEnd(chunk) {\n        return this.onData(chunk);\n    }\n}\nParamXor.reuse = true;\nconst MIME_DATA = 'application/andrew-inset:ez;application/applixware:aw;application/atom+xml:atom;application/atomcat+xml:atomcat;application/atomdeleted+xml:atomdeleted;application/atomsvc+xml:atomsvc;application/atsc-dwd+xml:dwd;application/atsc-held+xml:held;application/atsc-rsat+xml:rsat;application/bdoc:bdoc;application/calendar+xml:xcs;application/ccxml+xml:ccxml;application/cdfx+xml:cdfx;application/cdmi-capability:cdmia;application/cdmi-container:cdmic;application/cdmi-domain:cdmid;application/cdmi-object:cdmio;application/cdmi-queue:cdmiq;application/cu-seeme:cu;application/dash+xml:mpd;application/davmount+xml:davmount;application/docbook+xml:dbk;application/dssc+der:dssc;application/dssc+xml:xdssc;application/ecmascript:ecma,es;application/emma+xml:emma;application/emotionml+xml:emotionml;application/epub+zip:epub;application/exi:exi;application/fdt+xml:fdt;application/font-tdpfr:pfr;application/geo+json:geojson;application/gml+xml:gml;application/gpx+xml:gpx;application/gxf:gxf;application/gzip:gz;application/hjson:hjson;application/hyperstudio:stk;application/inkml+xml:ink,inkml;application/ipfix:ipfix;application/its+xml:its;application/java-archive:jar,war,ear;application/java-serialized-object:ser;application/java-vm:class;application/javascript:js,mjs;application/json:json,map;application/json5:json5;application/jsonml+json:jsonml;application/ld+json:jsonld;application/lgr+xml:lgr;application/lost+xml:lostxml;application/mac-binhex40:hqx;application/mac-compactpro:cpt;application/mads+xml:mads;application/manifest+json:webmanifest;application/marc:mrc;application/marcxml+xml:mrcx;application/mathematica:ma,nb,mb;application/mathml+xml:mathml;application/mbox:mbox;application/mediaservercontrol+xml:mscml;application/metalink+xml:metalink;application/metalink4+xml:meta4;application/mets+xml:mets;application/mmt-aei+xml:maei;application/mmt-usd+xml:musd;application/mods+xml:mods;application/mp21:m21,mp21;application/mp4:mp4s,m4p;application/mrb-consumer+xml:xdf;application/mrb-publish+xml:xdf;application/msword:doc,dot;application/mxf:mxf;application/n-quads:nq;application/n-triples:nt;application/node:cjs;application/octet-stream:bin,dms,lrf,mar,so,dist,distz,pkg,bpk,dump,elc,deploy,exe,dll,deb,dmg,iso,img,msi,msp,msm,buffer;application/oda:oda;application/oebps-package+xml:opf;application/ogg:ogx;application/omdoc+xml:omdoc;application/onenote:onetoc,onetoc2,onetmp,onepkg;application/oxps:oxps;application/p2p-overlay+xml:relo;application/patch-ops-error+xml:xer;application/pdf:pdf;application/pgp-encrypted:pgp;application/pgp-signature:asc,sig;application/pics-rules:prf;application/pkcs10:p10;application/pkcs7-mime:p7m,p7c;application/pkcs7-signature:p7s;application/pkcs8:p8;application/pkix-attr-cert:ac;application/pkix-cert:cer;application/pkix-crl:crl;application/pkix-pkipath:pkipath;application/pkixcmp:pki;application/pls+xml:pls;application/postscript:ai,eps,ps;application/provenance+xml:provx;application/pskc+xml:pskcxml;application/raml+yaml:raml;application/rdf+xml:rdf,owl;application/reginfo+xml:rif;application/relax-ng-compact-syntax:rnc;application/resource-lists+xml:rl;application/resource-lists-diff+xml:rld;application/rls-services+xml:rs;application/route-apd+xml:rapd;application/route-s-tsid+xml:sls;application/route-usd+xml:rusd;application/rpki-ghostbusters:gbr;application/rpki-manifest:mft;application/rpki-roa:roa;application/rsd+xml:rsd;application/rss+xml:rss;application/rtf:rtf;application/sbml+xml:sbml;application/scvp-cv-request:scq;application/scvp-cv-response:scs;application/scvp-vp-request:spq;application/scvp-vp-response:spp;application/sdp:sdp;application/senml+xml:senmlx;application/sensml+xml:sensmlx;application/set-payment-initiation:setpay;application/set-registration-initiation:setreg;application/shf+xml:shf;application/sieve:siv,sieve;application/smil+xml:smi,smil;application/sparql-query:rq;application/sparql-results+xml:srx;application/srgs:gram;application/srgs+xml:grxml;application/sru+xml:sru;application/ssdl+xml:ssdl;application/ssml+xml:ssml;application/swid+xml:swidtag;application/tei+xml:tei,teicorpus;application/thraud+xml:tfi;application/timestamped-data:tsd;application/toml:toml;application/ttml+xml:ttml;application/ubjson:ubj;application/urc-ressheet+xml:rsheet;application/urc-targetdesc+xml:td;application/voicexml+xml:vxml;application/wasm:wasm;application/widget:wgt;application/winhlp:hlp;application/wsdl+xml:wsdl;application/wspolicy+xml:wspolicy;application/xaml+xml:xaml;application/xcap-att+xml:xav;application/xcap-caps+xml:xca;application/xcap-diff+xml:xdf;application/xcap-el+xml:xel;application/xcap-error+xml:xer;application/xcap-ns+xml:xns;application/xenc+xml:xenc;application/xhtml+xml:xhtml,xht;application/xliff+xml:xlf;application/xml:xml,xsl,xsd,rng;application/xml-dtd:dtd;application/xop+xml:xop;application/xproc+xml:xpl;application/xslt+xml:xsl,xslt;application/xspf+xml:xspf;application/xv+xml:mxml,xhvml,xvml,xvm;application/yang:yang;application/yin+xml:yin;application/zip:zip;audio/3gpp:3gpp;audio/adpcm:adp;audio/amr:amr;audio/basic:au,snd;audio/midi:mid,midi,kar,rmi;audio/mobile-xmf:mxmf;audio/mp3:mp3;audio/mp4:m4a,mp4a;audio/mpeg:mpga,mp2,mp2a,mp3,m2a,m3a;audio/ogg:oga,ogg,spx,opus;audio/s3m:s3m;audio/silk:sil;audio/wav:wav;audio/wave:wav;audio/webm:weba;audio/xm:xm;font/collection:ttc;font/otf:otf;font/ttf:ttf;font/woff:woff;font/woff2:woff2;image/aces:exr;image/apng:apng;image/avif:avif;image/bmp:bmp;image/cgm:cgm;image/dicom-rle:drle;image/emf:emf;image/fits:fits;image/g3fax:g3;image/gif:gif;image/heic:heic;image/heic-sequence:heics;image/heif:heif;image/heif-sequence:heifs;image/hej2k:hej2;image/hsj2:hsj2;image/ief:ief;image/jls:jls;image/jp2:jp2,jpg2;image/jpeg:jpeg,jpg,jpe;image/jph:jph;image/jphc:jhc;image/jpm:jpm;image/jpx:jpx,jpf;image/jxr:jxr;image/jxra:jxra;image/jxrs:jxrs;image/jxs:jxs;image/jxsc:jxsc;image/jxsi:jxsi;image/jxss:jxss;image/ktx:ktx;image/ktx2:ktx2;image/png:png;image/sgi:sgi;image/svg+xml:svg,svgz;image/t38:t38;image/tiff:tif,tiff;image/tiff-fx:tfx;image/webp:webp;image/wmf:wmf;message/disposition-notification:disposition-notification;message/global:u8msg;message/global-delivery-status:u8dsn;message/global-disposition-notification:u8mdn;message/global-headers:u8hdr;message/rfc822:eml,mime;model/3mf:3mf;model/gltf+json:gltf;model/gltf-binary:glb;model/iges:igs,iges;model/mesh:msh,mesh,silo;model/mtl:mtl;model/obj:obj;model/stl:stl;model/vrml:wrl,vrml;model/x3d+binary:x3db,x3dbz;model/x3d+fastinfoset:x3db;model/x3d+vrml:x3dv,x3dvz;model/x3d+xml:x3d,x3dz;model/x3d-vrml:x3dv;text/cache-manifest:appcache,manifest;text/calendar:ics,ifb;text/coffeescript:coffee,litcoffee;text/css:css;text/csv:csv;text/html:html,htm,shtml;text/jade:jade;text/jsx:jsx;text/less:less;text/markdown:markdown,md;text/mathml:mml;text/mdx:mdx;text/n3:n3;text/plain:txt,text,conf,def,list,log,in,ini;text/richtext:rtx;text/rtf:rtf;text/sgml:sgml,sgm;text/shex:shex;text/slim:slim,slm;text/spdx:spdx;text/stylus:stylus,styl;text/tab-separated-values:tsv;text/troff:t,tr,roff,man,me,ms;text/turtle:ttl;text/uri-list:uri,uris,urls;text/vcard:vcard;text/vtt:vtt;text/xml:xml;text/yaml:yaml,yml;video/3gpp:3gp,3gpp;video/3gpp2:3g2;video/h261:h261;video/h263:h263;video/h264:h264;video/iso.segment:m4s;video/jpeg:jpgv;video/jpm:jpm,jpgm;video/mj2:mj2,mjp2;video/mp2t:ts;video/mp4:mp4,mp4v,mpg4;video/mpeg:mpeg,mpg,mpe,m1v,m2v;video/ogg:ogv;video/quicktime:qt,mov;video/webm:webm';\nvar _a;\nclass ParamMime extends ParamBase {\n    constructor(mime) {\n        super();\n        this.mime = mime;\n    }\n    static parseConf(conf) {\n        if (conf === 'auto') {\n            // likely\n            return [''];\n        }\n        return [conf];\n    }\n    onResponse(resArgs, fileLoader, rawRes) {\n        let type;\n        if (this.mime === '') {\n            const url = fileLoader.getSourceUrl();\n            if (!url.includes('?')) {\n                const m = url.match(/\\.(\\w+)$/);\n                if (m) {\n                    const ext = m[1].toLowerCase();\n                    type = ParamMime.extTypeMap.get(ext);\n                }\n            }\n            if (!type) {\n                const rawType = rawRes.headers.get('content-type');\n                if (rawType) {\n                    type = getPair(rawType, ';')[0];\n                }\n                else {\n                    type = 'application/octet-stream';\n                }\n            }\n        }\n        else {\n            type = this.mime;\n        }\n        resArgs.headers.set('content-type', type);\n    }\n}\n_a = ParamMime;\nParamMime.reuse = true;\n(() => {\n    const map = new Map();\n    for (const item of MIME_DATA.split(';')) {\n        const [mime, exts] = getPair(item, ':');\n        for (const ext of exts.split(',')) {\n            map.set(ext, mime);\n        }\n    }\n    _a.extTypeMap = map;\n})();\nvar CacheManager;\n(function (CacheManager) {\n    let mCache;\n    // TODO: LRU\n    async function init() {\n        if (!mCache) {\n            mCache = await caches.open('.freecdn');\n        }\n    }\n    CacheManager.init = init;\n    async function findHash(hash) {\n        const res = await findCache('/' + hash);\n        if (!res) {\n            return;\n        }\n        const buf = await res.clone().arrayBuffer();\n        const bin = new Uint8Array(buf);\n        const hashGot = await sha256(bin);\n        const hashExp = base64Decode(hash);\n        if (!hashExp) {\n            return;\n        }\n        if (!isArrayEqual(hashGot, hashExp)) {\n            console.warn('[FreeCDN/CacheManager] bad cache:', hash);\n            delCache('/' + hash);\n            return;\n        }\n        return res;\n    }\n    CacheManager.findHash = findHash;\n    async function addHash(hash, res) {\n        await addCache('/' + hash, res);\n    }\n    CacheManager.addHash = addHash;\n    function findCache(reqInfo) {\n        return mCache.match(reqInfo);\n    }\n    CacheManager.findCache = findCache;\n    async function addCache(reqInfo, res) {\n        try {\n            await mCache.put(reqInfo, res);\n        }\n        catch {\n        }\n    }\n    CacheManager.addCache = addCache;\n    function delCache(reqInfo) {\n        return mCache.delete(reqInfo);\n    }\n    CacheManager.delCache = delCache;\n})(CacheManager || (CacheManager = {}));\nclass Database {\n    constructor(name) {\n        this.name = name;\n    }\n    open(opts) {\n        const s = promisex();\n        const req = indexedDB.open(this.name);\n        req.onsuccess = () => {\n            const idb = req.result;\n            this.db = idb;\n            idb.onclose = () => {\n                console.warn('[FreeCDN/Database] indexedDB disconnected, reopen...');\n                this.open(opts);\n            };\n            s.resolve();\n        };\n        req.onerror = (e) => {\n            console.warn('[FreeCDN/Database] indexedDB open error:', e);\n            s.reject(req.error);\n        };\n        req.onupgradeneeded = () => {\n            const idb = req.result;\n            for (const [k, v] of Object.entries(opts)) {\n                idb.createObjectStore(k, v);\n            }\n        };\n        return s;\n    }\n    close() {\n        this.db.close();\n    }\n    get(table, key) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readonly');\n        const req = obj.get(key);\n        req.onsuccess = () => {\n            s.resolve(req.result);\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    put(table, record) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readwrite');\n        const req = obj.put(record);\n        req.onsuccess = () => {\n            s.resolve();\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    delete(table, key) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readwrite');\n        const req = obj.delete(key);\n        req.onsuccess = () => {\n            s.resolve();\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    enum(table, callback, ...args) {\n        const s = promisex();\n        const obj = this.getStore(table, 'readonly');\n        const req = obj.openCursor(...args);\n        req.onsuccess = () => {\n            const { result } = req;\n            if (!result) {\n                s.resolve();\n                return;\n            }\n            const ret = callback(result.value);\n            if (ret !== false) {\n                result.continue();\n            }\n        };\n        req.onerror = () => {\n            s.reject(req.error);\n        };\n        return s;\n    }\n    getStore(table, mode) {\n        return this.db\n            .transaction(table, mode)\n            .objectStore(table);\n    }\n}\nvar Network;\n(function (Network) {\n    const mDatabase = new Database('.freecdn');\n    const mUrlInfoMap = new Map();\n    function addUrlInfo(url, status, expire) {\n        if (mUrlInfoMap.has(url)) {\n            return;\n        }\n        const info = { url, status, expire };\n        mUrlInfoMap.set(url, info);\n        mDatabase.put('cache', info);\n    }\n    class HostInfo {\n        constructor() {\n            this.lastDoneTime = 0;\n            this.lastErrTime = 0;\n            this.pending = 0;\n            // public protocol = 1\n            this.errNum = 0;\n            this.reqNum = 0;\n            this.reqTimeAvg = -1;\n            this.reqTimeSum = 0;\n            // public speedAvg = 0\n            // public speedSum = 0\n        }\n    }\n    const mHostInfoMap = new Map();\n    function getHostInfo(host) {\n        let info = mHostInfoMap.get(host);\n        if (!info) {\n            info = new HostInfo();\n            mHostInfoMap.set(host, info);\n        }\n        return info;\n    }\n    function getHostWeight(hostInfo, now) {\n        // TODO: ...\n        if (hostInfo.reqTimeAvg !== -1) {\n            const delayScore = 100 - hostInfo.reqTimeAvg * 0.2;\n            return Math.max(delayScore, 10);\n        }\n        return 50;\n    }\n    function getUrlWeight(url, now, hostWeightMap) {\n        const urlInfo = mUrlInfoMap.get(url);\n        if (urlInfo && urlInfo.expire < now) {\n            if (urlInfo.status !== 200) {\n                return -2;\n            }\n            // 该 URL 之前加载过\n            // expire 值越大，已过期的概率越小，权重越高\n            return 100 + urlInfo.expire;\n        }\n        // 当前站点默认权重 -1，低于免费站点，减少流量成本\n        if (url[0] === '/') {\n            return hostWeightMap.get(MY_HOST) ?? -1;\n        }\n        const host = getHostFromUrl(url);\n        const hostInfo = mHostInfoMap.get(host);\n        if (!hostInfo) {\n            return hostWeightMap.get(host) ?? 50;\n        }\n        return getHostWeight(hostInfo, now);\n    }\n    Network.getUrlWeight = getUrlWeight;\n    async function fetch(req) {\n        const host = getHostFromUrl(req.url);\n        const hostInfo = getHostInfo(host);\n        hostInfo.pending++;\n        const t0 = getTimeSec();\n        let res;\n        try {\n            res = await NATIVE_FETCH(req);\n        }\n        catch (err) {\n            parseFetchError(err, req, hostInfo, t0);\n            // throw err\n            res = new Response();\n        }\n        finally {\n            hostInfo.pending--;\n        }\n        const maxAge = parseMaxAge(res.headers, t0);\n        switch (res.status) {\n            case 200:\n                if (req.cache !== 'no-store') {\n                    if (maxAge > 60) {\n                        addUrlInfo(res.url, 200, t0 + maxAge);\n                    }\n                }\n                break;\n            case 404:\n                addUrlInfo(res.url, 404, t0 + maxAge);\n                break;\n        }\n        // 过期时间会在 expires 参数中会用到，避免重复分析\n        res._maxage = maxAge;\n        return res;\n    }\n    Network.fetch = fetch;\n    const REG_NET_ERR = /^Failed to fetch|^NetworkError|^Could not connect/;\n    function parseFetchError(err, req, hostInfo, t0) {\n        if (!navigator.onLine) {\n            return;\n        }\n        if (!REG_NET_ERR.test(err.message)) {\n            return;\n        }\n        if (req.cache === 'only-if-cached') {\n            return;\n        }\n        hostInfo.errNum++;\n        hostInfo.lastErrTime = t0;\n    }\n    function parseMaxAge(headers, t0) {\n        const cacheControl = headers.get('cache-control');\n        if (cacheControl !== null) {\n            if (cacheControl.includes('no-cache')) {\n                return 0;\n            }\n            const m = cacheControl.match(/max-age=\"?(\\d+)\"?/);\n            if (m) {\n                return +m[1];\n            }\n        }\n        const expires = headers.get('expires');\n        if (expires !== null) {\n            const t1 = Date.parse(expires) / 1000;\n            if (t1) {\n                return (t1 - t0) | 0;\n            }\n        }\n        return 300 /* DEFAULT_MAX_AGE */;\n    }\n    function parseEntries(list) {\n        const timeBase = performance.timeOrigin;\n        for (const record of list) {\n            const host = getHostFromUrl(record.name);\n            const info = getHostInfo(host);\n            info.reqNum++;\n            info.lastDoneTime = timeBase + record.responseEnd;\n            // time-allow-origin\n            if (record.responseStart > 0) {\n                const reqTime = record.responseStart - record.requestStart;\n                info.reqTimeSum += reqTime;\n                info.reqTimeAvg = info.reqTimeSum / info.reqNum;\n            }\n        }\n    }\n    async function init() {\n        await mDatabase.open({\n            'cache': {\n                keyPath: 'url'\n            },\n        });\n        const now = getTimeSec();\n        // 读取 URL 历史信息\n        await mDatabase.enum('cache', (item) => {\n            if (item.expire < now) {\n                mDatabase.delete('cache', item.url);\n                return;\n            }\n            mUrlInfoMap.set(item.url, item);\n        });\n        // 跟踪每个 URL 的性能指标\n        const entries = performance.getEntriesByType('resource');\n        parseEntries(entries);\n        const observer = new PerformanceObserver(entryList => {\n            const entries = entryList.getEntries();\n            parseEntries(entries);\n        });\n        observer.observe({\n            entryTypes: ['resource']\n        });\n    }\n    Network.init = init;\n    function parseWeightConf(manifest) {\n        const zone = navigator.language.toLowerCase();\n        const zone0 = zone.split('-')[0];\n        const weightParams = manifest.getParams('@weight ' + zone) ||\n            manifest.getParams('@weight ' + zone0) ||\n            manifest.getParams('@weight');\n        if (!weightParams) {\n            const obj = ZONE_HOST_SCORE[zone] || ZONE_HOST_SCORE['*'];\n            return new Map(Object.entries(obj));\n        }\n        const map = new Map();\n        for (const [k, v] of weightParams) {\n            const num = +v;\n            if (isNaN(num)) {\n                continue;\n            }\n            map.set(k, num);\n        }\n        return map;\n    }\n    Network.parseWeightConf = parseWeightConf;\n})(Network || (Network = {}));\nclass ReaderError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nclass Reader {\n    constructor() {\n        /*\n         * chunks:\n         * |-------------------------------------|\n         * | 0                 |  1  |  2  | ... |\n         * | used       : free | ... | ... | ... |\n         * |<- offset -> <------ availLen ------>|\n         */\n        this.chunks = [];\n        this.offset = 0;\n        this.availLen = 0;\n    }\n    async pull(len) {\n        do {\n            let buf;\n            try {\n                const { value } = await this.source.read();\n                buf = value;\n            }\n            catch (err) {\n                throw new ReaderError(err.message);\n            }\n            if (!buf) {\n                return false;\n            }\n            this.feed(buf);\n        } while (this.availLen < len);\n        return true;\n    }\n    /**\n     * @param chunk chunk.length > 0\n     */\n    feed(chunk) {\n        this.chunks.push(chunk);\n        this.availLen += chunk.length;\n    }\n    /**\n     * @param len len > 0 && len <= availLen\n     */\n    readBytesSync(len) {\n        this.availLen -= len;\n        let ret;\n        let pos = 0;\n        let i = 0;\n        if (this.offset) {\n            const buf = this.chunks[0];\n            const end = this.offset + len;\n            const slice = buf.subarray(this.offset, end);\n            if (end < buf.length) {\n                this.offset += len;\n                return slice;\n            }\n            this.offset = 0;\n            if (end === buf.length) {\n                this.chunks.shift();\n                return slice;\n            }\n            ret = new Uint8Array(len);\n            ret.set(slice, 0);\n            pos = slice.length;\n            i = 1;\n        }\n        else {\n            ret = new Uint8Array(len);\n        }\n        do {\n            const buf = this.chunks[i];\n            const end = pos + buf.length;\n            const exceed = end - len;\n            if (exceed > 0) {\n                const head = buf.subarray(0, -exceed);\n                ret.set(head, pos);\n                this.offset = head.length;\n                break;\n            }\n            ret.set(buf, pos);\n            pos = end;\n            i++;\n        } while (pos < len);\n        this.chunks.splice(0, i);\n        return ret;\n    }\n    async readBytesAsync(len) {\n        if (this.availLen < len) {\n            await this.pull(len);\n        }\n        return this.readBytesSync(len);\n    }\n    //\n    // 如果 chunk0 读完还有剩余，可直接读取，性能更高（大概率）\n    // 如果正好读完，或不够读取，则需额外操作\n    //\n    readU32Sync() {\n        let pos = this.offset;\n        let buf = this.chunks[0];\n        if (buf.length - pos > 4) {\n            this.offset += 4;\n            this.availLen -= 4;\n        }\n        else {\n            buf = this.readBytesSync(4);\n            pos = 0;\n        }\n        return (buf[pos + 3] << 24 |\n            buf[pos + 2] << 16 |\n            buf[pos + 1] << 8 |\n            buf[pos]) >>> 0;\n    }\n    readU16Sync() {\n        let pos = this.offset;\n        let buf = this.chunks[0];\n        if (buf.length - pos > 2) {\n            this.offset += 2;\n            this.availLen -= 2;\n        }\n        else {\n            buf = this.readBytesSync(2);\n            pos = 0;\n        }\n        return (buf[pos + 1] << 8 |\n            buf[pos]);\n    }\n    readU8Sync() {\n        let pos = this.offset;\n        let buf = this.chunks[0];\n        if (buf.length - pos > 1) {\n            this.offset += 1;\n            this.availLen -= 1;\n        }\n        else {\n            buf = this.readBytesSync(1);\n            pos = 0;\n        }\n        return buf[pos];\n    }\n    async readU32Async() {\n        if (this.availLen < 4) {\n            await this.pull(4);\n        }\n        return this.readU16Sync();\n    }\n    async readU16Async() {\n        if (this.availLen < 2) {\n            await this.pull(2);\n        }\n        return this.readU16Sync();\n    }\n    async readU8Async() {\n        if (this.availLen < 1) {\n            await this.pull(1);\n        }\n        return this.readU8Sync();\n    }\n    async findAsync(byte) {\n        if (this.offset) {\n            const pos = this.chunks[0].indexOf(byte, this.offset);\n            if (pos !== -1) {\n                return pos - this.offset;\n            }\n        }\n        let sum = this.offset;\n        let i = 0;\n        for (;;) {\n            let buf = this.chunks[i];\n            if (!buf) {\n                if (!await this.pull(1)) {\n                    break;\n                }\n                buf = this.chunks[i];\n            }\n            const pos = buf.indexOf(byte);\n            if (pos !== -1) {\n                return sum + pos;\n            }\n            sum += buf.length;\n            i++;\n        }\n        return -1;\n    }\n}\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER = new TextDecoder();\nfunction utf8ToBytes(str) {\n    return TEXT_ENCODER.encode(str);\n}\nfunction bytesToUtf8(bytes) {\n    return TEXT_DECODER.decode(bytes);\n}\nfunction bytesToAsc(bytes) {\n    return bytes.reduce((s, v) => s + String.fromCharCode(v), '');\n}\nfunction base64Encode(bytes) {\n    return btoa(bytesToAsc(bytes));\n}\nfunction base64Decode(str) {\n    try {\n        str = atob(str);\n    }\n    catch {\n        return;\n    }\n    const bin = new Uint8Array(str.length);\n    for (let i = 0; i < bin.length; i++) {\n        bin[i] = str.charCodeAt(i);\n    }\n    return bin;\n}\nfunction parseJson(str) {\n    try {\n        return JSON.parse(str);\n    }\n    catch {\n    }\n}\nfunction splitList(str) {\n    str = str.trim();\n    if (!str) {\n        return [];\n    }\n    return str.split(/\\s+/);\n}\nfunction parseStrOrB64(str) {\n    // json string\n    if (str[0] === '\"') {\n        str = parseJson(str);\n        if (str === undefined) {\n            return;\n        }\n        return utf8ToBytes(str);\n    }\n    // base64\n    return base64Decode(str);\n}\nconst TIME_UNIT = {\n    '': 1,\n    'ms': 1,\n    's': 1000,\n    'min': 1000 * 60,\n    'h': 1000 * 3600,\n    'd': 1000 * 3600 * 24,\n    'y': 1000 * 3600 * 24 * 365,\n};\nfunction parseTime(str) {\n    const m = str.match(/^([\\d.]{1,9})(y|d|h|min|s|ms|)$/);\n    if (!m) {\n        return NaN;\n    }\n    const [, num, unit] = m;\n    return +num * TIME_UNIT[unit];\n}\nfunction parseByteUnit(str) {\n    const m = str.match(/^([\\d.]{1,9})(k|K|M|G|)(i|)(b|B|)$/);\n    if (!m) {\n        return NaN;\n    }\n    const [, num, kMG, i, bB] = m;\n    const exponent = kMG === 'k' ? 1 :\n        kMG === 'K' ? 1 :\n            kMG === 'M' ? 2 :\n                kMG === 'G' ? 3 : 0;\n    const base = i ? 1024 : 1000;\n    const unit = bB === 'b' ? 8 : 1;\n    return +num * base ** exponent / unit;\n}\nfunction getTimeSec() {\n    return Date.now() / 1000 | 0;\n}\nfunction concatBufs(bufs, size = 0) {\n    if (size === 0) {\n        for (const v of bufs) {\n            size += v.length;\n        }\n    }\n    const ret = new Uint8Array(size);\n    let pos = 0;\n    for (const v of bufs) {\n        ret.set(v, pos);\n        pos += v.length;\n    }\n    return ret;\n}\nfunction isArrayEqual(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getPair(str, delim) {\n    const pos = str.indexOf(delim);\n    if (pos === -1) {\n        return [str];\n    }\n    return [\n        str.substring(0, pos),\n        str.substring(pos + delim.length)\n    ];\n}\nfunction mergeMap(dst, src) {\n    for (const [k, v] of src) {\n        dst.set(k, v);\n    }\n}\n/**\n * @param url absolute or relative url\n */\nfunction stripUrlQuery(url) {\n    const pos = url.indexOf('?');\n    if (pos === -1) {\n        return url;\n    }\n    return url.substring(0, pos);\n}\n/**\n * @param url absolute url\n */\nfunction getHostFromUrl(url) {\n    const m = url.match(/^https?:\\/\\/([^/]+)/);\n    return m[1];\n}\n/**\n * @param url absolute or relative url\n */\nfunction toRelUrl(url) {\n    if (url.startsWith(ROOT_PATH)) {\n        return url.substring(MY_ORIGIN.length);\n    }\n    return url;\n}\nasync function sha256(buf) {\n    const ret = await CRYPTO.digest('SHA-256', buf);\n    return new Uint8Array(ret);\n}\nconst ZONE_HOST_SCORE = {\n    'zh-cn': {\n        'ajax.cdnjs.com': 50,\n        'cdnjs.cloudflare.com': 50,\n        'cdn.jsdelivr.net': 80,\n        'raw.githubusercontent.com': 10,\n        'cdnjs.loli.net': 70,\n        'lib.baomitu.com': 80,\n        'lf6-cdn-tos.bytecdntp.com': 90,\n        'cdn.staticfile.org': 90,\n        'cdn.bootcss.com': 10,\n        'cdn.bootcdn.net': 80,\n        'unpkg.com': 50,\n        'g.alicdn.com': 90,\n        'pagecdn.io': 20,\n        'ajax.aspnetcdn.com': 60,\n        'ajax.googleapis.com': 10,\n        'code.jquery.com': 20,\n        'stackpath.bootstrapcdn.com': 30,\n        'maxcdn.bootstrapcdn.com': 30,\n        'cdn.datatables.net': 40,\n        'twemoji.maxcdn.com': 40,\n    },\n    '*': {\n        'ajax.cdnjs.com': 90,\n        'cdnjs.cloudflare.com': 90,\n        'cdn.jsdelivr.net': 40,\n        'raw.githubusercontent.com': 10,\n        'cdnjs.loli.net': 40,\n        'lib.baomitu.com': 20,\n        'lf6-cdn-tos.bytecdntp.com': 40,\n        'cdn.staticfile.org': 20,\n        'cdn.bootcss.com': 10,\n        'cdn.bootcdn.net': 20,\n        'unpkg.com': 40,\n        'g.alicdn.com': 30,\n        'pagecdn.io': 40,\n        'ajax.aspnetcdn.com': 70,\n        'ajax.googleapis.com': 90,\n        'code.jquery.com': 50,\n        'stackpath.bootstrapcdn.com': 40,\n        'maxcdn.bootstrapcdn.com': 50,\n        'cdn.datatables.net': 50,\n        'twemoji.maxcdn.com': 50,\n    },\n};\n\n//# sourceMappingURL=freecdn-main.js.map\n","/**\n * JS Hook Util\n * example: https://codepen.io/etherdream/pen/WNoQQbG?editors=0012\n */\nnamespace Hook {\n  /**\n   * hook function\n   */\n  export function func<\n    T, K extends keyof T,\n\n    // T[K] must be a function\n    F = T[K] extends (...args: infer P) => infer R\n      ? (this: T, ...args: P) => R\n      : never\n  >(\n    obj: T,\n    key: K,\n    factory: (oldFn: F) => F\n  ) {\n    const oldFn: F = obj[key] as any\n    if (!oldFn) {\n      return false\n    }\n    const newFn = factory(oldFn)\n    obj[key] = newFn as any\n    return true\n  }\n\n  /**\n   * hook property\n   */\n  export function prop<\n    T, K extends keyof T,\n\n    GETTER extends (this: T) => T[K],\n    SETTER extends (this: T, value: T[K]) => void,\n\n    GETTER_FACTORY extends (oldGetter: GETTER) => GETTER,\n    SETTER_FACTORY extends (oldSetter: SETTER) => SETTER,\n  >(\n    obj: T,\n    key: K,\n    getterFactory: GETTER_FACTORY | null,\n    setterFactory: SETTER_FACTORY | null,\n  ) {\n    const desc = Object.getOwnPropertyDescriptor(obj, key)\n    if (!desc) {\n      return false\n    }\n    if (getterFactory) {\n      func(desc, 'get', getterFactory)\n    }\n    if (setterFactory) {\n      func(desc, 'set', setterFactory)\n    }\n    Object.defineProperty(obj, key, desc)\n    return true\n  }\n}\n","declare const VER: string\ndeclare const RELEASE: never\nconst IS_DEBUG = typeof RELEASE === 'undefined'\n\n\nconst DEFAULT_PARAMS = `\n@__default__\n expires=30s\n mime=auto\n open_timeout=10s\n valid_status=200\n`\nconst DEFAULT_MANIFEST_PATH = '/freecdn-internal/freecdn-manifest.txt'\nconst MY_URL = location.href\nconst MY_HOST = location.host\nconst MY_ORIGIN = location.origin\nconst ROOT_PATH = MY_ORIGIN + '/'\n\nconst INTERNAL_DIR = 'freecdn-internal/' + (IS_DEBUG ? 'dev' : VER)\nconst INTERNAL_PATH = new URL(INTERNAL_DIR, ROOT_PATH).pathname\nconst REG_IMG_EXTS = /\\.(?:jpg|jpeg|png|apng|gif|ico|bmp)$/i\n\nconst enum LEN {\n  SHA256_BIN = 32,\n  SHA256_B64 = 44,\n  PUBKEY_B64 = 124,\n  MAX_QUEUE = 1024 * 1024 * 50,\n}\n\ntype params_t = ReadonlyMap<string, string>\n\nconst NATIVE_FETCH = fetch\nconst EMPTY_BUF = new Uint8Array(0)\n\nconst CRYPTO = crypto.subtle\n\n\nlet gInited: true | PromiseX\n\nasync function globalInit() {\n  if (gInited) {\n    return gInited\n  }\n  gInited = promisex()\n\n  await CacheManager.init()\n  await Network.init()\n  UrlConf.init()\n\n  gInited.resolve()\n  gInited = true\n}","interface RequestArgs extends RequestInit {\n  headers: Headers\n}\n\ninterface ResponseArgs extends ResponseInit {\n  headers: Headers\n  status: number\n  statusText: string\n  contentLen: number\n}\n\nclass ParamError extends Error {\n  public constructor(message: string) {\n    super(message)\n  }\n}\n\nabstract class ParamBase {\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) : may_async<Response | void> {\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) : void {\n  }\n\n  public onData(chunk: Uint8Array) : may_async<Uint8Array> {\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) : may_async<Uint8Array> {\n    return chunk\n  }\n\n  public onError(error: any) : void {\n  }\n\n  public onAbort(reason: any) : void {\n  }\n}\n\ninterface ParamSub {\n  new(...args: any[]) : ParamBase\n\n  reuse?: boolean\n\n  parseConf(conf: string) :\n    any[] |     // construct args\n    string |    // error info\n    undefined   // off\n\n  priority?: number\n}","namespace KeyManager {\n  let mKey: CryptoKey\n\n\n  export async function set(keyBase64: string) {\n    const keyBin = base64Decode(keyBase64)\n    if (!keyBin) {\n      return\n    }\n    mKey = await CRYPTO.importKey('spki', keyBin, {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    }, false, ['verify'])\n  }\n\n  export async function verify(data: Uint8Array) {\n    if (!mKey) {\n      return false\n    }\n    const linePos = data.lastIndexOf(10)  // 10 = '\\n'\n    const lineBin = data.subarray(linePos + 1)\n    const lineTxt = bytesToUtf8(lineBin)\n\n    const m = lineTxt.match(/# SIGN: ([A-Za-z0-9+/=]{88})$/)\n    if (!m) {\n      return false\n    }\n    const signTxt = m[1]\n    const signBin = base64Decode(signTxt)!\n    const dataBin = data.subarray(0, linePos)\n\n    return await CRYPTO.verify({\n      name: 'ECDSA',\n      hash: {\n        name: 'SHA-256'\n      },\n    }, mKey, signBin, dataBin)\n  }\n}","//\n// 匹配清单中的文件块。例如：\n//\n// (http://foo/path/to/file)\n//    ...\n// (/path/to/file)\n//    ...\n// (@config)\n//    ...\n// 其中 $0 为文件名，内容部分只匹配不捕获，之后通过 lastIndex 截取\n//\nconst REG_HEAD_LINE = /^(?:\\/|https?:|@).*/mg\n\n\nclass Manifest {\n  private readonly urlFileMap = new Map<string, FileConf>()\n  public globalParams!: params_t\n\n\n  public has(key: string) {\n    return this.urlFileMap.has(key)\n  }\n\n  public get(key: string) {\n    return this.urlFileMap.get(key)\n  }\n\n  public getParams(name: string) {\n    const fileConf = this.get(name)\n    if (fileConf) {\n      fileConf.parse()\n      return fileConf.params\n    }\n  }\n\n  public async parse(txt: string) {\n    this.parseFile(txt + DEFAULT_PARAMS)\n\n    const inc = this.urlFileMap.get('@include')\n    if (inc) {\n      const cdn = new FreeCDN()\n      cdn.manifest = this\n\n      const urls = inc.getLines()\n      const rets = urls.map(cdn.fetchText, cdn)\n      const txts = await Promise.all(rets)\n      txts.forEach(this.parseFile, this)\n    }\n  }\n\n  private parseFile(txt: string) {\n    // lazy parse\n    let name = ''\n    let last = 0\n\n    for (;;) {\n      const m = REG_HEAD_LINE.exec(txt)\n      if (last > 0) {\n        if (name[0] !== '@') {\n          name = toRelUrl(name)\n        }\n        const curr = m ? m.index : txt.length\n        const part = txt.substring(last, curr)\n        const conf = new FileConf(name, part)\n\n        this.urlFileMap.set(name, conf)\n      }\n      if (!m) {\n        break\n      }\n      name = m[0]\n      last = REG_HEAD_LINE.lastIndex\n    }\n\n    const m0 = this.getParams('@__default__')!\n    const m1 = this.getParams('@global')\n\n    this.globalParams = m1 ? new Map([...m0, ...m1]) : m0\n  }\n}\n","class UrlConf {\n  private static nameClassMap: {[name: string] : ParamSub}\n\n  public static init() {\n    // 为了让代码更简洁，这里没有逐一引用各个参数对应的文件\n    // 如果该列表定义在全局，会出现依赖顺序的问题\n    this.nameClassMap = {\n      // 参数优先级（越前面的参数优先执行）\n      'data': ParamData,\n      'bundle': ParamBundle,\n      'concat': ParamConcat,\n\n      'open_timeout': ParamOpenTimeout,\n      'recv_timeout': ParamRecvTimeout,\n      'referrer_policy': ParamReferrerPolicy,\n      'req_headers': ParamReqHeaders,\n      'valid_status': ParamValidStatus,\n\n      'headers': ParamHeaders,\n      'expires': ParamExpires,\n      'mime': ParamMime,\n      'charset': ParamCharset,\n\n      'pos': ParamPos,\n      'size': ParamSize,\n      'xor': ParamXor,\n      'br': ParamBr,\n\n      'prefix': ParamPrefix,\n      'suffix': ParamSuffix,\n      'hash': ParamHash,\n      'stream': ParamStream,\n    }\n    Object.values(this.nameClassMap).forEach((cls, i) => {\n      cls.priority = i\n    })\n  }\n\n  // 不带片段部分的 URL（可以是相对路径）\n  public readonly url: string | undefined\n\n  // URL 片段部分\n  public readonly frag: string | undefined\n\n\n  public constructor(url: string | undefined,\n    private readonly fileParams: params_t\n  ) {\n    if (url) {\n      [this.url, this.frag] = getPair(toRelUrl(url), '#')\n    }\n  }\n\n  public parse(manifest: Manifest) {\n    // TODO: cache result\n    const params = new Map<string, string>()\n\n    // 参数优先级: 全局参数 < 站点参数 < 文件参数 < URL 参数\n    mergeMap(params, manifest.globalParams)\n\n    // 站点参数\n    if (this.url) {\n      const host = this.url[0] === '/' ? MY_HOST : getHostFromUrl(this.url)\n      const hostParams = manifest.getParams('@host ' + host)\n      if (hostParams) {\n        mergeMap(params, hostParams)\n      }\n    }\n\n    // 文件参数\n    mergeMap(params, this.fileParams)\n\n    // URL 参数（定义在 # 后面）\n    if (this.frag) {\n      const urlParams = new URLSearchParams(this.frag)\n      mergeMap(params, urlParams)\n    }\n\n    const mods: ParamBase[] = []\n\n    for (const [k, v] of params) {\n      const cls = UrlConf.nameClassMap[k]\n      if (!cls) {\n        console.warn('[FreeCDN/UrlConf] unknown param:', k)\n        continue\n      }\n      const ret = cls.parseConf(v)\n      if (ret === undefined) {\n        continue\n      }\n      if (typeof ret === 'string') {\n        console.warn('[FreeCDN/UrlConf] parseConf failed. mod:', k, 'err:', ret, 'conf:', v)\n        continue\n      }\n      const obj = new cls(...ret)\n      mods.push(obj)\n    }\n\n    mods.sort((a, b) =>\n      ((a.constructor as ParamSub).priority!) -\n      ((b.constructor as ParamSub).priority!)\n    )\n    return mods\n  }\n}\n","class UrlLoader {\n  private abortCtrl: AbortController | undefined\n\n  private pauseSignal: PromiseX | undefined\n  private isFetchDone = false\n\n  public bytesRead = 0\n  public onResponse!: (args: ResponseArgs) => void\n  public onData!: (chunk: Uint8Array) => void\n  public onEnd!: () => void\n  public onError!: (err: Error) => void\n\n\n  public constructor(\n    public readonly url: string | undefined,\n    private readonly paramMods: ParamBase[]) {\n  }\n\n  public async load(fileLoader: FileLoader) {\n    let isNetErr = false\n    let err: any\n    try {\n      // 网络错误（包括 fetch 被终止产生的错误）\n      // 不同浏览器错误信息不同，因此不用 catch 判断，而是通过返回值\n      err = await this.loadUnsafe(fileLoader)\n      isNetErr = !!err\n    } catch (e) {\n      // 参数模块抛出的错误（也有可能是脚本错误）\n      // console.assert(e instanceof ParamError, e)\n      err = e\n    }\n\n    if (err) {\n      if (this.abortCtrl && !this.abortCtrl.signal.aborted) {\n        for (const mod of this.paramMods) {\n          mod.onError(err)\n        }\n        this.onError(err)\n\n        if (!isNetErr) {\n          this.abort(err)\n        }\n      }\n    }\n  }\n\n  private async loadUnsafe(fileLoader: FileLoader) {\n    const {rawReq} = fileLoader\n    const {method} = rawReq\n    const reqArgs: RequestArgs = {\n      method,\n      referrer: rawReq.referrer,\n      referrerPolicy: 'same-origin',\n      headers: new Headers(),\n    }\n\n    if (method === 'POST' || method === 'PUT') {\n      reqArgs.body = await rawReq.clone().arrayBuffer()\n    }\n\n    let res: Response | void\n\n    for (const mod of this.paramMods) {\n      // 可直接返回响应（例如 data 参数、bundle 参数）\n      const ret = mod.onRequest(reqArgs, fileLoader)\n      if (ret) {\n        res = isPromise(ret) ? await ret : ret\n        if (res) {\n          break\n        }\n      }\n    }\n\n    if (!res) {\n      if (!this.url) {\n        this.onError(Error('vURL no data'))\n        return\n      }\n      this.abortCtrl = new AbortController()\n      reqArgs.signal = this.abortCtrl.signal\n\n      const req = new Request(this.url, reqArgs)\n      try {\n        res = await Network.fetch(req)\n      } catch (err) {\n        return err\n      }\n    }\n    if (!res.body) {\n      return Error('cors error')\n    }\n\n    const resArgs: ResponseArgs = {\n      status: res.status,\n      statusText: res.statusText,\n      headers: new Headers(),\n      contentLen: -1,\n    }\n    if (!res.headers.has('content-encoding')) {\n      const contentLen = res.headers.get('content-length')\n      if (contentLen) {\n        resArgs.contentLen = +contentLen\n      }\n    }\n    for (const mod of this.paramMods) {\n      mod.onResponse(resArgs, fileLoader, res)\n    }\n\n    const contentRange = res.headers.get('content-range')\n    if (contentRange) {\n      const m = contentRange.match(/bytes (\\d+)-/i)\n      if (m) {\n        const rangeBegin = +m[1]\n        if (rangeBegin > 0) {\n          this.bytesRead = rangeBegin\n        }\n      }\n    }\n\n    if (resArgs.contentLen >= 0) {\n      resArgs.headers.set('content-length', resArgs.contentLen + '')\n    }\n    this.onResponse(resArgs)\n\n    const reader = res.body.getReader()\n    let buf: Uint8Array\n\n    READ: for (;;) {\n      try {\n        const {value} = await reader.read()\n        if (!value) {\n          break\n        }\n        buf = value\n      } catch (err) {\n        return err\n      }\n\n      for (const mod of this.paramMods) {\n        const ret = mod.onData(buf)\n        buf = isPromise(ret) ? await ret : ret\n        if (buf.length === 0) {\n          continue READ\n        }\n      }\n\n      if (buf.length > 0) {\n        this.pauseSignal && await this.pauseSignal\n        this.bytesRead += buf.length\n        this.onData(buf)\n      }\n    } // READ NEXT\n\n    this.isFetchDone = true\n    buf = EMPTY_BUF\n\n    for (const mod of this.paramMods) {\n      const ret = mod.onEnd(buf)\n      buf = isPromise(ret) ? await ret : ret\n    }\n\n    if (buf.length > 0) {\n      this.pauseSignal && await this.pauseSignal\n      this.bytesRead += buf.length\n      this.onData(buf)\n    }\n\n    this.onEnd()\n  }\n\n  public pause() {\n    this.pauseSignal = promisex()\n  }\n\n  public resume() {\n    this.pauseSignal!.resolve()\n    this.pauseSignal = undefined\n  }\n\n  public abort(reason: any) {\n    if (this.isFetchDone) {\n      return\n    }\n    this.abortCtrl?.abort()\n\n    for (const mod of this.paramMods) {\n      mod.onAbort(reason)\n    }\n  }\n}\n","// 匹配缩进开头的行，捕获 trim 后的内容（排除 `#` 注释行）\nconst REG_SUB_LINE = /^\\s+([^#\\s].+?)\\s*$/mg\n\n\nclass FileConf {\n  public urlConfs!: readonly UrlConf[]\n  public params!: params_t\n\n\n  public constructor(\n    public readonly name: string,\n    private text: string\n  ) {\n  }\n\n  public getLines() {\n    const lines: string[] = []\n    for (;;) {\n      const m = REG_SUB_LINE.exec(this.text)\n      if (!m) {\n        break\n      }\n      lines.push(m[1])\n    }\n    this.text = ''\n    return lines\n  }\n\n  public parse() {\n    if (this.text === '') {\n      return\n    }\n    const urlConfs: UrlConf[] = []\n    const params = new Map<string, string>()\n\n    for (const line of this.getLines()) {\n      if (/^https?:|^\\//.test(line)) {\n        const urlConf = new UrlConf(line, params)\n        urlConfs.push(urlConf)\n      } else {\n        const [key, val] = getPair(line, '=')\n        if (val === undefined) {\n          console.warn('[FreeCDN/FileConf] missing param value:', line)\n          continue\n        }\n        params.set(key, val)\n      }\n    }\n    this.params = params\n    this.urlConfs = urlConfs\n  }\n}\n","const FILE_BACKUP_PARAMS = [\n  'open_timeout',\n  'recv_timeout',\n  'hash',\n  'req_headers',\n  'valid_status',\n]\n\nclass FileLoaderError extends Error {\n  public constructor(message: string) {\n    super(message)\n  }\n  public urlErrs!: {url: string, err: Error}[]\n}\n\n\nclass FileLoader {\n  private readonly urlConfs: UrlConf[]\n  private readonly urlLoaderSet = new Set<UrlLoader>()\n\n  private vUrlConf: UrlConf | undefined\n\n  private isPaused = false\n  private isAborted = false\n  private delayTid = 0\n  private urlErrs: {url: string, err: Error}[] = []\n\n  public readonly hasRange: boolean = false\n  public readonly rangeBegin: number | undefined\n  public readonly rangeEnd: number | undefined\n  public readonly fileSize: number | undefined\n\n  private opened = false\n  private closed = false\n  public bytesRead = 0\n\n  public onOpen!: (args: ResponseArgs) => void\n  public onData!: (chunk: Uint8Array) => void\n  public onEnd!: () => void\n  public onError!: (err: FileLoaderError) => void\n\n\n  public constructor(\n    public readonly fileConf: FileConf,\n    public readonly rawReq: Request,\n    public readonly cdn: FreeCDN,\n    public range: string | null,\n    public suffix: string\n  ) {\n    const fileParams = fileConf.params\n\n    if (range) {\n      const r = this.parseReqRange(range)\n      if (r) {\n        [this.rangeBegin, this.rangeEnd] = r\n        this.hasRange = true\n        this.bytesRead = this.rangeBegin\n      }\n      const fileSize = fileParams.get('size')\n      if (fileSize) {\n        this.fileSize = +fileSize\n      }\n    }\n\n    if (fileParams.has('data') || fileParams.has('bundle') || fileParams.has('concat')) {\n      this.vUrlConf = new UrlConf(undefined, fileParams)\n    }\n\n    // 原始 URL 作为后备资源\n    // 禁止修改原始内容，因此只保留白名单中的参数\n    const backupParams = new Map<string, string>()\n    for (const k of FILE_BACKUP_PARAMS) {\n      const v = fileParams.get(k)\n      if (v !== undefined) {\n        backupParams.set(k, v)\n      }\n    }\n    const backupUrlConf = new UrlConf(fileConf.name, backupParams)\n\n    this.urlConfs = fileConf.urlConfs.concat(backupUrlConf)\n  }\n\n  private parseReqRange(range: string) {\n    // 目前只考虑 `bytes=begin-end` 和 `bytes=begin-` 格式\n    const m = range.match(/bytes=(\\d+)-(\\d*)/i)\n    if (!m) {\n      return\n    }\n    const begin = +m[1]\n    const end = +m[2]   // +'' === 0\n\n    if (end !== 0 && end <= begin) {\n      return\n    }\n    return [begin, end]\n  }\n\n  private buildResRange(resArgs: ResponseArgs) {\n    const begin = this.rangeBegin!\n    let end = 0\n    if (this.rangeEnd) {\n      end = this.rangeEnd - 1\n    } else if (this.fileSize) {\n      end = this.fileSize - 1\n    } else if (resArgs.contentLen > 0) {\n      end = resArgs.contentLen\n    }\n    const val = 'bytes ' + begin + '-' + end + '/' + (this.fileSize || '*')\n\n    // TODO: status 416\n    resArgs.status = 206\n    resArgs.headers.set('content-range', val)\n\n    if (end > 0) {\n      const len = end - begin + 1\n      resArgs.headers.set('content-length', len + '')\n    }\n  }\n\n  public open() {\n    this.loadNextUrl()\n  }\n\n  public pause() {\n    if (this.isPaused) {\n      return\n    }\n    this.isPaused = true\n\n    // TODO: 进度落后的 Loader 无需暂停\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.pause()\n    }\n  }\n\n  public resume() {\n    if (!this.isPaused) {\n      return\n    }\n    this.isPaused = false\n\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.resume()\n    }\n  }\n\n  public abort(reason: any) {\n    if (this.isAborted) {\n      return\n    }\n    this.isAborted = true\n\n    for (const urlLoader of this.urlLoaderSet) {\n      urlLoader.abort(reason)\n    }\n    if (this.delayTid !== 0) {\n      clearTimeout(this.delayTid)\n    }\n  }\n\n  private getNextUrl() {\n    // 优先使用虚拟 URL（例如存在 data 参数时，无需使用真实 URL）\n    const {vUrlConf} = this\n    if (vUrlConf) {\n      this.vUrlConf = undefined\n      return {weight: 100, conf: vUrlConf}\n    }\n\n    const {urlConfs} = this\n    const lastIndex = urlConfs.length - 1\n    if (lastIndex === -1) {\n      return\n    }\n    const now = getTimeSec()\n    let weight = -10000\n    let index = 0\n\n    urlConfs.forEach((conf, i) => {\n      const w = Network.getUrlWeight(conf.url!, now, this.cdn.weightConf)\n      if (w > weight) {\n        weight = w\n        index = i\n      }\n    })\n\n    // 删除 urlConfs[index]\n    const conf = urlConfs[index]\n    urlConfs[index] = urlConfs[lastIndex]\n    urlConfs.length = lastIndex\n\n    return {weight, conf}\n  }\n\n  public loadNextUrl(delay = 0) {\n    const ret = this.getNextUrl()\n    if (!ret) {\n      if (this.urlLoaderSet.size === 0) {\n        const err = new FileLoaderError('failed to load: ' + this.getSourceUrl())\n        err.urlErrs = this.urlErrs\n        this.onError(err)\n      }\n      return\n    }\n    const {weight, conf} = ret\n\n    if (weight < 0 && delay > 0) {\n      // 并行加载多个备用 URL 时，推迟低权重的站点（例如当前站点、收费站点）\n      this.delayTid = setTimeout(() => {\n        this.delayTid = 0\n        this.createUrlLoader(conf)\n      }, delay)\n      return\n    }\n    this.createUrlLoader(conf)\n  }\n\n  public getSourceUrl() {\n    return this.fileConf.name + this.suffix\n  }\n\n  private getTargetUrl(url: string) {\n    if (url.endsWith('/')) {\n      return url + this.suffix\n    }\n    return url\n  }\n\n  private createUrlLoader(urlConf: UrlConf) {\n    const url = urlConf.url && this.getTargetUrl(urlConf.url)\n    const mods = urlConf.parse(this.cdn.manifest!)\n\n    const urlLoader = new UrlLoader(url, mods)\n    this.urlLoaderSet.add(urlLoader)\n\n    urlLoader.onData = (chunk) => {\n      if (this.closed) {\n        return\n      }\n      const add = urlLoader.bytesRead - this.bytesRead\n      if (add <= 0) {\n        // 当前节点的进度落后于总进度，丢弃收到的数据\n        return\n      }\n      if (add !== chunk.length) {\n        chunk = chunk.subarray(-add)\n      }\n      this.bytesRead = urlLoader.bytesRead\n\n      if (this.rangeEnd) {\n        const exceed = this.bytesRead - this.rangeEnd\n        if (exceed > 0) {\n          chunk = chunk.subarray(0, -exceed)\n          this.onData(chunk)\n          urlLoader.onEnd()\n          return\n        }\n      }\n      this.onData(chunk)\n    }\n\n    urlLoader.onEnd = () => {\n      if (this.closed) {\n        return\n      }\n      this.closed = true\n      this.onEnd()\n      this.abort('TASK_DONE')\n    }\n\n    urlLoader.onError = (err) => {\n      this.urlErrs.push({url: urlLoader.url || '', err})\n      this.urlLoaderSet.delete(urlLoader)\n      this.loadNextUrl()\n    }\n\n    urlLoader.onResponse = (resArgs) => {\n      if (this.opened) {\n        return\n      }\n      if (this.hasRange) {\n        this.buildResRange(resArgs)\n      }\n      this.opened = true\n      this.onOpen(resArgs)\n    }\n\n    urlLoader.load(this)\n  }\n}\n","const enum UpdaterConf {\n  FETCH_TIMEOUT = 1000 * 3,\n\n  DEFAULT_INTERVAL = 1000 * 300,\n  MIN_INTERVAL = 1000,\n\n  SET_SVC_DELAY = 1000 * 5,\n  WS_RETRY_DELAY = 1000 * 20,\n}\n\nconst EMPTY_PARAMS: params_t = new Map()\n\n\nclass Updater {\n  private readonly manifestUrl: string\n  private readonly urlWsMap = new Map<string, WebSocket>()\n  private readonly wsArgs: string = ''\n\n  private updateSignal: PromiseX<boolean> | undefined\n  private manifestHash = EMPTY_BUF\n  private pollingTimer = 0\n  private pollingInterval = UpdaterConf.DEFAULT_INTERVAL\n  private lastTime = 0\n  private setSvcTimer = 0\n  private backupUrls: string[] = []\n\n\n  public constructor(\n    manifestPath: string,\n    private onAvailable: (manifest: Manifest) => void\n  ) {\n    const url = new URL(manifestPath, MY_URL)\n    console.assert(url.host === MY_HOST)\n\n    const path = url.pathname + url.search\n    if (path !== DEFAULT_MANIFEST_PATH) {\n      this.wsArgs = '?manifest=' + encodeURIComponent(path)\n    }\n    this.manifestUrl = path\n  }\n\n  private async getManifestFromCache() {\n    const res = await CacheManager.findCache(this.manifestUrl)\n    if (!res) {\n      return\n    }\n    const buf = await res.arrayBuffer()\n    const bin = new Uint8Array(buf)\n\n    // 使用公钥校验缓存配置（缓存可被恶意脚本篡改）\n    if (!await KeyManager.verify(bin)) {\n      return\n    }\n    const txt = bytesToUtf8(bin)\n    const manifest = new Manifest()\n    await manifest.parse(txt)\n    return manifest\n  }\n\n  public async init() {\n    const manifest = await this.getManifestFromCache()\n    if (manifest) {\n      // 先使用本地缓存的配置\n      this.onAvailable(manifest)\n    }\n    await this.update()\n  }\n\n  public async update() {\n    if (this.updateSignal) {\n      return this.updateSignal\n    }\n    const now = Date.now()\n    if (now - this.lastTime < UpdaterConf.MIN_INTERVAL) {\n      return true\n    }\n    this.lastTime = now\n    this.updateSignal = promisex()\n\n    let ret = false\n    try {\n      ret = await this.updateUnsafe()\n    } catch (err) {\n      console.error('[FreeCDN/Updater] update err:', err)\n    }\n    this.updateSignal.resolve(ret)\n    this.updateSignal = undefined\n    return ret\n  }\n\n  private async updateUnsafe() {\n    // from current site\n    const data = await this.fetchManifest(this.manifestUrl)\n    if (data) {\n      await this.applyManifest(data)\n      return true\n    }\n    console.warn('[FreeCDN/Updater] failed to fetch 1st manifest:', this.manifestUrl)\n\n    if (this.backupUrls.length === 0) {\n      console.warn('[FreeCDN/Updater] no backup url')\n      return false\n    }\n\n    // from backup sites\n    for (const url of this.backupUrls) {\n      const data = await this.fetchManifest(url)\n      if (!data) {\n        console.warn('[FreeCDN/Updater] failed to fetch 3rd manifest:', url)\n        continue\n      }\n      if (!await KeyManager.verify(data)) {\n        console.warn('[FreeCDN/Updater] failed to verify 3rd manifest:', url)\n        continue\n      }\n      await this.applyManifest(data)\n      return true\n    }\n    console.warn('[FreeCDN/Updater] failed to reload')\n    return false\n  }\n\n  private async fetchManifest(url: string) {\n    const ctl = new AbortController()\n    const tid = setTimeout(() => {\n      ctl.abort()\n    }, UpdaterConf.FETCH_TIMEOUT)\n\n    const req = new Request(url, {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\n      cache: 'no-cache',\n      signal: ctl.signal,\n    })\n    try {\n      const res = await Network.fetch(req)\n      const bin = await res.arrayBuffer()\n      return new Uint8Array(bin)\n    } catch {\n    } finally {\n      clearTimeout(tid)\n    }\n  }\n\n  private async applyManifest(bytes: Uint8Array) {\n    const hash = await sha256(bytes)\n    if (isArrayEqual(this.manifestHash, hash)) {\n      return\n    }\n    this.manifestHash = hash\n\n    // 缓存最新的清单内容\n    const res = new Response(bytes)\n    res.headers.set('content-length', bytes.length + '')\n    CacheManager.addCache(this.manifestUrl, res)\n\n    const manifest = new Manifest()\n    const txt = bytesToUtf8(bytes)\n\n    await manifest.parse(txt)\n    this.onAvailable(manifest)\n  }\n\n  public applyConfs(params: params_t) {\n    this.backupUrls = this.parseBackupParam(params)\n\n    const interval = this.parseIntervalParam(params)\n    this.setPollingInterval(interval)\n\n    const svcUrls = this.parseServicesParam(params)\n    if (this.setSvcTimer > 0) {\n      clearTimeout(this.setSvcTimer)\n    }\n    // 延时开启，减少对业务的性能影响\n    this.setSvcTimer = setTimeout(() => {\n      this.setSvcTimer = 0\n      this.setServices(svcUrls)\n    }, UpdaterConf.SET_SVC_DELAY)\n  }\n\n  private parseBackupParam(params: params_t) {\n    const str = params.get('backup') || ''\n    return splitList(str)\n  }\n\n  private parseIntervalParam(params: params_t) {\n    const str = params.get('interval')\n    if (str) {\n      const num = parseTime(str)\n      if (!isNaN(num)) {\n        return num\n      }\n      console.warn('[FreeCDN/Updater] invalid interval:', str)\n    }\n    return UpdaterConf.DEFAULT_INTERVAL\n  }\n\n  private parseServicesParam(params: params_t) {\n    const str = params.get('services') || ''\n    return splitList(str)\n  }\n\n  private setPollingInterval(interval: number) {\n    if (this.pollingInterval === interval) {\n      return\n    }\n    this.pollingInterval === interval\n\n    if (this.pollingTimer) {\n      clearInterval(this.pollingTimer)\n    }\n    if (interval > 0) {\n      this.pollingTimer = setInterval(() => {\n        this.update()\n      }, interval)\n    }\n  }\n\n  private setServices(urls: string[]) {\n    for (const [url, ws] of this.urlWsMap) {\n      if (!urls.includes(url)) {\n        ws.onclose = null\n        ws.close()\n        this.urlWsMap.delete(url)\n      }\n    }\n    for (const url of urls) {\n      if (!this.urlWsMap.has(url)) {\n        this.createSvc(url)\n      }\n    }\n  }\n\n  private createSvc(url: string) {\n    const ws = new WebSocket(url + this.wsArgs)\n    ws.binaryType = 'arraybuffer'\n    ws.onmessage = (e) => {\n      const hashBin = new Uint8Array(e.data)\n      if (isArrayEqual(this.manifestHash, hashBin)) {\n        return\n      }\n      this.update()\n    }\n    ws.onclose = () => {\n      this.urlWsMap.delete(url)\n\n      setTimeout(() => {\n        this.createSvc(url)\n      }, UpdaterConf.WS_RETRY_DELAY)\n    }\n    this.urlWsMap.set(url, ws)\n  }\n}","///<reference path=\"global.ts\"/>\n///<reference path=\"param-base.ts\"/>\n///<reference path=\"key-manager.ts\"/>\n///<reference path=\"manifest.ts\"/>\n///<reference path=\"url-conf.ts\"/>\n///<reference path=\"url-loader.ts\"/>\n///<reference path=\"file-conf.ts\"/>\n///<reference path=\"file-loader.ts\"/>\n///<reference path=\"updater.ts\"/>\n\n\nclass FreeCDN {\n  public enableCacheStorage = true\n  public manifest: Manifest | undefined\n  public isSubReq = false\n\n  private readonly updater: Updater | undefined\n  public weightConf = new Map<string, number>()\n  private inited = false\n\n\n  public constructor(manifestUrl?: string) {\n    if (!manifestUrl) {\n      return\n    }\n    const updater = new Updater(manifestUrl, manifest => {\n      this.manifest = manifest\n\n      const updateConf = manifest.getParams('@update') || EMPTY_PARAMS\n      updater.applyConfs(updateConf)\n\n      // 权重参数\n      this.weightConf = Network.parseWeightConf(manifest)\n    })\n\n    this.updater = updater\n  }\n\n  public async fetch(input: RequestInfo, init?: RequestInit) {\n    const req = (input instanceof Request && !init)\n      ? input\n      : new Request(input, init)\n\n    if (!/^https?:/.test(req.url)) {\n      return NATIVE_FETCH(req)\n    }\n\n    const {manifest} = this\n    if (!manifest) {\n      return Network.fetch(req)\n    }\n\n    let fileConf: FileConf | undefined\n    let suffix = ''\n\n    FIND: for (;;) {\n      const urlObj = new URL(req.url)\n\n      // 同源 URL 使用相对路径，不同源使用完整路径（和清单中格式保持一致）\n      const originPrefix = urlObj.origin === MY_ORIGIN ? '' : urlObj.origin\n\n      // 带参数的 URL 尝试完整匹配\n      if (urlObj.search) {\n        fileConf = manifest.get(originPrefix + urlObj.pathname + urlObj.search)\n        if (fileConf) {\n          break\n        }\n      }\n\n      // 合并路径中连续的 `/`\n      const path = urlObj.pathname.replace(/\\/{2,}/g, '/')\n      const file = originPrefix + path\n\n      // 优先使用 avif、webp 版本\n      if (REG_IMG_EXTS.test(file) && req.mode !== 'cors' && !req.integrity) {\n        const accept = req.headers.get('accept') || ''\n        if (accept.includes('image/avif')) {\n          fileConf = manifest.get(file + '.avif')\n          if (fileConf) {\n            break\n          }\n        }\n        if (accept.includes('image/webp')) {\n          fileConf = manifest.get(file + '.webp')\n          if (fileConf) {\n            break\n          }\n        }\n      }\n\n      fileConf = manifest.get(file)\n      if (fileConf) {\n        break\n      }\n      if (file.endsWith('/')) {\n        fileConf = manifest.get(file + 'index.html')\n        if (fileConf) {\n          break\n        }\n      }\n      // 重定向到 `/` 结尾的路径\n      if (manifest.has(file + '/index.html')) {\n        return Response.redirect(file + '/')\n      }\n\n      // 目录匹配\n      // 尾部保存到 suffix 变量。例如访问 /path/to/file?a=1\n      // 清单若存在 /path/ 文件，suffix 则为 `to/file?a=1`\n\n      // 删除末尾的文件名。保持 `/` 结尾\n      let dir = path.replace(/[^/]*$/, '')\n\n      for (;;) {\n        fileConf = manifest.get(originPrefix + dir)\n        if (fileConf) {\n          suffix = path.substring(dir.length) + urlObj.search\n          break FIND\n        }\n        if (dir === '/') {\n          break\n        }\n        // 删除末尾的目录名。保持 `/` 结尾\n        dir = dir.replace(/[^/]+\\/$/, '')\n      }\n\n      // 清单中无匹配，直接转发\n      return Network.fetch(req)\n    }\n\n    fileConf.parse()\n\n    let fileHash = ''\n    const hashParam = fileConf.params.get('hash')\n    if (hashParam && hashParam.length === LEN.SHA256_B64) {\n      fileHash = hashParam\n    }\n\n    const range = req.headers.get('range')\n\n    const cacheable = this.enableCacheStorage && fileHash && !range\n    if (cacheable) {\n      const res = await CacheManager.findHash(fileHash)\n      if (res) {\n        return res\n      }\n    }\n\n    const fileLoader = new FileLoader(fileConf, req, this, range, suffix)\n    const promiseObj = promisex<Response>()\n\n    req.signal.addEventListener('abort', () => {\n      const reason = (req.signal as any).reason || 'unknown'\n      fileLoader.abort(reason)\n    })\n\n    // 如果文件只有一个 hash 则不用流模式（必须完整下载才能校验 hash）\n    if (fileHash) {\n      let resArgs: ResponseArgs\n      let resBody: Uint8Array | undefined\n\n      fileLoader.onOpen = (args) => {\n        resArgs = args\n      }\n      fileLoader.onData = (body) => {\n        resBody = body\n      }\n      fileLoader.onEnd = () => {\n        const body = resBody || EMPTY_BUF\n        const res = new Response(body, resArgs)\n\n        if (cacheable && body.length < 1024 * 1024 * 5) {\n          const cacheRes = res.clone()\n          // 字段可在控制台列表中显示，方便调试\n          cacheRes.headers.set('content-length', body.length + '')\n          cacheRes.headers.set('x-raw-url', req.url)\n          CacheManager.addHash(fileHash, cacheRes)\n        }\n        promiseObj.resolve(res)\n      }\n      fileLoader.onError = (err) => {\n        console.warn('[FreeCDN]', err.message, err.urlErrs)\n        promiseObj.reject(err)\n      }\n      fileLoader.open()\n      return promiseObj\n    }\n\n    // 如果文件有多个 hash 或没有 hash，可使用流模式\n    let controller: ReadableStreamDefaultController<Uint8Array>\n\n    const checkPressure = () => {\n      const {desiredSize} = controller\n      if (desiredSize === null) {\n        console.warn('desiredSize is null')\n        return\n      }\n      if (desiredSize <= 0) {\n        fileLoader.pause()\n      } else {\n        fileLoader.resume()\n      }\n    }\n\n    const stream = new ReadableStream({\n      start(c) {\n        controller = c\n      },\n      pull: checkPressure,\n      cancel(reason: any) {\n        console.warn('[FreeCDN] stream cancel:', reason)\n        fileLoader.abort(reason)\n      },\n    })\n\n    fileLoader.onData = (chunk) => {\n      controller.enqueue(chunk)\n      checkPressure()\n    }\n    fileLoader.onEnd = () => {\n      controller.close()\n    }\n    fileLoader.onError = (err) => {\n      controller.error(err)\n      console.warn('[FreeCDN]', err.message, err.urlErrs)\n      promiseObj.reject(err)\n    }\n    fileLoader.onOpen = (args) => {\n      const res = new Response(stream, args)\n      promiseObj.resolve(res)\n    }\n    fileLoader.open()\n    return promiseObj\n  }\n\n  public async fetchText(url: string) {\n    const res = await this.fetch(url)\n    return res.text()\n  }\n\n  public async fetchBin(url: string) {\n    const res = await this.fetch(url)\n    const buf = await res.arrayBuffer()\n    return new Uint8Array(buf)\n  }\n\n  public async fetchBlob(url: string) {\n    const res = await this.fetch(url)\n    const buf = await res.arrayBuffer()\n    const type = res.headers.get('content-type') || ''\n    return new Blob([buf], {type})\n  }\n\n  public async update() {\n    if (this.updater) {\n      return this.updater.update()\n    }\n    return false\n  }\n\n  public async setPublicKey(keyB64: string) {\n    if (keyB64.length !== LEN.PUBKEY_B64) {\n      keyB64 = `MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE${keyB64}==`\n    }\n    await KeyManager.set(keyB64)\n  }\n\n  public async init() {\n    console.assert(!this.inited)\n    this.inited = true\n\n    await globalInit()\n\n    if (this.updater) {\n      await this.updater.init()\n    }\n  }\n}","//\n// Promise Utils\n//\ntype may_async<T> = T | Promise<T>\n\ntype resolve_t<T> = (value: may_async<T>) => void\ntype reject_t = (reason?: any) => void\n\n\ninterface PromiseX<T = void> extends Promise<T> {\n  readonly resolve: resolve_t<T>\n  readonly reject: reject_t\n}\n\n// non-callback style Promise\nfunction promisex<T = void>() : PromiseX<T> {\n  let resolve: resolve_t<T>\n  let reject: reject_t\n\n  const p = new Promise((a, b) => {\n    resolve = a\n    reject = b\n  }) as PromiseX<T>\n\n  // @ts-ignore\n  p.resolve = resolve\n\n  // @ts-ignore\n  p.reject = reject\n\n  return p\n}\n\n// faster than instanceof\nfunction isPromise(obj: any /* except nullable */ | Promise<any>) : obj is Promise<any> {\n  return typeof obj.then === 'function'\n}","///<reference path=\"../../core-lib/src/freecdn.ts\"/>\n///<reference path=\"../../core-lib/src/promisex.ts\"/>\n///<reference path=\"hook.ts\"/>\n\n\ndeclare const Q: any[]\n\n\nnamespace Sw {\n  const GLOBAL: ServiceWorkerGlobalScope = self as any\n\n  const mLoaderJsRes = new Response('/* freecdn is installed */', {\n    headers: {\n      'content-type': 'text/javascript',\n      'cache-control': 'max-age=3600',\n    },\n  })\n\n  let mFreeCDN: FreeCDN\n\n  let mIniting: PromiseX | null\n  let mResUrlMap: WeakMap<Response, string>\n\n\n  // 共享模式（脚本通过业务方的 SW 引入）\n  function sharedModeInit() {\n    Hook.func(GLOBAL, 'fetch', oldFn => sharedModeHandler)\n\n    Hook.func(Cache.prototype, 'add', oldFn => async function(req) {\n      const res = await sharedModeHandler(req)\n      await this.put(req, res)\n    })\n\n    Hook.func(Cache.prototype, 'addAll', oldFn => async function(reqs) {\n      const tasks = reqs.map(req => this.add(req))\n      await Promise.all(tasks)\n    })\n\n    mResUrlMap = new WeakMap()\n\n    // 由于自定义的 Response 对象 url 为空，因此通过 hook 的方式保留原始 url\n    Hook.prop(Response.prototype, 'url',\n      getter => function() {\n        return mResUrlMap.get(this) || getter.call(this)\n      },\n      /* setter */ null\n    )\n\n    Hook.func(Response.prototype, 'clone', oldFn => function() {\n      const res = oldFn.call(this)\n      const url = mResUrlMap.get(this)\n      if (url) {\n        mResUrlMap.set(res, url)\n      }\n      return res\n    })\n  }\n\n  async function sharedModeHandler(input: RequestInfo, init?: RequestInit) {\n    if (mIniting) {\n      // freecdn 仍在初始化中（例如加载清单文件）\n      await mIniting\n    }\n    const req = (input instanceof Request && !init)\n      ? input\n      : new Request(input, init)\n\n    const res = await mFreeCDN.fetch(req)\n    mResUrlMap.set(res, req.url)\n    return res\n  }\n\n  // 独占模式（通过 freecdn-loader.min.js 引入）\n  function loaderModeInit() {\n    type tuple = Parameters<typeof loaderModeHandler>\n\n    // 重写 Q.push，这样 loader-js 可直接传递 event 和 promise\n    Q.push = loaderModeHandler as any\n\n    while (Q.length) {\n      const args = Q.splice(0, 3) as tuple\n      loaderModeHandler(...args)\n    }\n  }\n\n  function loaderModeHandler(\n    e: FetchEvent,\n    resolve: resolve_t<Response>,\n    reject: reject_t,\n  ) {\n    const req = e.request\n\n    // debug\n    if (req.url.endsWith('/freecdn-update')) {\n      mFreeCDN.update().then(result => {\n        const res = new Response('updated. success: ' + result, {\n          headers: {\n            'content-type': 'text/html',\n          },\n        })\n        resolve(res)\n      })\n      return\n    }\n\n    if (req.url === MY_URL) {\n      resolve(mLoaderJsRes.clone())\n      return\n    }\n\n    mFreeCDN.fetch(req).then(resolve, reject)\n  }\n\n  async function main() {\n    mFreeCDN = new FreeCDN('freecdn-internal/freecdn-manifest.txt')\n\n    const isSharedMode = !!(GLOBAL as any).FREECDN_SHARED_MODE\n\n    let publicKey: string | undefined\n\n    if (isSharedMode) {\n      mFreeCDN.enableCacheStorage = false\n      mIniting = promisex()\n\n      // 在此之前不要使用 await，否则安装 hook 会被推迟，导致初始化时无法触发 hook\n      sharedModeInit()\n      publicKey = (GLOBAL as any).FREECDN_PUBLIC_KEY\n    } else {\n      publicKey = Q.shift()\n    }\n\n    if (publicKey) {\n      await mFreeCDN.setPublicKey(publicKey)\n    }\n    await mFreeCDN.init()\n\n    if (isSharedMode) {\n      mIniting?.resolve()\n      mIniting = null\n    } else {\n      loaderModeInit()\n    }\n\n    console.log('[FreeCDN] service worker inited')\n  }\n  main()\n}","declare const BR_GLUE_HASH: string\ndeclare const BR_WASM_HASH: string\n\nconst enum ParamBrConf {\n  WASM_LOAD_TIMEOUT = 1000 * 20,\n  IN_BUF_LEN = 1024 * 128,\n  OUT_BUF_LEN = 1024 * 512,\n}\n\nclass ParamBr extends ParamBase {\n  private static hasErr = false\n  private static signal: PromiseX | undefined\n  private static asmMod: any\n\n  private static inPtr: number\n  private static outPtr: number\n\n\n  private static async init() {\n    if (this.signal) {\n      return\n    }\n    this.signal = promisex()\n\n    const BR_WASM_PATH = `${INTERNAL_PATH}/br/br.wasm`\n    const BR_GLUE_PATH = `${INTERNAL_PATH}/br/` + (IS_DEBUG ? 'br.js' : 'br.min.js')\n\n    const BR_MANIFEST = IS_DEBUG ? '' : `\n${BR_WASM_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.wasm\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.wasm\n\thash=${BR_WASM_HASH}\n\n${BR_GLUE_PATH}\n\thttps://cdn.jsdelivr.net/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://unpkg.com/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://code.bdstatic.com/npm/freecdn-js@${VER}/dist/br/br.min.js\n\thttps://npm.elemecdn.com/freecdn-js@${VER}/dist/br/br.min.js\n\thash=${BR_GLUE_HASH}\n`\n    const onError = () => {\n      this.hasErr = true\n      this.signal?.resolve()\n    }\n    const timer = setTimeout(onError, ParamBrConf.WASM_LOAD_TIMEOUT)\n\n    const asmMod: any = {\n      locateFile: () => BR_WASM_PATH,\n      onRuntimeInitialized: () => {\n        this.inPtr = asmMod._AllocInBuf(ParamBrConf.IN_BUF_LEN)\n        this.outPtr = asmMod._AllocOutBuf(ParamBrConf.OUT_BUF_LEN)\n\n        clearTimeout(timer)\n        this.signal?.resolve()\n        this.signal = undefined\n      },\n      onAbort: (reason: any) => {\n        console.warn('[FreeCDN/Br] wasm onAbort:', reason)\n        onError()\n      },\n      print: (msg: any) => {\n        console.warn('[FreeCDN/Br] wasm print:', msg)\n      },\n      printErr: (err: any) => {\n        console.warn('[FreeCDN/Br] wasm printErr:', err)\n      },\n    }\n\n    const manifest = new Manifest()\n    await manifest.parse(BR_MANIFEST)\n\n    const cdn = new FreeCDN()\n    cdn.manifest = manifest\n\n    const onFetch: typeof cdn.fetch = async (...args) => {\n      try {\n        return await cdn.fetch(...args)\n      } catch (err) {\n        console.warn('[FreeCDN/Br] failed to load wasm')\n        onError()\n        throw err\n      }\n    }\n    try {\n      const js = await cdn.fetchText(BR_GLUE_PATH)\n      const fn = Function('Module', 'fetch', js)\n      fn(asmMod, onFetch)\n    } catch {\n      console.warn('[FreeCDN/Br] failed to execute glue js')\n      onError()\n      return\n    }\n    this.asmMod = asmMod\n  }\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    if (conf === 'on') {\n      if (!this.asmMod) {\n        this.init()\n      }\n      return []\n    }\n    return 'invalid value'\n  }\n\n\n  private state = 0\n\n  public constructor() {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    resArgs.contentLen = -1\n  }\n\n  public async onData(chunk: Uint8Array) {\n    if (ParamBr.signal) {\n      await this.waitWasm()\n    }\n    return this.process(chunk)\n  }\n\n  public async onEnd(chunk: Uint8Array) {\n    if (ParamBr.signal) {\n      await this.waitWasm()\n    }\n    // ???\n    let buf = EMPTY_BUF\n    if (chunk.length > 0) {\n      buf = this.process(chunk)\n    }\n    this.destory()\n    return buf\n  }\n\n  private async waitWasm() {\n    await ParamBr.signal\n    if (ParamBr.hasErr) {\n      throw new ParamError('failed to load br decoder')\n    }\n  }\n\n  private process(chunk: Uint8Array) {\n    // brotli/c/include/decode.h\n    const enum RET {\n      ERROR = 0,\n      SUCCESS = 1,\n      NEEDS_MORE_INPUT = 2,\n      NEEDS_MORE_OUTPUT = 3\n    }\n    const asmObj = ParamBr.asmMod\n    const HEAPU8 = asmObj.HEAPU8 as Uint8Array\n\n    if (this.state === 0) {\n      this.state = asmObj._Init()\n    }\n\n    const outBufs: Uint8Array[] = []\n\n    for (let p = 0; p < chunk.length; p += ParamBrConf.IN_BUF_LEN) {\n      const inBuf = chunk.subarray(p, p + ParamBrConf.IN_BUF_LEN)\n      HEAPU8.set(inBuf, ParamBr.inPtr)\n\n      let availIn = inBuf.length\n      let availOut = 0\n      do {\n        const ret = asmObj._Update(this.state, 0, availIn)\n\n        if (ret === RET.ERROR) {\n          const err = asmObj._GetErrorCode()\n          this.destory()\n          throw new ParamError('br decode failed. code: ' + err)\n        }\n        availIn = asmObj._GetAvailableIn()\n        availOut = asmObj._GetAvailableOut()\n\n        const len = ParamBrConf.OUT_BUF_LEN - availOut\n        if (len === 0) {\n          continue\n        }\n        // use slice (copy), not subarray (ref)\n        const outBuf = HEAPU8.slice(ParamBr.outPtr, ParamBr.outPtr + len)\n        outBufs.push(outBuf)\n      } while (asmObj._HasMoreOutput(this.state))\n    }\n\n    if (outBufs.length === 1) {\n      return outBufs[0]\n    }\n    return concatBufs(outBufs)\n  }\n\n  private destory() {\n    ParamBr.asmMod._Destroy(this.state)\n  }\n}\n","const enum ParamBundleState {\n  LOADING = 1,\n}\ntype bundle_file_map_value_t = Response | PromiseX<Response> | ParamBundleState.LOADING\n\ntype bundle_file_map_t = Map<string /* path */, bundle_file_map_value_t>\n\ntype bundle_cache_t = bundle_file_map_t | PromiseX<bundle_file_map_t>\n\n\nclass ParamBundle extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    if (!/^https?:|^\\//.test(conf)) {\n      return 'invalid url'\n    }\n    return [conf]\n  }\n\n  private static cache = new Map<string /* pkgUrl */, bundle_cache_t>()\n\n\n  public constructor(\n    private readonly packUrl: string\n  ) {\n    super()\n  }\n\n  public async onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    if (fileLoader.cdn.isSubReq) {\n      return\n    }\n    let fileMap = ParamBundle.cache.get(this.packUrl)\n    if (!fileMap) {\n      // init\n      fileMap = promisex()\n      ParamBundle.cache.set(this.packUrl, fileMap)\n\n      this.loadPkg(fileLoader, fileMap)\n        .catch(fileMap.reject.bind(fileMap))\n    }\n\n    if (isPromise(fileMap)) {\n      try {\n        fileMap = await fileMap\n      } catch (err) {\n        if (typeof err === 'string') {\n          this.warn(err)\n        } else {\n          console.assert(err instanceof ReaderError, err)\n        }\n        return\n      }\n    }\n\n    let res: bundle_file_map_value_t | undefined\n\n    for (;;) {\n      const path = fileLoader.suffix\n      res = fileMap.get(path)\n      if (res) {\n        break\n      }\n      if (path === '') {\n        res = fileMap.get('index.html')\n        if (res) {\n          fileLoader.suffix = 'index.html'\n        }\n        break\n      }\n      if (path.endsWith('/')) {\n        res = fileMap.get(path + 'index.html')\n        if (res) {\n          fileLoader.suffix = path + 'index.html'\n        }\n        break\n      }\n      if (fileMap.has(path + '/index.html')) {\n        fileLoader.suffix = path + '/index.html'\n        return new Response(\"<script>location.pathname+='/'</script>\")\n      }\n      break\n    }\n    if (!res) {\n      return\n    }\n    if (res === ParamBundleState.LOADING) {\n      // register callback\n      res = promisex()\n      fileMap.set(fileLoader.suffix, res)\n    }\n    if (isPromise(res)) {\n      res = await res\n    }\n    return res.clone()\n  }\n\n  private async loadPkg(fileLoader: FileLoader, fileMapSignal: PromiseX<bundle_file_map_t>) {\n    type conf_t = {\n      [file: string]: {\n        [headerName: string] : string | number\n      }\n    }\n    const fileMap: bundle_file_map_t = new Map()\n\n    const cdn = new FreeCDN()\n    cdn.manifest = fileLoader.cdn.manifest\n    cdn.weightConf = fileLoader.cdn.weightConf\n    cdn.isSubReq = true\n\n    const reader = new Reader()\n    try {\n      const res = await cdn.fetch(this.packUrl)\n      reader.source = res.body!.getReader()\n    } catch {\n      throw 'failed to load'\n    }\n\n    // delimiter `\\r`\n    const delimPos = await reader.findAsync(13)\n    if (delimPos === -1) {\n      throw 'missing header'\n    }\n    const confBin = await reader.readBytesAsync(delimPos + 1)\n    const confMap: conf_t = parseJson(bytesToUtf8(confBin))\n    if (!confMap || typeof confMap !== 'object') {\n      throw 'invalid header'\n    }\n\n    for (const path of Object.keys(confMap)) {\n      fileMap.set(path, ParamBundleState.LOADING)\n    }\n    fileMapSignal.resolve(fileMap)\n\n    for (const [path, headers] of Object.entries(confMap)) {\n      const fileLen = +headers['content-length']\n      if (!(fileLen >= 0)) {\n        throw 'invalid content-length'\n      }\n      const fileBuf = await reader.readBytesAsync(fileLen)\n\n      const res = new Response(fileBuf, {\n        headers: confMap[path] as HeadersInit,\n      })\n      const signal = fileMap.get(path)\n      if (signal !== ParamBundleState.LOADING) {\n        (signal as PromiseX<Response>).resolve(res)\n      }\n      fileMap.set(path, res)\n    }\n  }\n\n  private warn(msg: string) {\n    console.warn('[FreeCDN/Bundle]', msg, this.packUrl)\n  }\n}","const REG_TEXT_MIME = /^text\\/|^application\\/(?:javascript|json)|\\+xml$/\n\n\nclass ParamCharset extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf !== 'off') {\n      return [conf]\n    }\n  }\n\n\n  public constructor(\n    private readonly charset: string\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    const type = resArgs.headers.get('content-type') || ''\n    if (REG_TEXT_MIME.test(type)) {\n      resArgs.headers.set('content-type', type + '; charset=' + this.charset)\n    }\n  }\n}\n","class ParamConcat extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'off') {\n      return\n    }\n    const urls = splitList(conf)\n    if (urls.length === 0) {\n      return 'missing url'\n    }\n    let partLen = parseByteUnit(urls[0])\n    if (partLen > 0) {\n      urls.shift()\n    } else {\n      partLen = -1\n    }\n    for (const url of urls) {\n      if (!/^https?:|^\\//.test(url)) {\n        return 'invalid url'\n      }\n    }\n    return [partLen, urls]\n  }\n\n\n  public constructor(\n    private readonly partLen: number,\n    private readonly urls: string\n  ) {\n    super()\n  }\n\n  private abortCtrl: AbortController | undefined\n\n  public async onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    if (fileLoader.cdn.isSubReq) {\n      return\n    }\n    const manifest = fileLoader.cdn.manifest!\n    const fileInfos: {url: string, size: number}[] = []\n\n    const REG_WILDCARD = /\\[(\\d+)-(\\d+)\\]/\n\n    for (const url of this.urls) {\n      let beginNum = 0\n      let endNum = 0\n      let padNum = 0\n\n      // 通配格式 [begin-end]\n      // begin 左侧可有多个 0，用于固定数字长度\n      const m = url.match(REG_WILDCARD)\n      if (m) {\n        const beginStr = m[1]\n        beginNum = +beginStr\n        endNum = +m[2]\n        padNum = beginStr[0] === '0' ? beginStr.length : 0\n      }\n\n      for (let i = beginNum; i <= endNum; i++) {\n        const realUrl = m\n          ? url.replace(REG_WILDCARD, (i + '').padStart(padNum, '0'))\n          : url\n\n        const fileConf = manifest.get(realUrl)\n        if (fileConf) {\n          fileConf.parse()\n\n          // 如果文件在清单中，优先使用 size 参数作为长度\n          const size = fileConf.params.get('size')\n          fileInfos.push({\n            url: fileConf.name,\n            size: size ? +size : this.partLen,\n          })\n        } else {\n          fileInfos.push({url: realUrl, size: this.partLen})\n        }\n      }\n    }\n    fileInfos.reverse()\n\n    const headers = new Headers()\n\n    // 排除 range 之前的文件\n    const {rangeBegin} = fileLoader\n    if (rangeBegin && rangeBegin > 0) {\n      let pos = 0\n\n      for (let i = fileInfos.length - 1; i >= 0; i--) {\n        const {size} = fileInfos[i]\n        if (size === -1) {\n          // 文件长度未知，停止排除\n          break\n        }\n        if (pos + size > rangeBegin) {\n          // 当前文件多余部分由 FileLoader 丢弃\n          if (pos) {\n            headers.set('content-range', `bytes ${pos}-`)\n          }\n          break\n        }\n        fileInfos.pop()\n        pos += size\n      }\n    }\n\n    const cdn = new FreeCDN()\n    cdn.manifest = fileLoader.cdn.manifest\n    cdn.weightConf = fileLoader.cdn.weightConf\n    cdn.isSubReq = true\n\n    let reader: ReadableStreamDefaultReader<Uint8Array>\n    let controller: ReadableStreamDefaultController<Uint8Array>\n\n    const openNextFile = async() => {\n      const info = fileInfos.pop()\n      if (!info) {\n        controller.close()\n        return false\n      }\n      this.abortCtrl = new AbortController()\n\n      try {\n        const res = await cdn.fetch(info.url, {\n          signal: this.abortCtrl.signal,\n        })\n        reader = res.body!.getReader()\n      } catch (err) {\n        controller.error(err)\n        return false\n      }\n      return true\n    }\n\n    const readNextChunk = async() => {\n      let buf: Uint8Array | undefined\n      try {\n        const {value} = await reader.read()\n        buf = value\n      } catch (err) {\n        controller.error(err)\n        return\n      }\n      if (buf) {\n        controller.enqueue(buf)\n      } else {\n        if (await openNextFile()) {\n          await readNextChunk()\n        }\n      }\n    }\n\n    const stream = new ReadableStream({\n      async start(c) {\n        controller = c\n        await openNextFile()\n      },\n      pull: readNextChunk,\n    })\n    return new Response(stream, {headers})\n  }\n\n  public onAbort(reason: any) {\n    if (this.abortCtrl) {\n      this.abortCtrl.abort(reason)\n      this.abortCtrl = undefined\n    }\n  }\n}","class ParamData extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onRequest() {\n    return new Response(this.bytes)\n  }\n}\n","class ParamExpires extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const time = parseTime(conf)\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    const seconds = time / 1000 | 0\n    return [seconds]\n  }\n\n\n  public constructor(\n    private readonly seconds: number\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    // 过期时间不小于实际值，防止经常变化的资源无法及时更新\n    const rawMaxAge = (rawRes as any)._maxage\n    const maxAge = rawMaxAge < this.seconds ? rawMaxAge : this.seconds\n\n    resArgs.headers.append('cache-control', 'max-age=' + maxAge)\n  }\n}\n","const enum ParamHashConf {\n  MAX_QUEUE_LEN = 64 * 1024 * 1024\n}\n\nclass ParamHash extends ParamBase {\n\n  public static parseConf(conf: string) {\n    // conf format:\n    // [blksize;]hash1,hash2,...\n    let blkLen = 1e9\n    let hashes = conf\n\n    const pos = conf.indexOf(';')\n    if (pos > 0) {\n      const blkLenStr = conf.substring(0, pos)\n      hashes = conf.substring(pos + 1)\n      blkLen = parseByteUnit(blkLenStr)\n      if (isNaN(blkLen)) {\n        return 'invalid block length'\n      }\n    }\n    const hashBins: Uint8Array[] = []\n    const hashB64s = hashes.split(',')\n\n    // 倒序存储，之后 pop 取出\n    for (let i = hashB64s.length - 1; i !== -1; i--) {\n      const bin = base64Decode(hashB64s[i])\n      if (!bin || bin.length !== LEN.SHA256_BIN) {\n        return 'invalid block hash'\n      }\n      hashBins.push(bin)\n    }\n    return [blkLen, hashBins]\n  }\n\n\n  private readonly reader = new Reader()\n  private hasData = false\n\n  public constructor(\n    private readonly blkLen: number,\n    private readonly hashBins: Uint8Array[]\n  ) {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    this.hasData = true\n    this.reader.feed(chunk)\n\n    if (this.reader.availLen > LEN.MAX_QUEUE) {\n      throw new ParamError('max queue length exceeded')\n    }\n    if (this.reader.availLen < this.blkLen) {\n      return EMPTY_BUF\n    }\n    return this.pull(this.reader.availLen % this.blkLen)\n  }\n\n  public async onEnd(chunk: Uint8Array) {\n    if (chunk.length > 0) {\n      this.reader.feed(chunk)\n    }\n    if (this.reader.availLen === 0) {\n      if (!this.hasData) {\n        await this.verify(EMPTY_BUF)\n      }\n      return EMPTY_BUF\n    }\n    return this.pull(0)\n  }\n\n  private async pull(remain: number) {\n    const blks = this.reader.readBytesSync(this.reader.availLen - remain)\n\n    for (let p = 0; p < blks.length; p += this.blkLen) {\n      const blk = blks.subarray(p, p + this.blkLen)\n      await this.verify(blk)\n    }\n    return blks\n  }\n\n  private async verify(blk: Uint8Array) {\n    const hashExp = this.hashBins.pop()\n    if (!hashExp) {\n      throw new ParamError('missing hash')\n    }\n    const hashGot = await sha256(blk)\n\n    if (!isArrayEqual(hashExp, hashGot)) {\n      const exp = base64Encode(hashExp)\n      const got = base64Encode(hashGot)\n      throw new ParamError(`hash incorrect. expected: ${exp}, but got: ${got}`)\n    }\n  }\n}","class ParamHeaders extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    return ParamReqHeaders.parse(conf)\n  }\n\n\n  public constructor(\n    private readonly headers: readonly [string, string][],\n    private readonly preserveAll: boolean\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    if (this.preserveAll) {\n      for (const [k, v] of rawRes.headers) {\n        resArgs.headers.set(k, v)\n      }\n      for (const [k, v] of this.headers) {\n        resArgs.headers.set(k, v)\n      }\n      return\n    }\n\n    for (const [k, v] of this.headers) {\n      if (v === '') {\n        // preserve\n        const rawVal = rawRes.headers.get(k)\n        if (rawVal !== null) {\n          resArgs.headers.set(k, rawVal)\n        }\n      } else {\n        // add\n        resArgs.headers.set(k, v)\n      }\n    }\n  }\n}\n","class ParamOpenTimeout extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const time = parseTime(conf)\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    return [time]\n  }\n\n\n  private tid = 0\n\n\n  public constructor(\n    private readonly time: number,\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    this.tid = setTimeout(() => {\n      const delay = Math.max(this.time, 5000)\n      fileLoader.loadNextUrl(delay)\n    }, this.time)\n  }\n\n  public onResponse() {\n    this.stopTimer()\n  }\n\n  public onError() {\n    this.stopTimer()\n  }\n\n  public onAbort() {\n    this.stopTimer()\n  }\n\n  private stopTimer() {\n    if (this.tid > 0) {\n      clearTimeout(this.tid)\n      this.tid = 0\n    }\n  }\n}\n","class ParamPos extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const pos = parseByteUnit(conf)\n    if (isNaN(pos)) {\n      return 'invalid byte format'\n    }\n    if (pos === 0) {\n      return\n    }\n    return [pos]\n  }\n\n\n  public constructor(\n    private remain: number\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    if (resArgs.contentLen >= 0) {\n      if ((resArgs.contentLen -= this.remain) < 0) {\n        resArgs.contentLen = 0\n      }\n    }\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.remain <= 0) {\n      return chunk\n    }\n    const remain = (this.remain -= chunk.length)\n    if (remain >= 0) {\n      return EMPTY_BUF\n    }\n    // if remain < 0, return last -remain bytes\n    return chunk.subarray(remain)\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}","class ParamPrefix extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  private done = false\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    if (resArgs.contentLen >= 0) {\n      resArgs.contentLen += this.bytes.length\n    }\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.done) {\n      return chunk\n    }\n    this.done = true\n    return concatBufs([this.bytes, chunk])\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    // for empty file\n    return this.onData(chunk)\n  }\n}\n","class ParamRecvTimeout extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const [n, t] = conf.split('/')\n    const bytes = parseByteUnit(n)\n    const time = parseTime(t)\n    if (isNaN(bytes)) {\n      return 'invalid byte format'\n    }\n    if (isNaN(time)) {\n      return 'invalid time format'\n    }\n    return [bytes, time]\n  }\n\n\n  private fileLoader!: FileLoader\n  private tid = 0\n  private sum = 0\n\n  public constructor(\n    private readonly bytes: number,\n    private readonly time: number,\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    this.fileLoader = fileLoader\n  }\n\n  public onResponse() {\n    this.tid = setInterval(() => {\n      if (this.sum <= this.bytes) {\n        this.stopTimer()\n        this.fileLoader.loadNextUrl()\n      }\n      this.sum = 0\n    }, this.time)\n  }\n\n  public onData(chunk: Uint8Array) {\n    this.sum += chunk.length\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    this.stopTimer()\n    return chunk\n  }\n\n  public onError() {\n    this.stopTimer()\n  }\n\n  public onAbort() {\n    this.stopTimer()\n  }\n\n  private stopTimer() {\n    if (this.tid > 0) {\n      clearInterval(this.tid)\n      this.tid = 0\n    }\n  }\n}\n","const REG_REFFERER_POLICY = /^(?:no-referrer|unsafe-url|origin|same-origin|strict-origin|no-referrer-when-downgrade|origin-when-cross-origin|strict-origin-when-cross-origin)$/\n\n\nclass ParamReferrerPolicy extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf === 'raw') {\n      return ['']\n    }\n    if (!REG_REFFERER_POLICY.test(conf)) {\n      return 'invalid value'\n    }\n    return [conf]\n  }\n\n\n  public constructor(\n    private readonly policy: ReferrerPolicy\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    reqArgs.referrerPolicy = this.policy || fileLoader.rawReq.referrerPolicy\n  }\n}\n","class ParamReqHeaders extends ParamBase {\n  public static reuse = true\n\n  public static parse(conf: string) {\n    const headers: [string, string][] = []\n    let preserveAll = false\n\n    // {\"header-to-preserve\": \"\", \"header-to-add\": \"val\"}\n    const map = parseJson(conf)\n    if (typeof map !== 'object') {\n      return 'invalid format'\n    }\n    for (const [k, v] of Object.entries(map)) {\n      if (k === '*') {\n        preserveAll = true\n      } else {\n        headers.push([k, v + ''])\n      }\n    }\n    return [headers, preserveAll]\n  }\n\n  public static parseConf(conf: string) {\n    return this.parse(conf)\n  }\n\n\n  public constructor(\n    private readonly headers: readonly [string, string][],\n    private readonly preserveAll: boolean\n  ) {\n    super()\n  }\n\n  public onRequest(reqArgs: RequestArgs, fileLoader: FileLoader) {\n    const {rawReq} = fileLoader\n\n    if (this.preserveAll) {\n      for (const [k, v] of rawReq.headers) {\n        reqArgs.headers.set(k, v)\n      }\n      for (const [k, v] of this.headers) {\n        reqArgs.headers.set(k, v)\n      }\n      return\n    }\n\n    for (const [k, v] of this.headers) {\n      if (k === 'referer') {\n        reqArgs.referrer = v || rawReq.referrer\n        continue\n      }\n      if (v === '') {\n        // preserve\n        const rawVal = rawReq.headers.get(k)\n        if (rawVal !== null) {\n          reqArgs.headers.set(k, rawVal)\n        }\n      } else {\n        // add\n        reqArgs.headers.set(k, v)\n      }\n    }\n  }\n}\n","class ParamSize extends ParamBase {\n\n  public static parseConf(conf: string) {\n    const size = parseByteUnit(conf)\n    if (isNaN(size)) {\n      return 'invalid byte format'\n    }\n    return [size]\n  }\n\n\n  public constructor(\n    private remain: number\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    resArgs.contentLen = this.remain\n  }\n\n  public onData(chunk: Uint8Array) {\n    if (this.remain <= 0) {\n      return EMPTY_BUF\n    }\n    const remain = (this.remain -= chunk.length)\n    if (remain >= 0) {\n      return chunk\n    }\n    // remain < 0, return [0, END + remain)\n    return chunk.subarray(0, remain)\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}\n","class ParamStream extends ParamBase {\n\n  public static parseConf(conf: string) {\n    if (conf === 'on') {\n      // default\n      return\n    }\n    if (conf === 'off') {\n      return []\n    }\n    return 'invalid value'\n  }\n\n\n  private readonly queueArr: Uint8Array[] = []\n  private queueLen = 0\n\n  public constructor() {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    this.queueLen += chunk.length\n    if (this.queueLen > LEN.MAX_QUEUE) {\n      throw new ParamError('max queue length exceeded')\n    }\n    this.queueArr.push(chunk)\n    return EMPTY_BUF\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    if (chunk.length > 0) {\n      // unlikely\n      this.onData(chunk)\n    }\n    return concatBufs(this.queueArr, this.queueLen)\n  }\n}\n","class ParamSuffix extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const bytes = parseStrOrB64(conf)\n    if (!bytes) {\n      return 'invalid format'\n    }\n    return [bytes]\n  }\n\n\n  public constructor(\n    private readonly bytes: Uint8Array\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs) {\n    if (resArgs.contentLen >= 0) {\n      resArgs.contentLen += this.bytes.length\n    }\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    if (chunk.length === 0) {\n      return this.bytes\n    }\n    return concatBufs([chunk, this.bytes])\n  }\n}\n","class ParamValidStatus extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    if (conf === '*') {\n      return\n    }\n    const codes = conf.split(',').map(Number)\n    return [codes]\n  }\n\n\n  public constructor(\n    private readonly codes: number[]\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    if (!this.codes.includes(rawRes.status)) {\n      throw new ParamError('invalid http status: ' + rawRes.status)\n    }\n  }\n}\n","class ParamXor extends ParamBase {\n  public static reuse = true\n\n  public static parseConf(conf: string) {\n    const key = +conf >>> 0\n    if (key > 255) {\n      return 'invalid value'\n    }\n    return [key]\n  }\n\n\n  public constructor(\n    private readonly key: number\n  ) {\n    super()\n  }\n\n  public onData(chunk: Uint8Array) {\n    // TODO: u32 optimize\n    for (let i = 0; i < chunk.length; i++) {\n      chunk[i] ^= this.key\n    }\n    return chunk\n  }\n\n  public onEnd(chunk: Uint8Array) {\n    return this.onData(chunk)\n  }\n}\n","namespace CacheManager {\n  let mCache: Cache\n\n  // TODO: LRU\n\n  export async function init() {\n    if (!mCache) {\n      mCache = await caches.open('.freecdn')\n    }\n  }\n\n  export async function findHash(hash: string) {\n    const res = await findCache('/' + hash)\n    if (!res) {\n      return\n    }\n    const buf = await res.clone().arrayBuffer()\n    const bin = new Uint8Array(buf)\n    const hashGot = await sha256(bin)\n    const hashExp = base64Decode(hash)\n    if (!hashExp) {\n      return\n    }\n    if (!isArrayEqual(hashGot, hashExp)) {\n      console.warn('[FreeCDN/CacheManager] bad cache:', hash)\n      delCache('/' + hash)\n      return\n    }\n    return res\n  }\n\n  export async function addHash(hash: string, res: Response) {\n    await addCache('/' + hash, res)\n  }\n\n  export function findCache(reqInfo: RequestInfo) {\n    return mCache.match(reqInfo)\n  }\n\n  export async function addCache(reqInfo: RequestInfo, res: Response) {\n    try {\n      await mCache.put(reqInfo, res)\n    } catch {\n    }\n  }\n\n  export function delCache(reqInfo: RequestInfo) {\n    return mCache.delete(reqInfo)\n  }\n}\n","namespace Network {\n  const enum Conf {\n    DEFAULT_MAX_AGE = 300,\n  }\n\n  const mDatabase = new Database('.freecdn')\n\n  interface UrlInfo {\n    url: string,\n    status: number,\n    expire: number,\n  }\n  const mUrlInfoMap = new Map<string, UrlInfo>()\n\n  function addUrlInfo(url: string, status: number, expire: number) {\n    if (mUrlInfoMap.has(url)) {\n      return\n    }\n    const info: UrlInfo = {url, status, expire}\n    mUrlInfoMap.set(url, info)\n\n    mDatabase.put('cache', info)\n  }\n\n\n  class HostInfo {\n    public lastDoneTime = 0\n    public lastErrTime = 0\n\n    public pending = 0\n    // public protocol = 1\n\n    public errNum = 0\n    public reqNum = 0\n    public reqTimeAvg = -1\n    public reqTimeSum = 0\n    // public speedAvg = 0\n    // public speedSum = 0\n  }\n  const mHostInfoMap = new Map<string, HostInfo>()\n\n  function getHostInfo(host: string) {\n    let info = mHostInfoMap.get(host)\n    if (!info) {\n      info = new HostInfo()\n      mHostInfoMap.set(host, info)\n    }\n    return info\n  }\n\n  function getHostWeight(hostInfo: HostInfo, now: number) {\n    // TODO: ...\n    if (hostInfo.reqTimeAvg !== -1) {\n      const delayScore = 100 - hostInfo.reqTimeAvg * 0.2\n      return Math.max(delayScore, 10)\n    }\n    return 50\n  }\n\n  export function getUrlWeight(url: string, now: number, hostWeightMap: Map<string, number>) {\n    const urlInfo = mUrlInfoMap.get(url)\n    if (urlInfo && urlInfo.expire < now) {\n      if (urlInfo.status !== 200) {\n        return -2\n      }\n      // 该 URL 之前加载过\n      // expire 值越大，已过期的概率越小，权重越高\n      return 100 + urlInfo.expire\n    }\n\n    // 当前站点默认权重 -1，低于免费站点，减少流量成本\n    if (url[0] === '/') {\n      return hostWeightMap.get(MY_HOST) ?? -1\n    }\n    const host = getHostFromUrl(url)\n    const hostInfo = mHostInfoMap.get(host)\n    if (!hostInfo) {\n      return hostWeightMap.get(host) ?? 50\n    }\n    return getHostWeight(hostInfo, now)\n  }\n\n  export async function fetch(req: Request) {\n    const host = getHostFromUrl(req.url)\n    const hostInfo = getHostInfo(host)\n    hostInfo.pending++\n\n    const t0 = getTimeSec()\n\n    let res: Response\n    try {\n      res = await NATIVE_FETCH(req)\n    } catch (err: any) {\n      parseFetchError(err, req, hostInfo, t0)\n      // throw err\n      res =  new Response();\n    } finally {\n      hostInfo.pending--\n    }\n\n    const maxAge = parseMaxAge(res.headers, t0)\n\n    switch (res.status) {\n    case 200:\n      if (req.cache !== 'no-store') {\n        if (maxAge > 60) {\n          addUrlInfo(res.url, 200, t0 + maxAge)\n        }\n      }\n      break\n    case 404:\n      addUrlInfo(res.url, 404, t0 + maxAge)\n      break\n    }\n\n    // 过期时间会在 expires 参数中会用到，避免重复分析\n    (res as any)._maxage = maxAge\n\n    return res\n  }\n\n  const REG_NET_ERR = /^Failed to fetch|^NetworkError|^Could not connect/\n\n  function parseFetchError(err: Error, req: Request, hostInfo: HostInfo, t0: number) {\n    if (!navigator.onLine) {\n      return\n    }\n    if (!REG_NET_ERR.test(err.message)) {\n      return\n    }\n    if (req.cache === 'only-if-cached') {\n      return\n    }\n    hostInfo.errNum++\n    hostInfo.lastErrTime = t0\n  }\n\n  function parseMaxAge(headers: Headers, t0: number) {\n    const cacheControl = headers.get('cache-control')\n    if (cacheControl !== null) {\n      if (cacheControl.includes('no-cache')) {\n        return 0\n      }\n      const m = cacheControl.match(/max-age=\"?(\\d+)\"?/)\n      if (m) {\n        return +m[1]\n      }\n    }\n    const expires = headers.get('expires')\n    if (expires !== null) {\n      const t1 = Date.parse(expires) / 1000\n      if (t1) {\n        return (t1 - t0) | 0\n      }\n    }\n    return Conf.DEFAULT_MAX_AGE\n  }\n\n\n  function parseEntries(list: PerformanceEntryList) {\n    const timeBase = performance.timeOrigin\n\n    for (const record of list as PerformanceResourceTiming[]) {\n      const host = getHostFromUrl(record.name)\n      const info = getHostInfo(host)\n\n      info.reqNum++\n      info.lastDoneTime = timeBase + record.responseEnd\n\n      // time-allow-origin\n      if (record.responseStart > 0) {\n        const reqTime = record.responseStart - record.requestStart\n        info.reqTimeSum += reqTime\n        info.reqTimeAvg = info.reqTimeSum / info.reqNum\n      }\n    }\n  }\n\n\n  export async function init() {\n    await mDatabase.open({\n      'cache': {\n        keyPath: 'url'\n      },\n    })\n\n    const now = getTimeSec()\n\n    // 读取 URL 历史信息\n    await mDatabase.enum('cache', (item: UrlInfo) => {\n      if (item.expire < now) {\n        mDatabase.delete('cache', item.url)\n        return\n      }\n      mUrlInfoMap.set(item.url, item)\n    })\n\n    // 跟踪每个 URL 的性能指标\n    const entries = performance.getEntriesByType('resource')\n    parseEntries(entries)\n\n    const observer = new PerformanceObserver(entryList => {\n      const entries = entryList.getEntries()\n      parseEntries(entries)\n    })\n    observer.observe({\n      entryTypes: ['resource']\n    })\n  }\n\n\n  export function parseWeightConf(manifest: Manifest) {\n    const zone = navigator.language.toLowerCase()\n    const zone0 = zone.split('-')[0]\n    const weightParams =\n      manifest.getParams('@weight ' + zone) ||\n      manifest.getParams('@weight ' + zone0) ||\n      manifest.getParams('@weight')\n\n    if (!weightParams) {\n      const obj = ZONE_HOST_SCORE[zone] || ZONE_HOST_SCORE['*']\n      return new Map(Object.entries(obj))\n    }\n\n    const map = new Map<string, number>()\n    for (const [k, v] of weightParams) {\n      const num = +v\n      if (isNaN(num)) {\n        continue\n      }\n      map.set(k, num)\n    }\n    return map\n  }\n}\n","class ParamMime extends ParamBase {\n  public static reuse = true\n\n  private static extTypeMap: ReadonlyMap<string, string>\n  static {\n    const map = new Map<string, string>()\n\n    for (const item of MIME_DATA.split(';')) {\n      const [mime, exts] = getPair(item, ':') as string[]\n\n      for (const ext of exts.split(',')) {\n        map.set(ext, mime)\n      }\n    }\n    this.extTypeMap = map\n  }\n\n  public static parseConf(conf: string) {\n    if (conf === 'auto') {\n      // likely\n      return ['']\n    }\n    return [conf]\n  }\n\n\n  public constructor(\n    private readonly mime: string\n  ) {\n    super()\n  }\n\n  public onResponse(resArgs: ResponseArgs, fileLoader: FileLoader, rawRes: Response) {\n    let type: string | undefined\n\n    if (this.mime === '') {\n      const url = fileLoader.getSourceUrl()\n      if (!url.includes('?')) {\n        const m = url.match(/\\.(\\w+)$/)\n        if (m) {\n          const ext = m[1].toLowerCase()\n          type = ParamMime.extTypeMap.get(ext)\n        }\n      }\n      if (!type) {\n        const rawType = rawRes.headers.get('content-type')\n        if (rawType) {\n          type = getPair(rawType, ';')[0]\n        } else {\n          type = 'application/octet-stream'\n        }\n      }\n    } else {\n      type = this.mime\n    }\n    resArgs.headers.set('content-type', type)\n  }\n}\n","const MIME_DATA = 'application/andrew-inset:ez;application/applixware:aw;application/atom+xml:atom;application/atomcat+xml:atomcat;application/atomdeleted+xml:atomdeleted;application/atomsvc+xml:atomsvc;application/atsc-dwd+xml:dwd;application/atsc-held+xml:held;application/atsc-rsat+xml:rsat;application/bdoc:bdoc;application/calendar+xml:xcs;application/ccxml+xml:ccxml;application/cdfx+xml:cdfx;application/cdmi-capability:cdmia;application/cdmi-container:cdmic;application/cdmi-domain:cdmid;application/cdmi-object:cdmio;application/cdmi-queue:cdmiq;application/cu-seeme:cu;application/dash+xml:mpd;application/davmount+xml:davmount;application/docbook+xml:dbk;application/dssc+der:dssc;application/dssc+xml:xdssc;application/ecmascript:ecma,es;application/emma+xml:emma;application/emotionml+xml:emotionml;application/epub+zip:epub;application/exi:exi;application/fdt+xml:fdt;application/font-tdpfr:pfr;application/geo+json:geojson;application/gml+xml:gml;application/gpx+xml:gpx;application/gxf:gxf;application/gzip:gz;application/hjson:hjson;application/hyperstudio:stk;application/inkml+xml:ink,inkml;application/ipfix:ipfix;application/its+xml:its;application/java-archive:jar,war,ear;application/java-serialized-object:ser;application/java-vm:class;application/javascript:js,mjs;application/json:json,map;application/json5:json5;application/jsonml+json:jsonml;application/ld+json:jsonld;application/lgr+xml:lgr;application/lost+xml:lostxml;application/mac-binhex40:hqx;application/mac-compactpro:cpt;application/mads+xml:mads;application/manifest+json:webmanifest;application/marc:mrc;application/marcxml+xml:mrcx;application/mathematica:ma,nb,mb;application/mathml+xml:mathml;application/mbox:mbox;application/mediaservercontrol+xml:mscml;application/metalink+xml:metalink;application/metalink4+xml:meta4;application/mets+xml:mets;application/mmt-aei+xml:maei;application/mmt-usd+xml:musd;application/mods+xml:mods;application/mp21:m21,mp21;application/mp4:mp4s,m4p;application/mrb-consumer+xml:xdf;application/mrb-publish+xml:xdf;application/msword:doc,dot;application/mxf:mxf;application/n-quads:nq;application/n-triples:nt;application/node:cjs;application/octet-stream:bin,dms,lrf,mar,so,dist,distz,pkg,bpk,dump,elc,deploy,exe,dll,deb,dmg,iso,img,msi,msp,msm,buffer;application/oda:oda;application/oebps-package+xml:opf;application/ogg:ogx;application/omdoc+xml:omdoc;application/onenote:onetoc,onetoc2,onetmp,onepkg;application/oxps:oxps;application/p2p-overlay+xml:relo;application/patch-ops-error+xml:xer;application/pdf:pdf;application/pgp-encrypted:pgp;application/pgp-signature:asc,sig;application/pics-rules:prf;application/pkcs10:p10;application/pkcs7-mime:p7m,p7c;application/pkcs7-signature:p7s;application/pkcs8:p8;application/pkix-attr-cert:ac;application/pkix-cert:cer;application/pkix-crl:crl;application/pkix-pkipath:pkipath;application/pkixcmp:pki;application/pls+xml:pls;application/postscript:ai,eps,ps;application/provenance+xml:provx;application/pskc+xml:pskcxml;application/raml+yaml:raml;application/rdf+xml:rdf,owl;application/reginfo+xml:rif;application/relax-ng-compact-syntax:rnc;application/resource-lists+xml:rl;application/resource-lists-diff+xml:rld;application/rls-services+xml:rs;application/route-apd+xml:rapd;application/route-s-tsid+xml:sls;application/route-usd+xml:rusd;application/rpki-ghostbusters:gbr;application/rpki-manifest:mft;application/rpki-roa:roa;application/rsd+xml:rsd;application/rss+xml:rss;application/rtf:rtf;application/sbml+xml:sbml;application/scvp-cv-request:scq;application/scvp-cv-response:scs;application/scvp-vp-request:spq;application/scvp-vp-response:spp;application/sdp:sdp;application/senml+xml:senmlx;application/sensml+xml:sensmlx;application/set-payment-initiation:setpay;application/set-registration-initiation:setreg;application/shf+xml:shf;application/sieve:siv,sieve;application/smil+xml:smi,smil;application/sparql-query:rq;application/sparql-results+xml:srx;application/srgs:gram;application/srgs+xml:grxml;application/sru+xml:sru;application/ssdl+xml:ssdl;application/ssml+xml:ssml;application/swid+xml:swidtag;application/tei+xml:tei,teicorpus;application/thraud+xml:tfi;application/timestamped-data:tsd;application/toml:toml;application/ttml+xml:ttml;application/ubjson:ubj;application/urc-ressheet+xml:rsheet;application/urc-targetdesc+xml:td;application/voicexml+xml:vxml;application/wasm:wasm;application/widget:wgt;application/winhlp:hlp;application/wsdl+xml:wsdl;application/wspolicy+xml:wspolicy;application/xaml+xml:xaml;application/xcap-att+xml:xav;application/xcap-caps+xml:xca;application/xcap-diff+xml:xdf;application/xcap-el+xml:xel;application/xcap-error+xml:xer;application/xcap-ns+xml:xns;application/xenc+xml:xenc;application/xhtml+xml:xhtml,xht;application/xliff+xml:xlf;application/xml:xml,xsl,xsd,rng;application/xml-dtd:dtd;application/xop+xml:xop;application/xproc+xml:xpl;application/xslt+xml:xsl,xslt;application/xspf+xml:xspf;application/xv+xml:mxml,xhvml,xvml,xvm;application/yang:yang;application/yin+xml:yin;application/zip:zip;audio/3gpp:3gpp;audio/adpcm:adp;audio/amr:amr;audio/basic:au,snd;audio/midi:mid,midi,kar,rmi;audio/mobile-xmf:mxmf;audio/mp3:mp3;audio/mp4:m4a,mp4a;audio/mpeg:mpga,mp2,mp2a,mp3,m2a,m3a;audio/ogg:oga,ogg,spx,opus;audio/s3m:s3m;audio/silk:sil;audio/wav:wav;audio/wave:wav;audio/webm:weba;audio/xm:xm;font/collection:ttc;font/otf:otf;font/ttf:ttf;font/woff:woff;font/woff2:woff2;image/aces:exr;image/apng:apng;image/avif:avif;image/bmp:bmp;image/cgm:cgm;image/dicom-rle:drle;image/emf:emf;image/fits:fits;image/g3fax:g3;image/gif:gif;image/heic:heic;image/heic-sequence:heics;image/heif:heif;image/heif-sequence:heifs;image/hej2k:hej2;image/hsj2:hsj2;image/ief:ief;image/jls:jls;image/jp2:jp2,jpg2;image/jpeg:jpeg,jpg,jpe;image/jph:jph;image/jphc:jhc;image/jpm:jpm;image/jpx:jpx,jpf;image/jxr:jxr;image/jxra:jxra;image/jxrs:jxrs;image/jxs:jxs;image/jxsc:jxsc;image/jxsi:jxsi;image/jxss:jxss;image/ktx:ktx;image/ktx2:ktx2;image/png:png;image/sgi:sgi;image/svg+xml:svg,svgz;image/t38:t38;image/tiff:tif,tiff;image/tiff-fx:tfx;image/webp:webp;image/wmf:wmf;message/disposition-notification:disposition-notification;message/global:u8msg;message/global-delivery-status:u8dsn;message/global-disposition-notification:u8mdn;message/global-headers:u8hdr;message/rfc822:eml,mime;model/3mf:3mf;model/gltf+json:gltf;model/gltf-binary:glb;model/iges:igs,iges;model/mesh:msh,mesh,silo;model/mtl:mtl;model/obj:obj;model/stl:stl;model/vrml:wrl,vrml;model/x3d+binary:x3db,x3dbz;model/x3d+fastinfoset:x3db;model/x3d+vrml:x3dv,x3dvz;model/x3d+xml:x3d,x3dz;model/x3d-vrml:x3dv;text/cache-manifest:appcache,manifest;text/calendar:ics,ifb;text/coffeescript:coffee,litcoffee;text/css:css;text/csv:csv;text/html:html,htm,shtml;text/jade:jade;text/jsx:jsx;text/less:less;text/markdown:markdown,md;text/mathml:mml;text/mdx:mdx;text/n3:n3;text/plain:txt,text,conf,def,list,log,in,ini;text/richtext:rtx;text/rtf:rtf;text/sgml:sgml,sgm;text/shex:shex;text/slim:slim,slm;text/spdx:spdx;text/stylus:stylus,styl;text/tab-separated-values:tsv;text/troff:t,tr,roff,man,me,ms;text/turtle:ttl;text/uri-list:uri,uris,urls;text/vcard:vcard;text/vtt:vtt;text/xml:xml;text/yaml:yaml,yml;video/3gpp:3gp,3gpp;video/3gpp2:3g2;video/h261:h261;video/h263:h263;video/h264:h264;video/iso.segment:m4s;video/jpeg:jpgv;video/jpm:jpm,jpgm;video/mj2:mj2,mjp2;video/mp2t:ts;video/mp4:mp4,mp4v,mpg4;video/mpeg:mpeg,mpg,mpe,m1v,m2v;video/ogg:ogv;video/quicktime:qt,mov;video/webm:webm'\n","class Database {\n  private db!: IDBDatabase\n\n\n  public constructor(\n    private readonly name: string\n  ) {\n  }\n\n  public open(opts: {\n    [table: string] : IDBObjectStoreParameters\n  }) {\n    const s = promisex()\n    const req = indexedDB.open(this.name)\n\n    req.onsuccess = () => {\n      const idb = req.result\n      this.db = idb\n\n      idb.onclose = () => {\n        console.warn('[FreeCDN/Database] indexedDB disconnected, reopen...')\n        this.open(opts)\n      }\n      s.resolve()\n    }\n    req.onerror = (e) => {\n      console.warn('[FreeCDN/Database] indexedDB open error:', e)\n      s.reject(req.error)\n    }\n    req.onupgradeneeded = () => {\n      const idb = req.result\n      for (const [k, v] of Object.entries(opts)) {\n        idb.createObjectStore(k, v)\n      }\n    }\n    return s\n  }\n\n  public close() {\n    this.db.close()\n  }\n\n  public get(table: string, key: any) {\n    const s = promisex<any>()\n    const obj = this.getStore(table, 'readonly')\n    const req = obj.get(key)\n\n    req.onsuccess = () => {\n      s.resolve(req.result)\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public put(table: string, record: any) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readwrite')\n    const req = obj.put(record)\n\n    req.onsuccess = () => {\n      s.resolve()\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public delete(table: string, key: any) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readwrite')\n    const req = obj.delete(key)\n\n    req.onsuccess = () => {\n      s.resolve()\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  public enum(\n    table: string,\n    callback: (result: any) => boolean | void,\n    ...args: Parameters<typeof IDBObjectStore.prototype.openCursor>\n  ) {\n    const s = promisex()\n    const obj = this.getStore(table, 'readonly')\n    const req = obj.openCursor(...args)\n\n    req.onsuccess = () => {\n      const {result} = req\n      if (!result) {\n        s.resolve()\n        return\n      }\n      const ret = callback(result.value)\n      if (ret !== false) {\n        result.continue()\n      }\n    }\n    req.onerror = () => {\n      s.reject(req.error)\n    }\n    return s\n  }\n\n  private getStore(table: string, mode: IDBTransactionMode) {\n    return this.db\n      .transaction(table, mode)\n      .objectStore(table)\n  }\n}\n","class ReaderError extends Error {\n  public constructor(message: string) {\n    super(message)\n  }\n}\n\nclass Reader {\n  /*\n   * chunks:\n   * |-------------------------------------|\n   * | 0                 |  1  |  2  | ... |\n   * | used       : free | ... | ... | ... |\n   * |<- offset -> <------ availLen ------>|\n   */\n  private readonly chunks: Uint8Array[] = []\n  private offset = 0\n\n  public availLen = 0\n  public source?: ReadableStreamDefaultReader<Uint8Array>\n\n\n  private async pull(len: number) {\n    do {\n      let buf: Uint8Array | undefined\n      try {\n        const {value} = await this.source!.read()\n        buf = value\n      } catch (err: any) {\n        throw new ReaderError(err.message)\n      }\n      if (!buf) {\n        return false\n      }\n      this.feed(buf)\n    } while (this.availLen < len)\n    return true\n  }\n\n  /**\n   * @param chunk chunk.length > 0\n   */\n  public feed(chunk: Uint8Array) {\n    this.chunks.push(chunk)\n    this.availLen += chunk.length\n  }\n\n  /**\n   * @param len len > 0 && len <= availLen\n   */\n  public readBytesSync(len: number) {\n    this.availLen -= len\n\n    let ret: Uint8Array\n    let pos = 0\n    let i = 0\n\n    if (this.offset) {\n      const buf = this.chunks[0]\n      const end = this.offset + len\n      const slice = buf.subarray(this.offset, end)\n\n      if (end < buf.length) {\n        this.offset += len\n        return slice\n      }\n      this.offset = 0\n\n      if (end === buf.length) {\n        this.chunks.shift()\n        return slice\n      }\n      ret = new Uint8Array(len)\n      ret.set(slice, 0)\n\n      pos = slice.length\n      i = 1\n    } else {\n      ret = new Uint8Array(len)\n    }\n\n    do {\n      const buf = this.chunks[i]\n      const end = pos + buf.length\n\n      const exceed = end - len\n      if (exceed > 0) {\n        const head = buf.subarray(0, -exceed)\n        ret.set(head, pos)\n        this.offset = head.length\n        break\n      }\n      ret.set(buf, pos)\n      pos = end\n      i++\n    } while (pos < len)\n\n    this.chunks.splice(0, i)\n    return ret\n  }\n\n  public async readBytesAsync(len: number) {\n    if (this.availLen < len) {\n      await this.pull(len)\n    }\n    return this.readBytesSync(len)\n  }\n\n  //\n  // 如果 chunk0 读完还有剩余，可直接读取，性能更高（大概率）\n  // 如果正好读完，或不够读取，则需额外操作\n  //\n  public readU32Sync() {\n    let pos = this.offset\n    let buf = this.chunks[0]\n    if (buf.length - pos > 4) {\n      this.offset += 4\n      this.availLen -= 4\n    } else {\n      buf = this.readBytesSync(4)\n      pos = 0\n    }\n    return (\n      buf[pos + 3] << 24 |\n      buf[pos + 2] << 16 |\n      buf[pos + 1] <<  8 |\n      buf[pos]\n    ) >>> 0\n  }\n\n  public readU16Sync() {\n    let pos = this.offset\n    let buf = this.chunks[0]\n    if (buf.length - pos > 2) {\n      this.offset += 2\n      this.availLen -= 2\n    } else {\n      buf = this.readBytesSync(2)\n      pos = 0\n    }\n    return (\n      buf[pos + 1] << 8 |\n      buf[pos]\n    )\n  }\n\n  public readU8Sync() {\n    let pos = this.offset\n    let buf = this.chunks[0]\n    if (buf.length - pos > 1) {\n      this.offset += 1\n      this.availLen -= 1\n    } else {\n      buf = this.readBytesSync(1)\n      pos = 0\n    }\n    return buf[pos]\n  }\n\n  public async readU32Async() {\n    if (this.availLen < 4) {\n      await this.pull(4)\n    }\n    return this.readU16Sync()\n  }\n\n  public async readU16Async() {\n    if (this.availLen < 2) {\n      await this.pull(2)\n    }\n    return this.readU16Sync()\n  }\n\n  public async readU8Async() {\n    if (this.availLen < 1) {\n      await this.pull(1)\n    }\n    return this.readU8Sync()\n  }\n\n  public async findAsync(byte: number) {\n    if (this.offset) {\n      const pos = this.chunks[0].indexOf(byte, this.offset)\n      if (pos !== -1) {\n        return pos - this.offset\n      }\n    }\n    let sum = this.offset\n    let i = 0\n\n    for (;;) {\n      let buf = this.chunks[i]\n      if (!buf) {\n        if (!await this.pull(1)) {\n          break\n        }\n        buf = this.chunks[i]\n      }\n      const pos = buf.indexOf(byte)\n      if (pos !== -1) {\n        return sum + pos\n      }\n      sum += buf.length\n      i++\n    }\n    return -1\n  }\n}","const TEXT_ENCODER = new TextEncoder()\nconst TEXT_DECODER = new TextDecoder()\n\nfunction utf8ToBytes(str: string) : Uint8Array {\n  return TEXT_ENCODER.encode(str)\n}\n\nfunction bytesToUtf8(bytes: Uint8Array) : string {\n  return TEXT_DECODER.decode(bytes)\n}\n\nfunction bytesToAsc(bytes: Uint8Array) : string {\n  return bytes.reduce((s, v) => s + String.fromCharCode(v), '')\n}\n\nfunction base64Encode(bytes: Uint8Array) : string {\n  return btoa(bytesToAsc(bytes))\n}\n\nfunction base64Decode(str: string) : Uint8Array | undefined {\n  try {\n    str = atob(str)\n  } catch {\n    return\n  }\n  const bin = new Uint8Array(str.length)\n  for (let i = 0; i < bin.length; i++) {\n    bin[i] = str.charCodeAt(i)\n  }\n  return bin\n}\n\nfunction parseJson(str: string) {\n  try {\n    return JSON.parse(str)\n  } catch {\n  }\n}\n\nfunction splitList(str: string) : string[] {\n  str = str.trim()\n  if (!str) {\n    return []\n  }\n  return str.split(/\\s+/)\n}\n\nfunction parseStrOrB64(str: string) : Uint8Array | undefined {\n  // json string\n  if (str[0] === '\"') {\n    str = parseJson(str)\n    if (str === undefined) {\n      return\n    }\n    return utf8ToBytes(str)\n  }\n  // base64\n  return base64Decode(str)\n}\n\nconst TIME_UNIT: {[key: string] : number} = {\n  ''   : 1,\n  'ms' : 1,\n  's'  : 1000,\n  'min': 1000 * 60,\n  'h'  : 1000 * 3600,\n  'd'  : 1000 * 3600 * 24,\n  'y'  : 1000 * 3600 * 24 * 365,\n}\n\nfunction parseTime(str: string) : number {\n  const m = str.match(/^([\\d.]{1,9})(y|d|h|min|s|ms|)$/)\n  if (!m) {\n    return NaN\n  }\n  const [, num, unit] = m\n  return +num * TIME_UNIT[unit]\n}\n\nfunction parseByteUnit(str: string) : number {\n  const m = str.match(/^([\\d.]{1,9})(k|K|M|G|)(i|)(b|B|)$/)\n  if (!m) {\n    return NaN\n  }\n  const [, num, kMG, i, bB] = m\n  const exponent =\n    kMG === 'k' ? 1 :\n    kMG === 'K' ? 1 :\n    kMG === 'M' ? 2 :\n    kMG === 'G' ? 3 : 0\n\n  const base = i ? 1024 : 1000\n  const unit = bB === 'b' ? 8 : 1\n  return +num * base ** exponent / unit\n}\n\nfunction getTimeSec() : number {\n  return Date.now() / 1000 | 0\n}\n\nfunction concatBufs(bufs: Uint8Array[], size = 0) : Uint8Array {\n  if (size === 0) {\n    for (const v of bufs) {\n      size += v.length\n    }\n  }\n  const ret = new Uint8Array(size)\n  let pos = 0\n  for (const v of bufs) {\n    ret.set(v, pos)\n    pos += v.length\n  }\n  return ret\n}\n\n\nfunction isArrayEqual<T>(b1: ArrayLike<T>, b2: ArrayLike<T>) : boolean {\n  if (b1.length !== b2.length) {\n    return false\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n\nfunction getPair(str: string, delim: string) : [string, string?] {\n  const pos = str.indexOf(delim)\n  if (pos === -1) {\n    return [str]\n  }\n  return [\n    str.substring(0, pos),\n    str.substring(pos + delim.length)\n  ]\n}\n\nfunction mergeMap<K, V>(dst: Map<K, V>, src: Iterable<[K, V]>) : void {\n  for (const [k, v] of src) {\n    dst.set(k, v)\n  }\n}\n\n/**\n * @param url absolute or relative url\n */\nfunction stripUrlQuery(url: string) : string {\n  const pos = url.indexOf('?')\n  if (pos === -1) {\n    return url\n  }\n  return url.substring(0, pos)\n}\n\n/**\n * @param url absolute url\n */\nfunction getHostFromUrl(url: string) : string {\n  const m = url.match(/^https?:\\/\\/([^/]+)/) !\n  return m[1]\n}\n\n/**\n * @param url absolute or relative url\n */\nfunction toRelUrl(url: string) : string {\n  if (url.startsWith(ROOT_PATH)) {\n    return url.substring(MY_ORIGIN.length)\n  }\n  return url\n}\n\nasync function sha256(buf: Uint8Array) : Promise<Uint8Array> {\n  const ret = await CRYPTO.digest('SHA-256', buf)\n  return new Uint8Array(ret)\n}\n","const ZONE_HOST_SCORE: {\n  [zone: string]: {\n    [host: string]: number\n  }\n} = {\n  'zh-cn': {\n    'ajax.cdnjs.com': 50,\n    'cdnjs.cloudflare.com': 50,\n    'cdn.jsdelivr.net': 80,\n    'raw.githubusercontent.com': 10,\n    'cdnjs.loli.net': 70,\n    'lib.baomitu.com': 80,\n    'lf6-cdn-tos.bytecdntp.com': 90,\n    'cdn.staticfile.org': 90,\n    'cdn.bootcss.com': 10,\n    'cdn.bootcdn.net': 80,\n    'unpkg.com': 50,\n    'g.alicdn.com': 90,\n    'pagecdn.io': 20,\n    'ajax.aspnetcdn.com': 60,\n    'ajax.googleapis.com': 10,\n    'code.jquery.com': 20,\n    'stackpath.bootstrapcdn.com': 30,\n    'maxcdn.bootstrapcdn.com': 30,\n    'cdn.datatables.net': 40,\n    'twemoji.maxcdn.com': 40,\n  },\n  '*': {\n    'ajax.cdnjs.com': 90,\n    'cdnjs.cloudflare.com': 90,\n    'cdn.jsdelivr.net': 40,\n    'raw.githubusercontent.com': 10,\n    'cdnjs.loli.net': 40,\n    'lib.baomitu.com': 20,\n    'lf6-cdn-tos.bytecdntp.com': 40,\n    'cdn.staticfile.org': 20,\n    'cdn.bootcss.com': 10,\n    'cdn.bootcdn.net': 20,\n    'unpkg.com': 40,\n    'g.alicdn.com': 30,\n    'pagecdn.io': 40,\n    'ajax.aspnetcdn.com': 70,\n    'ajax.googleapis.com': 90,\n    'code.jquery.com': 50,\n    'stackpath.bootstrapcdn.com': 40,\n    'maxcdn.bootstrapcdn.com': 50,\n    'cdn.datatables.net': 50,\n    'twemoji.maxcdn.com': 50,\n  },\n}"]}